(* Module for axiomatizing type "short_short_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_short_integer
 use import "_gnatprove_standard".Main
 use import "int".Int

 type short_short_integer #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -128 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  127
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = short_short_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type short_short_integer__ref #"system.ads" 1 0 0# =
  { mutable short_short_integer__content "model_trace:" : short_short_integer }
 
 function short_short_integer__ref___projection #"system.ads" 1 0 0# 
   (a : short_short_integer__ref) : short_short_integer =
  a.short_short_integer__content
 
 meta "model_projection" function short_short_integer__ref___projection
 
 meta "inline : no" function short_short_integer__ref___projection
 
 val short_short_integer__havoc #"system.ads" 1 0 0# 
   (x : short_short_integer__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "short_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_integer
 use import "_gnatprove_standard".Main
 use import "int".Int

 type short_integer #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -32768 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  32767
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = short_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type short_integer__ref #"system.ads" 1 0 0# =
  { mutable short_integer__content "model_trace:" : short_integer }
 
 function short_integer__ref___projection #"system.ads" 1 0 0# 
   (a : short_integer__ref) : short_integer =
  a.short_integer__content
 
 meta "model_projection" function short_integer__ref___projection
 
 meta "inline : no" function short_integer__ref___projection
 
 val short_integer__havoc #"system.ads" 1 0 0# 
   (x : short_integer__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer
 use import "_gnatprove_standard".Main
 use import "int".Int

 type integer #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -2147483648 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  2147483647
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type integer__ref #"system.ads" 1 0 0# =
  { mutable integer__content "model_trace:" : integer }
 
 function integer__ref___projection #"system.ads" 1 0 0# 
   (a : integer__ref) : integer =
  a.integer__content
 
 meta "model_projection" function integer__ref___projection
 
 meta "inline : no" function integer__ref___projection
 
 val integer__havoc #"system.ads" 1 0 0# 
   (x : integer__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "long_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_integer
 use import "_gnatprove_standard".Main
 use import "int".Int

 type long_integer #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -2147483648 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  2147483647
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = long_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type long_integer__ref #"system.ads" 1 0 0# =
  { mutable long_integer__content "model_trace:" : long_integer }
 
 function long_integer__ref___projection #"system.ads" 1 0 0# 
   (a : long_integer__ref) : long_integer =
  a.long_integer__content
 
 meta "model_projection" function long_integer__ref___projection
 
 meta "inline : no" function long_integer__ref___projection
 
 val long_integer__havoc #"system.ads" 1 0 0# 
   (x : long_integer__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "long_long_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_long_integer
 use import "_gnatprove_standard".Main
 use import "int".Int

 type long_long_integer #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -9223372036854775808 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  9223372036854775807
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = long_long_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type long_long_integer__ref #"system.ads" 1 0 0# =
  { mutable long_long_integer__content "model_trace:" : long_long_integer }
 
 function long_long_integer__ref___projection #"system.ads" 1 0 0# 
   (a : long_long_integer__ref) : long_long_integer =
  a.long_long_integer__content
 
 meta "model_projection" function long_long_integer__ref___projection
 
 meta "inline : no" function long_long_integer__ref___projection
 
 val long_long_integer__havoc #"system.ads" 1 0 0# 
   (x : long_long_integer__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "natural", created in Gnat2Why.Types.Translate_Type *)
module Standard__natural
 use import "_gnatprove_standard".Main
 use import "int".Int

 type natural #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  0
 
 function last #"system.ads" 1 0 0# 
   : int =
  2147483647
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = natural, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type natural__ref #"system.ads" 1 0 0# =
  { mutable natural__content "model_trace:" : natural }
 
 function natural__ref___projection #"system.ads" 1 0 0# 
   (a : natural__ref) : natural =
  a.natural__content
 
 meta "model_projection" function natural__ref___projection
 
 meta "inline : no" function natural__ref___projection
 
 val natural__havoc #"system.ads" 1 0 0# 
   (x : natural__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "positive", created in Gnat2Why.Types.Translate_Type *)
module Standard__positive
 use import "_gnatprove_standard".Main
 use import "int".Int

 type positive #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  1
 
 function last #"system.ads" 1 0 0# 
   : int =
  2147483647
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = positive, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type positive__ref #"system.ads" 1 0 0# =
  { mutable positive__content "model_trace:" : positive }
 
 function positive__ref___projection #"system.ads" 1 0 0# 
   (a : positive__ref) : positive =
  a.positive__content
 
 meta "model_projection" function positive__ref___projection
 
 meta "inline : no" function positive__ref___projection
 
 val positive__havoc #"system.ads" 1 0 0# 
   (x : positive__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "short_float", created in Gnat2Why.Types.Translate_Type *)
module Standard__short_float
 use import "_gnatprove_standard".Main
 use import "real".RealInfix
 use        "_gnatprove_standard".Floating

 type short_float #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : real =
  (-.340282346638528859811704183484516925440.0)
 
 function last #"system.ads" 1 0 0# 
   : real =
  (340282346638528859811704183484516925440.0)
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : real)  =
  ( (first <=. x) /\ (x <=. last) )
 
 clone export "ada__model".Static_Floating_Point with
 type t = short_float, 
 function round_real_tmp = Floating.round_single, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_real
 
 meta "inline : no" function to_real
 
 type short_float__ref #"system.ads" 1 0 0# =
  { mutable short_float__content "model_trace:" : short_float }
 
 function short_float__ref___projection #"system.ads" 1 0 0# 
   (a : short_float__ref) : short_float =
  a.short_float__content
 
 meta "model_projection" function short_float__ref___projection
 
 meta "inline : no" function short_float__ref___projection
 
 val short_float__havoc #"system.ads" 1 0 0# 
   (x : short_float__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "float", created in Gnat2Why.Types.Translate_Type *)
module Standard__float
 use import "_gnatprove_standard".Main
 use import "real".RealInfix
 use        "_gnatprove_standard".Floating

 type float #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : real =
  (-.340282346638528859811704183484516925440.0)
 
 function last #"system.ads" 1 0 0# 
   : real =
  (340282346638528859811704183484516925440.0)
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : real)  =
  ( (first <=. x) /\ (x <=. last) )
 
 clone export "ada__model".Static_Floating_Point with
 type t = float, 
 function round_real_tmp = Floating.round_single, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_real
 
 meta "inline : no" function to_real
 
 type float__ref #"system.ads" 1 0 0# =
  { mutable float__content "model_trace:" : float }
 
 function float__ref___projection #"system.ads" 1 0 0# 
   (a : float__ref) : float =
  a.float__content
 
 meta "model_projection" function float__ref___projection
 
 meta "inline : no" function float__ref___projection
 
 val float__havoc #"system.ads" 1 0 0# 
   (x : float__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "long_float", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_float
 use import "_gnatprove_standard".Main
 use import "real".RealInfix
 use        "_gnatprove_standard".Floating

 type long_float #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : real =
  (-.179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0)
 
 function last #"system.ads" 1 0 0# 
   : real =
  (179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0)
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : real)  =
  ( (first <=. x) /\ (x <=. last) )
 
 clone export "ada__model".Static_Floating_Point with
 type t = long_float, 
 function round_real_tmp = Floating.round_double, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_real
 
 meta "inline : no" function to_real
 
 type long_float__ref #"system.ads" 1 0 0# =
  { mutable long_float__content "model_trace:" : long_float }
 
 function long_float__ref___projection #"system.ads" 1 0 0# 
   (a : long_float__ref) : long_float =
  a.long_float__content
 
 meta "model_projection" function long_float__ref___projection
 
 meta "inline : no" function long_float__ref___projection
 
 val long_float__havoc #"system.ads" 1 0 0# 
   (x : long_float__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "long_long_float", created in Gnat2Why.Types.Translate_Type *)
module Standard__long_long_float
 use import "_gnatprove_standard".Main
 use import "real".RealInfix

 type long_long_float #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : real =
  (-.1189731495357231765021263853030970205169063322294624200440323733891737005522970722616410290336528882853545697807495577314427443153670288434198125573853743678673593200706973263201915918282961524365529510646791086614311790632169778838896134786560600399148753433211454911160088679845154866512852340149773037600009125479393966223151383622417838542743917838138717805889487540575168226347659235576974805113725649020884855222494791399377585026011773549180099796226026859508558883608159846900235645132346594476384939859276456284579661772930407806609229102715046085388087959327781622986827547830768080040150694942303411728957777100335714010559775242124057347007386251660110828379119623008469277200965153500208474470792443848545912886723000619085126472111951361467527633519562927597957250278002980795904193139603021470997035276467445530922022679656280991498232083329641241038509239184734786121921697210543484287048353408113042573002216421348917347174234800714880751002064390517234247656004721768096486107994943415703476320643558624207443504424380566136017608837478165389027809576975977286860071487028287955567141404632615832623602762896316173978484254486860609948270867968048078702511858930838546584223040908805996294594586201903766048446790926002225410530775901065760671347200125846406957030257138960983757998926954553052368560758683179223113639519468850880771872104705203957587480013143131444254943919940175753169339392366881856189129931729104252921236835159922322050998001677102784035360140829296398115122877768135706045789343535451696539561254048846447169786893211671087229088082778350518228857646062218739702851655083720992349483334435228984751232753726636066213902281264706234075352071724058665079518217303463782631353393706774901950197841690441824738063162828586857741432581165364040218402724913393320949219498422442730427019873044536620350262386957804682003601447291997123095530057206141866974852846856186514832715974481203121946751686379343096189615107330065552421485195201762858595091051839472502863871632494167613804996319791441870254302706758495192008837915169401581740046711477877201459644461175204059453504764721807975761111720846273639279600339670470037613374509553184150073796412605047923251661354841291884211340823015473304754067072818763503617332908005951896325207071673904547777129682265206225651439919376804400292380903112437912614776255964694221981375146967079446870358004392507659451618379811859392049544036114915310782251072691486979809240946772142727012404377187409216756613634938900451232351668146089322400697993176017805338191849981933008410985993938760292601390911414526003720284872132411955424282101831204216104467404621635336900583664606591156298764745525068145003932941404131495400677602951005962253022823003631473824681059648442441324864573137437595096416168048024129351876204668135636877532814675538798871771836512893947195335061885003267607354388673368002074387849657014576090349857571243045102038730494854256702479339322809110526041538528994849203991091946129912491633289917998094380337879522093131466946149705939664152375949285890960489916121944989986384837022486672249148924678410206183364627416969576307632480235587975245253737035433882960862753427740016333434055083537048507374544819754722228975281083020898682633020285259923084168054539687911418297629988964576482765287504562854924265165217750799516259669229114977788962356670956627138482018191348321687995863652637620978285070099337294396784639879024914514222742527006363942327998483976739987154418554201562244154926653014515504685489258620276085761837129763358761215382565129633538141663949516556000264159186554850057052611431952919918807954522394649627635630178580896692226406235382898535867595990647008385687123810329591926494846250768992258419305480763620215089022149220528069842018350840586938493815498909445461977893029113576516775406232278298314033473276603952231603422824717528181818844304880921321933550869873395861276073670866652375555675803171490108477320096424318780070008797346032906278943553743564448851907191616455141155761939399690767415156402826543664026760095087523945507341556135867933066031744720924446513532366647649735400851967040771103640538150073486891798364049570606189535005089840913826869535090066783324472578712196604415284924840041850932811908963634175739897166596000759487800619164094854338758520657116541072260996288150123144377944008749301944744330784388995701842710004808305012177123560622895076269042856800047718893158089358515593863176652948089031267747029662545110861548958395087796755464137944895960527975209874813839762578592105756284401759349324162148339565350189196811389091843795734703269406342890087805846940352453479398080674273236297887100867175802531561302356064878709259865288416350972529537091114317204887747405539054009425375424119317944175137064689643861517718849867010341532542385911089624710885385808688837777258648564145934262121086647588489260031762345960769508849149662444156604419552086811989770240.0)
 
 function last #"system.ads" 1 0 0# 
   : real =
  (1189731495357231765021263853030970205169063322294624200440323733891737005522970722616410290336528882853545697807495577314427443153670288434198125573853743678673593200706973263201915918282961524365529510646791086614311790632169778838896134786560600399148753433211454911160088679845154866512852340149773037600009125479393966223151383622417838542743917838138717805889487540575168226347659235576974805113725649020884855222494791399377585026011773549180099796226026859508558883608159846900235645132346594476384939859276456284579661772930407806609229102715046085388087959327781622986827547830768080040150694942303411728957777100335714010559775242124057347007386251660110828379119623008469277200965153500208474470792443848545912886723000619085126472111951361467527633519562927597957250278002980795904193139603021470997035276467445530922022679656280991498232083329641241038509239184734786121921697210543484287048353408113042573002216421348917347174234800714880751002064390517234247656004721768096486107994943415703476320643558624207443504424380566136017608837478165389027809576975977286860071487028287955567141404632615832623602762896316173978484254486860609948270867968048078702511858930838546584223040908805996294594586201903766048446790926002225410530775901065760671347200125846406957030257138960983757998926954553052368560758683179223113639519468850880771872104705203957587480013143131444254943919940175753169339392366881856189129931729104252921236835159922322050998001677102784035360140829296398115122877768135706045789343535451696539561254048846447169786893211671087229088082778350518228857646062218739702851655083720992349483334435228984751232753726636066213902281264706234075352071724058665079518217303463782631353393706774901950197841690441824738063162828586857741432581165364040218402724913393320949219498422442730427019873044536620350262386957804682003601447291997123095530057206141866974852846856186514832715974481203121946751686379343096189615107330065552421485195201762858595091051839472502863871632494167613804996319791441870254302706758495192008837915169401581740046711477877201459644461175204059453504764721807975761111720846273639279600339670470037613374509553184150073796412605047923251661354841291884211340823015473304754067072818763503617332908005951896325207071673904547777129682265206225651439919376804400292380903112437912614776255964694221981375146967079446870358004392507659451618379811859392049544036114915310782251072691486979809240946772142727012404377187409216756613634938900451232351668146089322400697993176017805338191849981933008410985993938760292601390911414526003720284872132411955424282101831204216104467404621635336900583664606591156298764745525068145003932941404131495400677602951005962253022823003631473824681059648442441324864573137437595096416168048024129351876204668135636877532814675538798871771836512893947195335061885003267607354388673368002074387849657014576090349857571243045102038730494854256702479339322809110526041538528994849203991091946129912491633289917998094380337879522093131466946149705939664152375949285890960489916121944989986384837022486672249148924678410206183364627416969576307632480235587975245253737035433882960862753427740016333434055083537048507374544819754722228975281083020898682633020285259923084168054539687911418297629988964576482765287504562854924265165217750799516259669229114977788962356670956627138482018191348321687995863652637620978285070099337294396784639879024914514222742527006363942327998483976739987154418554201562244154926653014515504685489258620276085761837129763358761215382565129633538141663949516556000264159186554850057052611431952919918807954522394649627635630178580896692226406235382898535867595990647008385687123810329591926494846250768992258419305480763620215089022149220528069842018350840586938493815498909445461977893029113576516775406232278298314033473276603952231603422824717528181818844304880921321933550869873395861276073670866652375555675803171490108477320096424318780070008797346032906278943553743564448851907191616455141155761939399690767415156402826543664026760095087523945507341556135867933066031744720924446513532366647649735400851967040771103640538150073486891798364049570606189535005089840913826869535090066783324472578712196604415284924840041850932811908963634175739897166596000759487800619164094854338758520657116541072260996288150123144377944008749301944744330784388995701842710004808305012177123560622895076269042856800047718893158089358515593863176652948089031267747029662545110861548958395087796755464137944895960527975209874813839762578592105756284401759349324162148339565350189196811389091843795734703269406342890087805846940352453479398080674273236297887100867175802531561302356064878709259865288416350972529537091114317204887747405539054009425375424119317944175137064689643861517718849867010341532542385911089624710885385808688837777258648564145934262121086647588489260031762345960769508849149662444156604419552086811989770240.0)
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : real)  =
  ( (first <=. x) /\ (x <=. last) )
 
 clone export "ada__model".Static_Floating_Point with
 type t = long_long_float, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_real
 
 meta "inline : no" function to_real
 
 type long_long_float__ref #"system.ads" 1 0 0# =
  { mutable long_long_float__content "model_trace:" : long_long_float }
 
 function long_long_float__ref___projection #"system.ads" 1 0 0# 
   (a : long_long_float__ref) : long_long_float =
  a.long_long_float__content
 
 meta "model_projection" function long_long_float__ref___projection
 
 meta "inline : no" function long_long_float__ref___projection
 
 val long_long_float__havoc #"system.ads" 1 0 0# 
   (x : long_long_float__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "character", created in Gnat2Why.Types.Translate_Type *)
module Standard__character
 use import "_gnatprove_standard".Main
 use import "int".Int

 type character #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  0
 
 function last #"system.ads" 1 0 0# 
   : int =
  255
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = character, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type character__ref #"system.ads" 1 0 0# =
  { mutable character__content "model_trace:" : character }
 
 function character__ref___projection #"system.ads" 1 0 0# 
   (a : character__ref) : character =
  a.character__content
 
 meta "model_projection" function character__ref___projection
 
 meta "inline : no" function character__ref___projection
 
 val character__havoc #"system.ads" 1 0 0# 
   (x : character__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "wide_character", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_character
 use import "_gnatprove_standard".Main
 use import "int".Int

 type wide_character #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  0
 
 function last #"system.ads" 1 0 0# 
   : int =
  65535
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = wide_character, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type wide_character__ref #"system.ads" 1 0 0# =
  { mutable wide_character__content "model_trace:" : wide_character }
 
 function wide_character__ref___projection #"system.ads" 1 0 0# 
   (a : wide_character__ref) : wide_character =
  a.wide_character__content
 
 meta "model_projection" function wide_character__ref___projection
 
 meta "inline : no" function wide_character__ref___projection
 
 val wide_character__havoc #"system.ads" 1 0 0# 
   (x : wide_character__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "wide_wide_character", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_wide_character
 use import "_gnatprove_standard".Main
 use import "int".Int

 type wide_wide_character #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  0
 
 function last #"system.ads" 1 0 0# 
   : int =
  2147483647
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = wide_wide_character, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type wide_wide_character__ref #"system.ads" 1 0 0# =
  { mutable wide_wide_character__content "model_trace:" : wide_wide_character }
 
 function wide_wide_character__ref___projection #"system.ads" 1 0 0# 
   (a : wide_wide_character__ref) : wide_wide_character =
  a.wide_wide_character__content
 
 meta "model_projection" function wide_wide_character__ref___projection
 
 meta "inline : no" function wide_wide_character__ref___projection
 
 val wide_wide_character__havoc #"system.ads" 1 0 0# 
   (x : wide_wide_character__ref) : unit
  writes {x}

end

(* Module for axiomatizing the array theory associated to type "string", created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__character
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__character

 function index_I1_one #"system.ads" 1 0 0# 
   : int =
  1
 
 type component_type #"system.ads" 1 0 0# =
  Standard__character.character
 
 clone export "_gnatprove_standard".Array__1 with
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function index_Index_one #"system.ads" 1 0 0# 
   : int =
  1
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with
 type component_type = component_type, 
 function to_rep = Standard__character.to_rep, 
 type map = map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = get, 
 function bool_eq = bool_eq

end

(* Module for axiomatizing type "string", created in Gnat2Why.Types.Translate_Type *)
module Standard__string
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main
 use        Standard__integer
 use        Standard__positive
 use        Standard__character
 use        Array__Int__Standard__character

 type component_type #"system.ads" 1 0 0# =
  Standard__character.character
 
 function index_1_id #"system.ads" 1 0 0# 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with
 type map = Array__Int__Standard__character.map, 
 function array_bool_eq = Array__Int__Standard__character.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Standard__positive.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type string #"system.ads" 1 0 0# =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline : no" function to_array
 
 meta "model_projection" function first
 
 meta "inline : no" function first
 
 meta "model_projection" function last
 
 meta "inline : no" function last
 
 function to_string #"system.ads" 1 0 0# 
   (x : Main.__image) : string
 
 function from_string #"system.ads" 1 0 0# 
   (x : string) : Main.__image
 
 type string__ref #"system.ads" 1 0 0# =
  { mutable string__content "model_trace:" : string }
 
 function string__ref___projection #"system.ads" 1 0 0# 
   (a : string__ref) : string =
  a.string__content
 
 meta "model_projection" function string__ref___projection
 
 meta "inline : no" function string__ref___projection
 
 val string__havoc #"system.ads" 1 0 0# 
   (x : string__ref) : unit
  writes {x}

end

(* Module for axiomatizing the array theory associated to type "wide_string", created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__wide_character
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__wide_character

 function index_I1_one #"system.ads" 1 0 0# 
   : int =
  1
 
 type component_type #"system.ads" 1 0 0# =
  Standard__wide_character.wide_character
 
 clone export "_gnatprove_standard".Array__1 with
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function index_Index_one #"system.ads" 1 0 0# 
   : int =
  1
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with
 type component_type = component_type, 
 function to_rep = Standard__wide_character.to_rep, 
 type map = map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = get, 
 function bool_eq = bool_eq

end

(* Module for axiomatizing type "wide_string", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_string
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer
 use        Standard__positive
 use        Standard__wide_character
 use        Array__Int__Standard__wide_character

 type component_type #"system.ads" 1 0 0# =
  Standard__wide_character.wide_character
 
 function index_1_id #"system.ads" 1 0 0# 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with
 type map = Array__Int__Standard__wide_character.map, 
 function array_bool_eq = Array__Int__Standard__wide_character.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Standard__positive.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type wide_string #"system.ads" 1 0 0# =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline : no" function to_array
 
 meta "model_projection" function first
 
 meta "inline : no" function first
 
 meta "model_projection" function last
 
 meta "inline : no" function last
 
 type wide_string__ref #"system.ads" 1 0 0# =
  { mutable wide_string__content "model_trace:" : wide_string }
 
 function wide_string__ref___projection #"system.ads" 1 0 0# 
   (a : wide_string__ref) : wide_string =
  a.wide_string__content
 
 meta "model_projection" function wide_string__ref___projection
 
 meta "inline : no" function wide_string__ref___projection
 
 val wide_string__havoc #"system.ads" 1 0 0# 
   (x : wide_string__ref) : unit
  writes {x}

end

(* Module for axiomatizing the array theory associated to type "wide_wide_string", created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__wide_wide_character
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__wide_wide_character

 function index_I1_one #"system.ads" 1 0 0# 
   : int =
  1
 
 type component_type #"system.ads" 1 0 0# =
  Standard__wide_wide_character.wide_wide_character
 
 clone export "_gnatprove_standard".Array__1 with
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function index_Index_one #"system.ads" 1 0 0# 
   : int =
  1
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with
 type component_type = component_type, 
 function to_rep = Standard__wide_wide_character.to_rep, 
 type map = map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = get, 
 function bool_eq = bool_eq

end

(* Module for axiomatizing type "wide_wide_string", created in Gnat2Why.Types.Translate_Type *)
module Standard__wide_wide_string
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer
 use        Standard__positive
 use        Standard__wide_wide_character
 use        Array__Int__Standard__wide_wide_character

 type component_type #"system.ads" 1 0 0# =
  Standard__wide_wide_character.wide_wide_character
 
 function index_1_id #"system.ads" 1 0 0# 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with
 type map = Array__Int__Standard__wide_wide_character.map, 
 function array_bool_eq = Array__Int__Standard__wide_wide_character.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = Standard__positive.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type wide_wide_string #"system.ads" 1 0 0# =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline : no" function to_array
 
 meta "model_projection" function first
 
 meta "inline : no" function first
 
 meta "model_projection" function last
 
 meta "inline : no" function last
 
 type wide_wide_string__ref #"system.ads" 1 0 0# =
  { mutable wide_wide_string__content "model_trace:" : wide_wide_string }
 
 function wide_wide_string__ref___projection #"system.ads" 1 0 0# 
   (a : wide_wide_string__ref) : wide_wide_string =
  a.wide_wide_string__content
 
 meta "model_projection" function wide_wide_string__ref___projection
 
 meta "inline : no" function wide_wide_string__ref___projection
 
 val wide_wide_string__havoc #"system.ads" 1 0 0# 
   (x : wide_wide_string__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "duration", created in Gnat2Why.Types.Translate_Type *)
module Standard__duration
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main

 type duration #"system.ads" 1 0 0# 
 
 function inv_small #"system.ads" 1 0 0# 
   : Main.__fixed =
  1000000000
 
 function first #"system.ads" 1 0 0# 
   : Main.__fixed =
  ( -9223372036854775808 )
 
 function last #"system.ads" 1 0 0# 
   : Main.__fixed =
  9223372036854775807
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : Main.__fixed)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Fixed_Point with
 type t = duration, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range, 
 function inv_small = inv_small
 
 type duration__ref #"system.ads" 1 0 0# =
  { mutable duration__content "model_trace:" : duration }
 
 function duration__ref___projection #"system.ads" 1 0 0# 
   (a : duration__ref) : duration =
  a.duration__content
 
 meta "model_projection" function duration__ref___projection
 
 meta "inline : no" function duration__ref___projection
 
 val duration__havoc #"system.ads" 1 0 0# 
   (x : duration__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "integer_8", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_8
 use import "_gnatprove_standard".Main
 use import "int".Int

 type integer_8 #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -128 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  127
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = integer_8, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type integer_8__ref #"system.ads" 1 0 0# =
  { mutable integer_8__content "model_trace:" : integer_8 }
 
 function integer_8__ref___projection #"system.ads" 1 0 0# 
   (a : integer_8__ref) : integer_8 =
  a.integer_8__content
 
 meta "model_projection" function integer_8__ref___projection
 
 meta "inline : no" function integer_8__ref___projection
 
 val integer_8__havoc #"system.ads" 1 0 0# 
   (x : integer_8__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "integer_16", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_16
 use import "_gnatprove_standard".Main
 use import "int".Int

 type integer_16 #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -32768 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  32767
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = integer_16, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type integer_16__ref #"system.ads" 1 0 0# =
  { mutable integer_16__content "model_trace:" : integer_16 }
 
 function integer_16__ref___projection #"system.ads" 1 0 0# 
   (a : integer_16__ref) : integer_16 =
  a.integer_16__content
 
 meta "model_projection" function integer_16__ref___projection
 
 meta "inline : no" function integer_16__ref___projection
 
 val integer_16__havoc #"system.ads" 1 0 0# 
   (x : integer_16__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "integer_32", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_32
 use import "_gnatprove_standard".Main
 use import "int".Int

 type integer_32 #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -2147483648 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  2147483647
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = integer_32, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type integer_32__ref #"system.ads" 1 0 0# =
  { mutable integer_32__content "model_trace:" : integer_32 }
 
 function integer_32__ref___projection #"system.ads" 1 0 0# 
   (a : integer_32__ref) : integer_32 =
  a.integer_32__content
 
 meta "model_projection" function integer_32__ref___projection
 
 meta "inline : no" function integer_32__ref___projection
 
 val integer_32__havoc #"system.ads" 1 0 0# 
   (x : integer_32__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "integer_64", created in Gnat2Why.Types.Translate_Type *)
module Standard__integer_64
 use import "_gnatprove_standard".Main
 use import "int".Int

 type integer_64 #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -9223372036854775808 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  9223372036854775807
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = integer_64, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type integer_64__ref #"system.ads" 1 0 0# =
  { mutable integer_64__content "model_trace:" : integer_64 }
 
 function integer_64__ref___projection #"system.ads" 1 0 0# 
   (a : integer_64__ref) : integer_64 =
  a.integer_64__content
 
 meta "model_projection" function integer_64__ref___projection
 
 meta "inline : no" function integer_64__ref___projection
 
 val integer_64__havoc #"system.ads" 1 0 0# 
   (x : integer_64__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "universal_integer", created in Gnat2Why.Types.Translate_Type *)
module Standard__universal_integer
 use import "_gnatprove_standard".Main
 use import "int".Int

 type universal_integer #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : int =
  ( -9223372036854775808 )
 
 function last #"system.ads" 1 0 0# 
   : int =
  9223372036854775807
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = universal_integer, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type universal_integer__ref #"system.ads" 1 0 0# =
  { mutable universal_integer__content "model_trace:" : universal_integer }
 
 function universal_integer__ref___projection #"system.ads" 1 0 0# 
   (a : universal_integer__ref) : universal_integer =
  a.universal_integer__content
 
 meta "model_projection" function universal_integer__ref___projection
 
 meta "inline : no" function universal_integer__ref___projection
 
 val universal_integer__havoc #"system.ads" 1 0 0# 
   (x : universal_integer__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "universal_real", created in Gnat2Why.Types.Translate_Type *)
module Standard__universal_real
 use import "_gnatprove_standard".Main
 use import "real".RealInfix

 type universal_real #"system.ads" 1 0 0# 
 
 function first #"system.ads" 1 0 0# 
   : real =
  (-.1189731495357231765021263853030970205169063322294624200440323733891737005522970722616410290336528882853545697807495577314427443153670288434198125573853743678673593200706973263201915918282961524365529510646791086614311790632169778838896134786560600399148753433211454911160088679845154866512852340149773037600009125479393966223151383622417838542743917838138717805889487540575168226347659235576974805113725649020884855222494791399377585026011773549180099796226026859508558883608159846900235645132346594476384939859276456284579661772930407806609229102715046085388087959327781622986827547830768080040150694942303411728957777100335714010559775242124057347007386251660110828379119623008469277200965153500208474470792443848545912886723000619085126472111951361467527633519562927597957250278002980795904193139603021470997035276467445530922022679656280991498232083329641241038509239184734786121921697210543484287048353408113042573002216421348917347174234800714880751002064390517234247656004721768096486107994943415703476320643558624207443504424380566136017608837478165389027809576975977286860071487028287955567141404632615832623602762896316173978484254486860609948270867968048078702511858930838546584223040908805996294594586201903766048446790926002225410530775901065760671347200125846406957030257138960983757998926954553052368560758683179223113639519468850880771872104705203957587480013143131444254943919940175753169339392366881856189129931729104252921236835159922322050998001677102784035360140829296398115122877768135706045789343535451696539561254048846447169786893211671087229088082778350518228857646062218739702851655083720992349483334435228984751232753726636066213902281264706234075352071724058665079518217303463782631353393706774901950197841690441824738063162828586857741432581165364040218402724913393320949219498422442730427019873044536620350262386957804682003601447291997123095530057206141866974852846856186514832715974481203121946751686379343096189615107330065552421485195201762858595091051839472502863871632494167613804996319791441870254302706758495192008837915169401581740046711477877201459644461175204059453504764721807975761111720846273639279600339670470037613374509553184150073796412605047923251661354841291884211340823015473304754067072818763503617332908005951896325207071673904547777129682265206225651439919376804400292380903112437912614776255964694221981375146967079446870358004392507659451618379811859392049544036114915310782251072691486979809240946772142727012404377187409216756613634938900451232351668146089322400697993176017805338191849981933008410985993938760292601390911414526003720284872132411955424282101831204216104467404621635336900583664606591156298764745525068145003932941404131495400677602951005962253022823003631473824681059648442441324864573137437595096416168048024129351876204668135636877532814675538798871771836512893947195335061885003267607354388673368002074387849657014576090349857571243045102038730494854256702479339322809110526041538528994849203991091946129912491633289917998094380337879522093131466946149705939664152375949285890960489916121944989986384837022486672249148924678410206183364627416969576307632480235587975245253737035433882960862753427740016333434055083537048507374544819754722228975281083020898682633020285259923084168054539687911418297629988964576482765287504562854924265165217750799516259669229114977788962356670956627138482018191348321687995863652637620978285070099337294396784639879024914514222742527006363942327998483976739987154418554201562244154926653014515504685489258620276085761837129763358761215382565129633538141663949516556000264159186554850057052611431952919918807954522394649627635630178580896692226406235382898535867595990647008385687123810329591926494846250768992258419305480763620215089022149220528069842018350840586938493815498909445461977893029113576516775406232278298314033473276603952231603422824717528181818844304880921321933550869873395861276073670866652375555675803171490108477320096424318780070008797346032906278943553743564448851907191616455141155761939399690767415156402826543664026760095087523945507341556135867933066031744720924446513532366647649735400851967040771103640538150073486891798364049570606189535005089840913826869535090066783324472578712196604415284924840041850932811908963634175739897166596000759487800619164094854338758520657116541072260996288150123144377944008749301944744330784388995701842710004808305012177123560622895076269042856800047718893158089358515593863176652948089031267747029662545110861548958395087796755464137944895960527975209874813839762578592105756284401759349324162148339565350189196811389091843795734703269406342890087805846940352453479398080674273236297887100867175802531561302356064878709259865288416350972529537091114317204887747405539054009425375424119317944175137064689643861517718849867010341532542385911089624710885385808688837777258648564145934262121086647588489260031762345960769508849149662444156604419552086811989770240.0)
 
 function last #"system.ads" 1 0 0# 
   : real =
  (1189731495357231765021263853030970205169063322294624200440323733891737005522970722616410290336528882853545697807495577314427443153670288434198125573853743678673593200706973263201915918282961524365529510646791086614311790632169778838896134786560600399148753433211454911160088679845154866512852340149773037600009125479393966223151383622417838542743917838138717805889487540575168226347659235576974805113725649020884855222494791399377585026011773549180099796226026859508558883608159846900235645132346594476384939859276456284579661772930407806609229102715046085388087959327781622986827547830768080040150694942303411728957777100335714010559775242124057347007386251660110828379119623008469277200965153500208474470792443848545912886723000619085126472111951361467527633519562927597957250278002980795904193139603021470997035276467445530922022679656280991498232083329641241038509239184734786121921697210543484287048353408113042573002216421348917347174234800714880751002064390517234247656004721768096486107994943415703476320643558624207443504424380566136017608837478165389027809576975977286860071487028287955567141404632615832623602762896316173978484254486860609948270867968048078702511858930838546584223040908805996294594586201903766048446790926002225410530775901065760671347200125846406957030257138960983757998926954553052368560758683179223113639519468850880771872104705203957587480013143131444254943919940175753169339392366881856189129931729104252921236835159922322050998001677102784035360140829296398115122877768135706045789343535451696539561254048846447169786893211671087229088082778350518228857646062218739702851655083720992349483334435228984751232753726636066213902281264706234075352071724058665079518217303463782631353393706774901950197841690441824738063162828586857741432581165364040218402724913393320949219498422442730427019873044536620350262386957804682003601447291997123095530057206141866974852846856186514832715974481203121946751686379343096189615107330065552421485195201762858595091051839472502863871632494167613804996319791441870254302706758495192008837915169401581740046711477877201459644461175204059453504764721807975761111720846273639279600339670470037613374509553184150073796412605047923251661354841291884211340823015473304754067072818763503617332908005951896325207071673904547777129682265206225651439919376804400292380903112437912614776255964694221981375146967079446870358004392507659451618379811859392049544036114915310782251072691486979809240946772142727012404377187409216756613634938900451232351668146089322400697993176017805338191849981933008410985993938760292601390911414526003720284872132411955424282101831204216104467404621635336900583664606591156298764745525068145003932941404131495400677602951005962253022823003631473824681059648442441324864573137437595096416168048024129351876204668135636877532814675538798871771836512893947195335061885003267607354388673368002074387849657014576090349857571243045102038730494854256702479339322809110526041538528994849203991091946129912491633289917998094380337879522093131466946149705939664152375949285890960489916121944989986384837022486672249148924678410206183364627416969576307632480235587975245253737035433882960862753427740016333434055083537048507374544819754722228975281083020898682633020285259923084168054539687911418297629988964576482765287504562854924265165217750799516259669229114977788962356670956627138482018191348321687995863652637620978285070099337294396784639879024914514222742527006363942327998483976739987154418554201562244154926653014515504685489258620276085761837129763358761215382565129633538141663949516556000264159186554850057052611431952919918807954522394649627635630178580896692226406235382898535867595990647008385687123810329591926494846250768992258419305480763620215089022149220528069842018350840586938493815498909445461977893029113576516775406232278298314033473276603952231603422824717528181818844304880921321933550869873395861276073670866652375555675803171490108477320096424318780070008797346032906278943553743564448851907191616455141155761939399690767415156402826543664026760095087523945507341556135867933066031744720924446513532366647649735400851967040771103640538150073486891798364049570606189535005089840913826869535090066783324472578712196604415284924840041850932811908963634175739897166596000759487800619164094854338758520657116541072260996288150123144377944008749301944744330784388995701842710004808305012177123560622895076269042856800047718893158089358515593863176652948089031267747029662545110861548958395087796755464137944895960527975209874813839762578592105756284401759349324162148339565350189196811389091843795734703269406342890087805846940352453479398080674273236297887100867175802531561302356064878709259865288416350972529537091114317204887747405539054009425375424119317944175137064689643861517718849867010341532542385911089624710885385808688837777258648564145934262121086647588489260031762345960769508849149662444156604419552086811989770240.0)
 
 predicate in_range #"system.ads" 1 0 0# 
   (x : real)  =
  ( (first <=. x) /\ (x <=. last) )
 
 clone export "ada__model".Static_Floating_Point with
 type t = universal_real, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_real
 
 meta "inline : no" function to_real
 
 type universal_real__ref #"system.ads" 1 0 0# =
  { mutable universal_real__content "model_trace:" : universal_real }
 
 function universal_real__ref___projection #"system.ads" 1 0 0# 
   (a : universal_real__ref) : universal_real =
  a.universal_real__content
 
 meta "model_projection" function universal_real__ref___projection
 
 meta "inline : no" function universal_real__ref___projection
 
 val universal_real__havoc #"system.ads" 1 0 0# 
   (x : universal_real__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "name" defined at system.ads:46, created in Gnat2Why.Types.Translate_Type *)
module System__name
 use import "_gnatprove_standard".Main
 use import "int".Int

 type name #"system.ads" 46 0 0# 
 
 function first #"system.ads" 46 0 0# 
   : int =
  0
 
 function last #"system.ads" 46 0 0# 
   : int =
  0
 
 predicate in_range #"system.ads" 46 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = name, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type name__ref #"system.ads" 46 0 0# =
  { mutable name__content "model_trace:" : name }
 
 function name__ref___projection #"system.ads" 46 0 0# 
   (a : name__ref) : name =
  a.name__content
 
 meta "model_projection" function name__ref___projection
 
 meta "inline : no" function name__ref___projection
 
 val name__havoc #"system.ads" 46 0 0# 
   (x : name__ref) : unit
  writes {x}

end

(* Module for defining the constant "system_name" defined at system.ads:47, created in Gnat2Why.Decls.Translate_Constant *)
module System__system_name
 use import "_gnatprove_standard".Main

 function system_name #"system.ads" 47 0 0# "model" "model_trace:7413" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 46 0 0# 
   : int

end

(* Module for axiomatizing type "address" defined at system.ads:108, created in Gnat2Why.Types.Translate_Type *)
module System__address
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV32

 type address #"system.ads" 108 0 0# 
 
 function attr__ATTRIBUTE_MODULUS #"system.ads" 108 0 0# 
   : BV32.t
 
 function first #"system.ads" 108 0 0# 
   : BV32.t =
  ( BV32.of_int 0 )
 
 function last #"system.ads" 108 0 0# 
   : BV32.t =
  ( BV32.of_int 4294967295 )
 
 function first_int #"system.ads" 108 0 0# 
   : int =
  0
 
 function last_int #"system.ads" 108 0 0# 
   : int =
  4294967295
 
 predicate in_range #"system.ads" 108 0 0# 
   (x : BV32.t)  =
  true
 
 predicate in_range_int #"system.ads" 108 0 0# 
   (x : int)  =
  BV32.uint_in_range x
 
 clone export "ada__model".Static_Modular_32 with
 type t = address, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range, 
 predicate in_range_int = in_range_int
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type address__ref #"system.ads" 108 0 0# =
  { mutable address__content "model_trace:" : address }
 
 function address__ref___projection #"system.ads" 108 0 0# 
   (a : address__ref) : address =
  a.address__content
 
 meta "model_projection" function address__ref___projection
 
 meta "inline : no" function address__ref___projection
 
 val address__havoc #"system.ads" 108 0 0# 
   (x : address__ref) : unit
  writes {x}

end

(* Module for defining the constant "null_address" defined at system.ads:69, created in Gnat2Why.Decls.Translate_Constant *)
module System__null_address
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function null_address #"system.ads" 69 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module for defining the constant "left" defined at system.ads:77, created in Gnat2Why.Decls.Translate_Constant *)
module System__Olt__left
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function left #"system.ads" 77 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at system.ads:77, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Olt__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "right" defined at system.ads:77, created in Gnat2Why.Decls.Translate_Constant *)
module System__Olt__right
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function right #"system.ads" 77 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at system.ads:77, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Olt__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "Olt" defined at system.ads:77, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__Olt
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function olt #"system.ads" 77 0 0# 
   (left : BV32.t) (right : BV32.t) : bool

end

(* Module for defining the constant "left" defined at system.ads:78, created in Gnat2Why.Decls.Translate_Constant *)
module System__Ole__left
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function left #"system.ads" 78 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at system.ads:78, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Ole__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "right" defined at system.ads:78, created in Gnat2Why.Decls.Translate_Constant *)
module System__Ole__right
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function right #"system.ads" 78 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at system.ads:78, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Ole__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "Ole" defined at system.ads:78, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__Ole
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function ole #"system.ads" 78 0 0# 
   (left : BV32.t) (right : BV32.t) : bool

end

(* Module for defining the constant "left" defined at system.ads:79, created in Gnat2Why.Decls.Translate_Constant *)
module System__Ogt__left
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function left #"system.ads" 79 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at system.ads:79, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Ogt__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "right" defined at system.ads:79, created in Gnat2Why.Decls.Translate_Constant *)
module System__Ogt__right
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function right #"system.ads" 79 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at system.ads:79, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Ogt__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "Ogt" defined at system.ads:79, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__Ogt
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function ogt #"system.ads" 79 0 0# 
   (left : BV32.t) (right : BV32.t) : bool

end

(* Module for defining the constant "left" defined at system.ads:80, created in Gnat2Why.Decls.Translate_Constant *)
module System__Oge__left
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function left #"system.ads" 80 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at system.ads:80, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Oge__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "right" defined at system.ads:80, created in Gnat2Why.Decls.Translate_Constant *)
module System__Oge__right
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function right #"system.ads" 80 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at system.ads:80, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Oge__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "Oge" defined at system.ads:80, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__Oge
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function oge #"system.ads" 80 0 0# 
   (left : BV32.t) (right : BV32.t) : bool

end

(* Module for defining the constant "left" defined at system.ads:81, created in Gnat2Why.Decls.Translate_Constant *)
module System__Oeq__left
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function left #"system.ads" 81 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at system.ads:81, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Oeq__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "right" defined at system.ads:81, created in Gnat2Why.Decls.Translate_Constant *)
module System__Oeq__right
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function right #"system.ads" 81 0 0# 
   : BV32.t
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 108 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at system.ads:81, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__Oeq__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "Oeq" defined at system.ads:81, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__Oeq
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 function oeq #"system.ads" 81 0 0# 
   (left : BV32.t) (right : BV32.t) : bool

end

(* Module for axiomatizing type "bit_order" defined at system.ads:91, created in Gnat2Why.Types.Translate_Type *)
module System__bit_order
 use import "_gnatprove_standard".Main
 use import "int".Int

 type bit_order #"system.ads" 91 0 0# 
 
 function first #"system.ads" 91 0 0# 
   : int =
  0
 
 function last #"system.ads" 91 0 0# 
   : int =
  1
 
 predicate in_range #"system.ads" 91 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = bit_order, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type bit_order__ref #"system.ads" 91 0 0# =
  { mutable bit_order__content "model_trace:" : bit_order }
 
 function bit_order__ref___projection #"system.ads" 91 0 0# 
   (a : bit_order__ref) : bit_order =
  a.bit_order__content
 
 meta "model_projection" function bit_order__ref___projection
 
 meta "inline : no" function bit_order__ref___projection
 
 val bit_order__havoc #"system.ads" 91 0 0# 
   (x : bit_order__ref) : unit
  writes {x}

end

(* Module for defining the constant "default_bit_order" defined at system.ads:92, created in Gnat2Why.Decls.Translate_Constant *)
module System__default_bit_order
 use import "_gnatprove_standard".Main

 function default_bit_order #"system.ads" 92 0 0# "model" "model_trace:7762" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 91 0 0# 
   : int

end

(* Module for defining the constant "max_priority" defined at system.ads:97, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_priority
 use import "_gnatprove_standard".Main

 function max_priority #"system.ads" 97 0 0# "model" "model_trace:7778" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module for defining the constant "max_interrupt_priority" defined at system.ads:98, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_interrupt_priority
 use import "_gnatprove_standard".Main

 function max_interrupt_priority #"system.ads" 98 0 0# "model" "model_trace:7788" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module for axiomatizing type "any_priority" defined at system.ads:100, created in Gnat2Why.Types.Translate_Type *)
module System__any_priority
 use import "_gnatprove_standard".Main
 use import "int".Int

 type any_priority #"system.ads" 100 0 0# 
 
 function first #"system.ads" 100 0 0# 
   : int =
  0
 
 function last #"system.ads" 100 0 0# 
   : int =
  31
 
 predicate in_range #"system.ads" 100 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = any_priority, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type any_priority__ref #"system.ads" 100 0 0# =
  { mutable any_priority__content "model_trace:" : any_priority }
 
 function any_priority__ref___projection #"system.ads" 100 0 0# 
   (a : any_priority__ref) : any_priority =
  a.any_priority__content
 
 meta "model_projection" function any_priority__ref___projection
 
 meta "inline : no" function any_priority__ref___projection
 
 val any_priority__havoc #"system.ads" 100 0 0# 
   (x : any_priority__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "priority" defined at system.ads:101, created in Gnat2Why.Types.Translate_Type *)
module System__priority
 use import "_gnatprove_standard".Main
 use import "int".Int

 type priority #"system.ads" 101 0 0# 
 
 function first #"system.ads" 101 0 0# 
   : int =
  0
 
 function last #"system.ads" 101 0 0# 
   : int =
  30
 
 predicate in_range #"system.ads" 101 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = priority, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type priority__ref #"system.ads" 101 0 0# =
  { mutable priority__content "model_trace:" : priority }
 
 function priority__ref___projection #"system.ads" 101 0 0# 
   (a : priority__ref) : priority =
  a.priority__content
 
 meta "model_projection" function priority__ref___projection
 
 meta "inline : no" function priority__ref___projection
 
 val priority__havoc #"system.ads" 101 0 0# 
   (x : priority__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "interrupt_priority" defined at system.ads:102, created in Gnat2Why.Types.Translate_Type *)
module System__interrupt_priority
 use import "_gnatprove_standard".Main
 use import "int".Int

 type interrupt_priority #"system.ads" 102 0 0# 
 
 function first #"system.ads" 102 0 0# 
   : int =
  31
 
 function last #"system.ads" 102 0 0# 
   : int =
  31
 
 predicate in_range #"system.ads" 102 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = interrupt_priority, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type interrupt_priority__ref #"system.ads" 102 0 0# =
  { mutable interrupt_priority__content "model_trace:" : interrupt_priority }
 
 function interrupt_priority__ref___projection #"system.ads" 102 0 0# 
   (a : interrupt_priority__ref) : interrupt_priority =
  a.interrupt_priority__content
 
 meta "model_projection" function interrupt_priority__ref___projection
 
 meta "inline : no" function interrupt_priority__ref___projection
 
 val interrupt_priority__havoc #"system.ads" 102 0 0# 
   (x : interrupt_priority__ref) : unit
  writes {x}

end

(* Module for defining the constant "default_priority" defined at system.ads:104, created in Gnat2Why.Decls.Translate_Constant *)
module System__default_priority
 use import "_gnatprove_standard".Main

 function default_priority #"system.ads" 104 0 0# "model" "model_trace:7840" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 101 0 0# 
   : int

end

(* Module for defining the constant "backend_divide_checks" defined at system.ads:121, created in Gnat2Why.Decls.Translate_Constant *)
module System__backend_divide_checks
 use import "_gnatprove_standard".Main

 function backend_divide_checks #"system.ads" 121 0 0# "model" "model_trace:7870" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 121 0 0# 
   : int

end

(* Module for defining the constant "backend_overflow_checks" defined at system.ads:122, created in Gnat2Why.Decls.Translate_Constant *)
module System__backend_overflow_checks
 use import "_gnatprove_standard".Main

 function backend_overflow_checks #"system.ads" 122 0 0# "model" "model_trace:7880" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 122 0 0# 
   : int

end

(* Module for defining the constant "command_line_args" defined at system.ads:123, created in Gnat2Why.Decls.Translate_Constant *)
module System__command_line_args
 use import "_gnatprove_standard".Main

 function command_line_args #"system.ads" 123 0 0# "model" "model_trace:7890" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 123 0 0# 
   : int

end

(* Module for defining the constant "configurable_run_time" defined at system.ads:124, created in Gnat2Why.Decls.Translate_Constant *)
module System__configurable_run_time
 use import "_gnatprove_standard".Main

 function configurable_run_time #"system.ads" 124 0 0# "model" "model_trace:7900" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 124 0 0# 
   : int

end

(* Module for defining the constant "denorm" defined at system.ads:125, created in Gnat2Why.Decls.Translate_Constant *)
module System__denorm
 use import "_gnatprove_standard".Main

 function denorm #"system.ads" 125 0 0# "model" "model_trace:7910" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 125 0 0# 
   : int

end

(* Module for defining the constant "duration_32_bits" defined at system.ads:126, created in Gnat2Why.Decls.Translate_Constant *)
module System__duration_32_bits
 use import "_gnatprove_standard".Main

 function duration_32_bits #"system.ads" 126 0 0# "model" "model_trace:7920" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 126 0 0# 
   : int

end

(* Module for defining the constant "exit_status_supported" defined at system.ads:127, created in Gnat2Why.Decls.Translate_Constant *)
module System__exit_status_supported
 use import "_gnatprove_standard".Main

 function exit_status_supported #"system.ads" 127 0 0# "model" "model_trace:7930" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 127 0 0# 
   : int

end

(* Module for defining the constant "fractional_fixed_ops" defined at system.ads:128, created in Gnat2Why.Decls.Translate_Constant *)
module System__fractional_fixed_ops
 use import "_gnatprove_standard".Main

 function fractional_fixed_ops #"system.ads" 128 0 0# "model" "model_trace:7940" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 128 0 0# 
   : int

end

(* Module for defining the constant "frontend_layout" defined at system.ads:129, created in Gnat2Why.Decls.Translate_Constant *)
module System__frontend_layout
 use import "_gnatprove_standard".Main

 function frontend_layout #"system.ads" 129 0 0# "model" "model_trace:7950" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 129 0 0# 
   : int

end

(* Module for defining the constant "machine_overflows" defined at system.ads:130, created in Gnat2Why.Decls.Translate_Constant *)
module System__machine_overflows
 use import "_gnatprove_standard".Main

 function machine_overflows #"system.ads" 130 0 0# "model" "model_trace:7960" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 130 0 0# 
   : int

end

(* Module for defining the constant "machine_rounds" defined at system.ads:131, created in Gnat2Why.Decls.Translate_Constant *)
module System__machine_rounds
 use import "_gnatprove_standard".Main

 function machine_rounds #"system.ads" 131 0 0# "model" "model_trace:7970" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 131 0 0# 
   : int

end

(* Module for defining the constant "preallocated_stacks" defined at system.ads:132, created in Gnat2Why.Decls.Translate_Constant *)
module System__preallocated_stacks
 use import "_gnatprove_standard".Main

 function preallocated_stacks #"system.ads" 132 0 0# "model" "model_trace:7980" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 132 0 0# 
   : int

end

(* Module for defining the constant "signed_zeros" defined at system.ads:133, created in Gnat2Why.Decls.Translate_Constant *)
module System__signed_zeros
 use import "_gnatprove_standard".Main

 function signed_zeros #"system.ads" 133 0 0# "model" "model_trace:7990" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 133 0 0# 
   : int

end

(* Module for defining the constant "stack_check_default" defined at system.ads:134, created in Gnat2Why.Decls.Translate_Constant *)
module System__stack_check_default
 use import "_gnatprove_standard".Main

 function stack_check_default #"system.ads" 134 0 0# "model" "model_trace:8000" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 134 0 0# 
   : int

end

(* Module for defining the constant "stack_check_probes" defined at system.ads:135, created in Gnat2Why.Decls.Translate_Constant *)
module System__stack_check_probes
 use import "_gnatprove_standard".Main

 function stack_check_probes #"system.ads" 135 0 0# "model" "model_trace:8010" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 135 0 0# 
   : int

end

(* Module for defining the constant "stack_check_limits" defined at system.ads:136, created in Gnat2Why.Decls.Translate_Constant *)
module System__stack_check_limits
 use import "_gnatprove_standard".Main

 function stack_check_limits #"system.ads" 136 0 0# "model" "model_trace:8020" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 136 0 0# 
   : int

end

(* Module for defining the constant "support_aggregates" defined at system.ads:137, created in Gnat2Why.Decls.Translate_Constant *)
module System__support_aggregates
 use import "_gnatprove_standard".Main

 function support_aggregates #"system.ads" 137 0 0# "model" "model_trace:8030" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 137 0 0# 
   : int

end

(* Module for defining the constant "support_atomic_primitives" defined at system.ads:138, created in Gnat2Why.Decls.Translate_Constant *)
module System__support_atomic_primitives
 use import "_gnatprove_standard".Main

 function support_atomic_primitives #"system.ads" 138 0 0# "model" "model_trace:8040" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 138 0 0# 
   : int

end

(* Module for defining the constant "support_composite_assign" defined at system.ads:139, created in Gnat2Why.Decls.Translate_Constant *)
module System__support_composite_assign
 use import "_gnatprove_standard".Main

 function support_composite_assign #"system.ads" 139 0 0# "model" "model_trace:8050" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 139 0 0# 
   : int

end

(* Module for defining the constant "support_composite_compare" defined at system.ads:140, created in Gnat2Why.Decls.Translate_Constant *)
module System__support_composite_compare
 use import "_gnatprove_standard".Main

 function support_composite_compare #"system.ads" 140 0 0# "model" "model_trace:8060" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 140 0 0# 
   : int

end

(* Module for defining the constant "support_long_shifts" defined at system.ads:141, created in Gnat2Why.Decls.Translate_Constant *)
module System__support_long_shifts
 use import "_gnatprove_standard".Main

 function support_long_shifts #"system.ads" 141 0 0# "model" "model_trace:8070" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 141 0 0# 
   : int

end

(* Module for defining the constant "always_compatible_rep" defined at system.ads:142, created in Gnat2Why.Decls.Translate_Constant *)
module System__always_compatible_rep
 use import "_gnatprove_standard".Main

 function always_compatible_rep #"system.ads" 142 0 0# "model" "model_trace:8080" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 142 0 0# 
   : int

end

(* Module for defining the constant "suppress_standard_library" defined at system.ads:143, created in Gnat2Why.Decls.Translate_Constant *)
module System__suppress_standard_library
 use import "_gnatprove_standard".Main

 function suppress_standard_library #"system.ads" 143 0 0# "model" "model_trace:8090" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 143 0 0# 
   : int

end

(* Module for defining the constant "use_ada_main_program_name" defined at system.ads:144, created in Gnat2Why.Decls.Translate_Constant *)
module System__use_ada_main_program_name
 use import "_gnatprove_standard".Main

 function use_ada_main_program_name #"system.ads" 144 0 0# "model" "model_trace:8100" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 144 0 0# 
   : int

end

(* Module for defining the constant "frontend_exceptions" defined at system.ads:145, created in Gnat2Why.Decls.Translate_Constant *)
module System__frontend_exceptions
 use import "_gnatprove_standard".Main

 function frontend_exceptions #"system.ads" 145 0 0# "model" "model_trace:8110" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 145 0 0# 
   : int

end

(* Module for defining the constant "zcx_by_default" defined at system.ads:146, created in Gnat2Why.Decls.Translate_Constant *)
module System__zcx_by_default
 use import "_gnatprove_standard".Main

 function zcx_by_default #"system.ads" 146 0 0# "model" "model_trace:8120" 
   : bool
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 146 0 0# 
   : int

end

(* Module for axiomatizing the array theory associated to type "Tpriorities_mappingB" defined at system.ads:161, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Standard__integer
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer

 function index_I1_one #"system.ads" 146 0 0# 
   : int =
  1
 
 type component_type #"system.ads" 146 0 0# =
  Standard__integer.integer
 
 clone export "_gnatprove_standard".Array__1 with
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function index_Index_one #"system.ads" 1 0 0# 
   : int =
  1
 
 clone export "ada__model".Array_Int_Rep_Comparison_Axiom with
 type component_type = component_type, 
 function to_rep = Standard__integer.to_rep, 
 type map = map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = get, 
 function bool_eq = bool_eq

end

(* Module for axiomatizing type "Tpriorities_mappingB" defined at system.ads:161, created in Gnat2Why.Types.Translate_Type *)
module System__Tpriorities_mappingB
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer
 use        Standard__integer
 use        System__any_priority
 use        Array__Int__Standard__integer

 type component_type #"system.ads" 1 0 0# =
  Standard__integer.integer
 
 function index_1_id #"system.ads" 1 0 0# 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with
 type map = Array__Int__Standard__integer.map, 
 function array_bool_eq = Array__Int__Standard__integer.bool_eq, 
 type index_base_type = Standard__integer.integer, 
 type index_rep_type = int, 
 function to_rep = Standard__integer.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Standard__integer.in_range, 
 predicate index_dynamic_property = System__any_priority.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type tpriorities_mappingB #"system.ads" 161 0 0# =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline : no" function to_array
 
 meta "model_projection" function first
 
 meta "inline : no" function first
 
 meta "model_projection" function last
 
 meta "inline : no" function last
 
 type tpriorities_mappingB__ref #"system.ads" 161 0 0# =
  { mutable tpriorities_mappingB__content "model_trace:" : tpriorities_mappingB }
 
 function tpriorities_mappingB__ref___projection #"system.ads" 161 0 0# 
   (a : tpriorities_mappingB__ref) : tpriorities_mappingB =
  a.tpriorities_mappingB__content
 
 meta "model_projection" function tpriorities_mappingB__ref___projection
 
 meta "inline : no" function tpriorities_mappingB__ref___projection
 
 val tpriorities_mappingB__havoc #"system.ads" 161 0 0# 
   (x : tpriorities_mappingB__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "priorities_mapping" defined at system.ads:161, created in Gnat2Why.Types.Translate_Type *)
module System__priorities_mapping
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer
 use        Array__Int__Standard__integer

 type component_type #"system.ads" 161 0 0# =
  Standard__integer.integer
 
 function first #"system.ads" 1 0 0# 
   : int =
  0
 
 function last #"system.ads" 1 0 0# 
   : int =
  31
 
 clone export "ada__model".Constr_Array with
 type map = Array__Int__Standard__integer.map, 
 function array_bool_eq = Array__Int__Standard__integer.bool_eq, 
 function first = first, 
 function last = last, 
 type index_rep_type = int

end

(* Module for axiomatizing type "T3s" defined at system.ads:166, created in Gnat2Why.Types.Translate_Type *)
module System__T3s
 use import "_gnatprove_standard".Main
 use import "int".Int

 type t3s #"system.ads" 166 0 0# 
 
 function first #"system.ads" 166 0 0# 
   : int =
  0
 
 function last #"system.ads" 166 0 0# 
   : int =
  31
 
 predicate in_range #"system.ads" 166 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = t3s, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type t3s__ref #"system.ads" 166 0 0# =
  { mutable t3s__content "model_trace:" : t3s }
 
 function t3s__ref___projection #"system.ads" 166 0 0# 
   (a : t3s__ref) : t3s =
  a.t3s__content
 
 meta "model_projection" function t3s__ref___projection
 
 meta "inline : no" function t3s__ref___projection
 
 val t3s__havoc #"system.ads" 166 0 0# 
   (x : t3s__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T4s" defined at system.ads:166, created in Gnat2Why.Types.Translate_Type *)
module System__T4s
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer
 use        Array__Int__Standard__integer

 type component_type #"system.ads" 166 0 0# =
  Standard__integer.integer
 
 function first #"system.ads" 1 0 0# 
   : int =
  0
 
 function last #"system.ads" 1 0 0# 
   : int =
  31
 
 clone export "ada__model".Constr_Array with
 type map = Array__Int__Standard__integer.map, 
 function array_bool_eq = Array__Int__Standard__integer.bool_eq, 
 function first = first, 
 function last = last, 
 type index_rep_type = int

end

(* Module for defining the constant "underlying_priorities" defined at system.ads:165, created in Gnat2Why.Decls.Translate_Constant *)
module System__underlying_priorities
 use import "_gnatprove_standard".Main
 use        Array__Int__Standard__integer

 function underlying_priorities #"system.ads" 165 0 0# "model_projected" "model_trace:8146" 
   : Array__Int__Standard__integer.map
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 161 0 0# 
   : int

end

(* Module for axiomatizing type "root_controlled" defined at s-finroo.ads:40, created in Gnat2Why.Types.Translate_Type *)
module System__finalization_root__root_controlled
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main

 type __split_fields #"system.ads" 161 0 0# =
  { rec__ext__ "model_trace:" : Main.__private }
 
 function __split_fields___projection #"system.ads" 161 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__ext__
 
 meta "model_projection" function __split_fields___projection
 
 meta "inline : no" function __split_fields___projection
 
 type __split_fields__ref #"system.ads" 161 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref___projection #"system.ads" 161 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref___projection
 
 meta "inline : no" function __split_fields__ref___projection
 
 val __split_fields__havoc #"system.ads" 161 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type root_controlled #"s-finroo.ads" 40 0 0# =
  { __split_fields "model_trace:" : __split_fields; attr__tag "model_trace:" : int }
 
 function root_controlled___projection #"s-finroo.ads" 40 0 0# 
   (a : root_controlled) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function root_controlled___projection
 
 meta "inline : no" function root_controlled___projection
 
 function root_controlled_2__projection #"s-finroo.ads" 40 0 0# 
   (a : root_controlled) : int =
  a.attr__tag
 
 meta "model_projection" function root_controlled_2__projection
 
 meta "inline : no" function root_controlled_2__projection
 
 function bool_eq #"s-finroo.ads" 40 0 0# 
   (a : root_controlled) (b : root_controlled) : bool =
  (if (true) then (
   True) else (
   False))
 
 function user_eq #"s-finroo.ads" 40 0 0# 
   (a : root_controlled) (b : root_controlled) : bool
 
 function __dispatch_eq #"s-finroo.ads" 40 0 0# 
   (a : root_controlled) (b : root_controlled) : bool
 
 function __tag #"s-finroo.ads" 40 0 0# 
   : int
 
 function value__size #"s-finroo.ads" 40 0 0# 
   : int
 
 function object__size #"s-finroo.ads" 40 0 0# 
   (a : root_controlled) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : root_controlled.
   ((object__size a) >= 0))
 
 function dummy #"s-finroo.ads" 40 0 0# 
   : root_controlled
 
 type root_controlled__ref #"s-finroo.ads" 40 0 0# =
  { mutable root_controlled__content "model_trace:" : root_controlled }
 
 function root_controlled__ref___projection #"s-finroo.ads" 40 0 0# 
   (a : root_controlled__ref) : root_controlled =
  a.root_controlled__content
 
 meta "model_projection" function root_controlled__ref___projection
 
 meta "inline : no" function root_controlled__ref___projection
 
 val root_controlled__havoc #"s-finroo.ads" 40 0 0# 
   (x : root_controlled__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "Troot_controlledC" defined at s-finroo.ads:40, created in Gnat2Why.Types.Translate_Type *)
module System__finalization_root__Troot_controlledC
 use export System__finalization_root__root_controlled
 use import "_gnatprove_standard".Main


end

(* Module for axiomatizing type "controlled" defined at a-finali.ads:59, created in Gnat2Why.Types.Translate_Type *)
module Ada__finalization__controlled
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled

 type __split_fields #"s-finroo.ads" 40 0 0# =
  { rec__ext__ "model_trace:" : Main.__private }
 
 function __split_fields_2__projection #"s-finroo.ads" 40 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__ext__
 
 meta "model_projection" function __split_fields_2__projection
 
 meta "inline : no" function __split_fields_2__projection
 
 type __split_fields__ref #"s-finroo.ads" 40 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_2__projection #"s-finroo.ads" 40 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_2__projection
 
 meta "inline : no" function __split_fields__ref_2__projection
 
 val __split_fields__havoc #"s-finroo.ads" 40 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type controlled #"a-finali.ads" 59 0 0# =
  { __split_fields "model_trace:" : __split_fields; attr__tag "model_trace:" : int }
 
 function controlled___projection #"a-finali.ads" 59 0 0# 
   (a : controlled) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function controlled___projection
 
 meta "inline : no" function controlled___projection
 
 function controlled_2__projection #"a-finali.ads" 59 0 0# 
   (a : controlled) : int =
  a.attr__tag
 
 meta "model_projection" function controlled_2__projection
 
 meta "inline : no" function controlled_2__projection
 
 function hide_ext__ #"a-finali.ads" 59 0 0# 
   (rec__ext__ : Main.__private) : Main.__private
 
 function extract__ext__ #"a-finali.ads" 59 0 0# 
   (x : Main.__private) : Main.__private
 
 function to_base #"a-finali.ads" 59 0 0# 
   (a : controlled) : System__finalization_root__root_controlled.root_controlled =
  { System__finalization_root__root_controlled.__split_fields = { System__finalization_root__root_controlled.rec__ext__ = (hide_ext__ a.__split_fields.rec__ext__) }; System__finalization_root__root_controlled.attr__tag = a.attr__tag }
 
 function of_base #"s-finroo.ads" 40 0 0# 
   (r : System__finalization_root__root_controlled.root_controlled) : controlled =
  { __split_fields = { rec__ext__ = (extract__ext__ r.System__finalization_root__root_controlled.__split_fields.System__finalization_root__root_controlled.rec__ext__) }; attr__tag = r.System__finalization_root__root_controlled.attr__tag }
 
 function bool_eq #"a-finali.ads" 59 0 0# 
   (a : controlled) (b : controlled) : bool =
  (if (true) then (
   True) else (
   False))
 
 function user_eq #"a-finali.ads" 59 0 0# 
   (a : controlled) (b : controlled) : bool
 
 function __tag #"a-finali.ads" 59 0 0# 
   : int
 
 function value__size #"a-finali.ads" 59 0 0# 
   : int
 
 function object__size #"a-finali.ads" 59 0 0# 
   (a : controlled) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : controlled.
   ((object__size a) >= 0))
 
 function dummy #"a-finali.ads" 59 0 0# 
   : controlled
 
 type controlled__ref #"a-finali.ads" 59 0 0# =
  { mutable controlled__content "model_trace:" : controlled }
 
 function controlled__ref___projection #"a-finali.ads" 59 0 0# 
   (a : controlled__ref) : controlled =
  a.controlled__content
 
 meta "model_projection" function controlled__ref___projection
 
 meta "inline : no" function controlled__ref___projection
 
 val controlled__havoc #"a-finali.ads" 59 0 0# 
   (x : controlled__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "limited_controlled" defined at a-finali.ads:65, created in Gnat2Why.Types.Translate_Type *)
module Ada__finalization__limited_controlled
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled

 type __split_fields #"a-finali.ads" 59 0 0# =
  { rec__ext__ "model_trace:" : Main.__private }
 
 function __split_fields_3__projection #"a-finali.ads" 59 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__ext__
 
 meta "model_projection" function __split_fields_3__projection
 
 meta "inline : no" function __split_fields_3__projection
 
 type __split_fields__ref #"a-finali.ads" 59 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_3__projection #"a-finali.ads" 59 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_3__projection
 
 meta "inline : no" function __split_fields__ref_3__projection
 
 val __split_fields__havoc #"a-finali.ads" 59 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type limited_controlled #"a-finali.ads" 65 0 0# =
  { __split_fields "model_trace:" : __split_fields; attr__tag "model_trace:" : int }
 
 function limited_controlled___projection #"a-finali.ads" 65 0 0# 
   (a : limited_controlled) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function limited_controlled___projection
 
 meta "inline : no" function limited_controlled___projection
 
 function limited_controlled_2__projection #"a-finali.ads" 65 0 0# 
   (a : limited_controlled) : int =
  a.attr__tag
 
 meta "model_projection" function limited_controlled_2__projection
 
 meta "inline : no" function limited_controlled_2__projection
 
 function hide_ext__ #"a-finali.ads" 65 0 0# 
   (rec__ext__ : Main.__private) : Main.__private
 
 function extract__ext__ #"a-finali.ads" 65 0 0# 
   (x : Main.__private) : Main.__private
 
 function to_base #"a-finali.ads" 65 0 0# 
   (a : limited_controlled) : System__finalization_root__root_controlled.root_controlled =
  { System__finalization_root__root_controlled.__split_fields = { System__finalization_root__root_controlled.rec__ext__ = (hide_ext__ a.__split_fields.rec__ext__) }; System__finalization_root__root_controlled.attr__tag = a.attr__tag }
 
 function of_base #"s-finroo.ads" 40 0 0# 
   (r : System__finalization_root__root_controlled.root_controlled) : limited_controlled =
  { __split_fields = { rec__ext__ = (extract__ext__ r.System__finalization_root__root_controlled.__split_fields.System__finalization_root__root_controlled.rec__ext__) }; attr__tag = r.System__finalization_root__root_controlled.attr__tag }
 
 function bool_eq #"a-finali.ads" 65 0 0# 
   (a : limited_controlled) (b : limited_controlled) : bool =
  (if (true) then (
   True) else (
   False))
 
 function user_eq #"a-finali.ads" 65 0 0# 
   (a : limited_controlled) (b : limited_controlled) : bool
 
 function __tag #"a-finali.ads" 65 0 0# 
   : int
 
 function value__size #"a-finali.ads" 65 0 0# 
   : int
 
 function object__size #"a-finali.ads" 65 0 0# 
   (a : limited_controlled) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : limited_controlled.
   ((object__size a) >= 0))
 
 function dummy #"a-finali.ads" 65 0 0# 
   : limited_controlled
 
 type limited_controlled__ref #"a-finali.ads" 65 0 0# =
  { mutable limited_controlled__content "model_trace:" : limited_controlled }
 
 function limited_controlled__ref___projection #"a-finali.ads" 65 0 0# 
   (a : limited_controlled__ref) : limited_controlled =
  a.limited_controlled__content
 
 meta "model_projection" function limited_controlled__ref___projection
 
 meta "inline : no" function limited_controlled__ref___projection
 
 val limited_controlled__havoc #"a-finali.ads" 65 0 0# 
   (x : limited_controlled__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "TcontrolledC" defined at a-finali.ads:43, created in Gnat2Why.Types.Translate_Type *)
module Ada__finalization__TcontrolledC
 use export Ada__finalization__controlled
 use import "_gnatprove_standard".Main


end

(* Module for axiomatizing type "Tlimited_controlledC" defined at a-finali.ads:50, created in Gnat2Why.Types.Translate_Type *)
module Ada__finalization__Tlimited_controlledC
 use export Ada__finalization__limited_controlled
 use import "_gnatprove_standard".Main


end

(* Module for axiomatizing type "atomic_unsigned" defined at s-atocou.ads:75, created in Gnat2Why.Types.Translate_Type *)
module System__atomic_counters__atomic_unsigned
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV32

 type atomic_unsigned #"s-atocou.ads" 75 0 0# 
 
 function attr__ATTRIBUTE_MODULUS #"s-atocou.ads" 75 0 0# 
   : BV32.t
 
 function first #"s-atocou.ads" 75 0 0# 
   : BV32.t =
  ( BV32.of_int 0 )
 
 function last #"s-atocou.ads" 75 0 0# 
   : BV32.t =
  ( BV32.of_int 4294967295 )
 
 function first_int #"s-atocou.ads" 75 0 0# 
   : int =
  0
 
 function last_int #"s-atocou.ads" 75 0 0# 
   : int =
  4294967295
 
 predicate in_range #"s-atocou.ads" 75 0 0# 
   (x : BV32.t)  =
  true
 
 predicate in_range_int #"s-atocou.ads" 75 0 0# 
   (x : int)  =
  BV32.uint_in_range x
 
 clone export "ada__model".Static_Modular_32 with
 type t = atomic_unsigned, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range, 
 predicate in_range_int = in_range_int
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type atomic_unsigned__ref #"s-atocou.ads" 75 0 0# =
  { mutable atomic_unsigned__content "model_trace:" : atomic_unsigned }
 
 function atomic_unsigned__ref___projection #"s-atocou.ads" 75 0 0# 
   (a : atomic_unsigned__ref) : atomic_unsigned =
  a.atomic_unsigned__content
 
 meta "model_projection" function atomic_unsigned__ref___projection
 
 meta "inline : no" function atomic_unsigned__ref___projection
 
 val atomic_unsigned__havoc #"s-atocou.ads" 75 0 0# 
   (x : atomic_unsigned__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "atomic_counter" defined at s-atocou.ads:102, created in Gnat2Why.Types.Translate_Type *)
module System__atomic_counters__atomic_counter
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV32
 use        System__atomic_counters__atomic_unsigned

 type __split_fields #"s-atocou.ads" 75 0 0# =
  { rec__value "model_trace:.8633" : System__atomic_counters__atomic_unsigned.atomic_unsigned }
 
 function __split_fields_Value__projection #"s-atocou.ads" 75 0 0# "model_trace:.8633" 
   (a : __split_fields) : System__atomic_counters__atomic_unsigned.atomic_unsigned =
  a.rec__value
 
 meta "model_projection" function __split_fields_Value__projection
 
 meta "inline : no" function __split_fields_Value__projection
 
 type __split_fields__ref #"s-atocou.ads" 102 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_4__projection #"s-atocou.ads" 102 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_4__projection
 
 meta "inline : no" function __split_fields__ref_4__projection
 
 val __split_fields__havoc #"s-atocou.ads" 102 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type atomic_counter #"s-atocou.ads" 102 0 0# =
  { __split_fields "model_trace:" : __split_fields }
 
 function atomic_counter___projection #"s-atocou.ads" 102 0 0# 
   (a : atomic_counter) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function atomic_counter___projection
 
 meta "inline : no" function atomic_counter___projection
 
 predicate value__pred #"s-atocou.ads" 102 0 0# 
   (a : atomic_counter)  =
  true
 
 val rec__value_ #"s-atocou.ads" 102 0 0# 
   (a : atomic_counter) : System__atomic_counters__atomic_unsigned.atomic_unsigned
  requires { (value__pred a) }
  ensures { (result = a.__split_fields.rec__value) }
 
 function bool_eq #"s-atocou.ads" 102 0 0# 
   (a : atomic_counter) (b : atomic_counter) : bool =
  (if (((System__atomic_counters__atomic_unsigned.to_rep a.__split_fields.rec__value) = (System__atomic_counters__atomic_unsigned.to_rep b.__split_fields.rec__value))) then (
   True) else (
   False))
 
 function user_eq #"s-atocou.ads" 102 0 0# 
   (a : atomic_counter) (b : atomic_counter) : bool
 
 function value__size #"s-atocou.ads" 102 0 0# 
   : int
 
 function object__size #"s-atocou.ads" 102 0 0# 
   (a : atomic_counter) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : atomic_counter.
   ((object__size a) >= 0))
 
 function dummy #"s-atocou.ads" 102 0 0# 
   : atomic_counter
 
 type atomic_counter__ref #"s-atocou.ads" 102 0 0# =
  { mutable atomic_counter__content "model_trace:" : atomic_counter }
 
 function atomic_counter__ref___projection #"s-atocou.ads" 102 0 0# 
   (a : atomic_counter__ref) : atomic_counter =
  a.atomic_counter__content
 
 meta "model_projection" function atomic_counter__ref___projection
 
 meta "inline : no" function atomic_counter__ref___projection
 
 val atomic_counter__havoc #"s-atocou.ads" 102 0 0# 
   (x : atomic_counter__ref) : unit
  writes {x}

end

(* Module for defining the constant "item" defined at s-atocou.ads:65, created in Gnat2Why.Decls.Translate_Constant *)
module System__atomic_counters__is_one__item
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter

 function item #"s-atocou.ads" 65 0 0# 
   : System__atomic_counters__atomic_counter.atomic_counter
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 102 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at s-atocou.ads:65, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__is_one__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "is_one" defined at s-atocou.ads:65, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__atomic_counters__is_one
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter

 function is_one #"s-atocou.ads" 65 0 0# 
   (item : System__atomic_counters__atomic_counter.atomic_counter) : bool

end

(* Module for axiomatizing type "hash_type" defined at a-contai.ads:19, created in Gnat2Why.Types.Translate_Type *)
module Ada__containers__hash_type
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV32

 type hash_type #"a-contai.ads" 19 0 0# 
 
 function attr__ATTRIBUTE_MODULUS #"a-contai.ads" 19 0 0# 
   : BV32.t
 
 function first #"a-contai.ads" 19 0 0# 
   : BV32.t =
  ( BV32.of_int 0 )
 
 function last #"a-contai.ads" 19 0 0# 
   : BV32.t =
  ( BV32.of_int 4294967295 )
 
 function first_int #"a-contai.ads" 19 0 0# 
   : int =
  0
 
 function last_int #"a-contai.ads" 19 0 0# 
   : int =
  4294967295
 
 predicate in_range #"a-contai.ads" 19 0 0# 
   (x : BV32.t)  =
  true
 
 predicate in_range_int #"a-contai.ads" 19 0 0# 
   (x : int)  =
  BV32.uint_in_range x
 
 clone export "ada__model".Static_Modular_32 with
 type t = hash_type, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range, 
 predicate in_range_int = in_range_int
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type hash_type__ref #"a-contai.ads" 19 0 0# =
  { mutable hash_type__content "model_trace:" : hash_type }
 
 function hash_type__ref___projection #"a-contai.ads" 19 0 0# 
   (a : hash_type__ref) : hash_type =
  a.hash_type__content
 
 meta "model_projection" function hash_type__ref___projection
 
 meta "inline : no" function hash_type__ref___projection
 
 val hash_type__havoc #"a-contai.ads" 19 0 0# 
   (x : hash_type__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "Tcount_typeB" defined at a-contai.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Ada__containers__Tcount_typeB
 use import "_gnatprove_standard".Main
 use import "int".Int

 type tcount_typeB #"a-contai.ads" 20 0 0# 
 
 function first #"a-contai.ads" 20 0 0# 
   : int =
  ( -2147483648 )
 
 function last #"a-contai.ads" 20 0 0# 
   : int =
  2147483647
 
 predicate in_range #"a-contai.ads" 20 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = tcount_typeB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type tcount_typeB__ref #"a-contai.ads" 20 0 0# =
  { mutable tcount_typeB__content "model_trace:" : tcount_typeB }
 
 function tcount_typeB__ref___projection #"a-contai.ads" 20 0 0# 
   (a : tcount_typeB__ref) : tcount_typeB =
  a.tcount_typeB__content
 
 meta "model_projection" function tcount_typeB__ref___projection
 
 meta "inline : no" function tcount_typeB__ref___projection
 
 val tcount_typeB__havoc #"a-contai.ads" 20 0 0# 
   (x : tcount_typeB__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "count_type" defined at a-contai.ads:20, created in Gnat2Why.Types.Translate_Type *)
module Ada__containers__count_type
 use import "_gnatprove_standard".Main
 use import "int".Int

 type count_type #"a-contai.ads" 20 0 0# 
 
 function first #"a-contai.ads" 20 0 0# 
   : int =
  0
 
 function last #"a-contai.ads" 20 0 0# 
   : int =
  2147483647
 
 predicate in_range #"a-contai.ads" 20 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = count_type, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type count_type__ref #"a-contai.ads" 20 0 0# =
  { mutable count_type__content "model_trace:" : count_type }
 
 function count_type__ref___projection #"a-contai.ads" 20 0 0# 
   (a : count_type__ref) : count_type =
  a.count_type__content
 
 meta "model_projection" function count_type__ref___projection
 
 meta "inline : no" function count_type__ref___projection
 
 val count_type__havoc #"a-contai.ads" 20 0 0# 
   (x : count_type__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "tamper_counts" defined at a-conhel.ads:43, created in Gnat2Why.Types.Translate_Type *)
module Ada__containers__helpers__tamper_counts
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV32
 use        System__atomic_counters__atomic_unsigned

 type __split_fields #"a-contai.ads" 20 0 0# =
  { rec__busy "model_trace:.6712" : System__atomic_counters__atomic_unsigned.atomic_unsigned; rec__lock "model_trace:.6725" : System__atomic_counters__atomic_unsigned.atomic_unsigned }
 
 function __split_fields_Busy__projection #"s-atocou.ads" 75 0 0# "model_trace:.6712" 
   (a : __split_fields) : System__atomic_counters__atomic_unsigned.atomic_unsigned =
  a.rec__busy
 
 meta "model_projection" function __split_fields_Busy__projection
 
 meta "inline : no" function __split_fields_Busy__projection
 
 function __split_fields_Lock__projection #"a-conhel.ads" 43 0 0# "model_trace:.6725" 
   (a : __split_fields) : System__atomic_counters__atomic_unsigned.atomic_unsigned =
  a.rec__lock
 
 meta "model_projection" function __split_fields_Lock__projection
 
 meta "inline : no" function __split_fields_Lock__projection
 
 type __split_fields__ref #"a-conhel.ads" 43 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_5__projection #"a-conhel.ads" 43 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_5__projection
 
 meta "inline : no" function __split_fields__ref_5__projection
 
 val __split_fields__havoc #"a-conhel.ads" 43 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type tamper_counts #"a-conhel.ads" 43 0 0# =
  { __split_fields "model_trace:" : __split_fields }
 
 function tamper_counts___projection #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function tamper_counts___projection
 
 meta "inline : no" function tamper_counts___projection
 
 predicate busy__pred #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts)  =
  true
 
 val rec__busy_ #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts) : System__atomic_counters__atomic_unsigned.atomic_unsigned
  requires { (busy__pred a) }
  ensures { (result = a.__split_fields.rec__busy) }
 
 predicate lock__pred #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts)  =
  true
 
 val rec__lock_ #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts) : System__atomic_counters__atomic_unsigned.atomic_unsigned
  requires { (lock__pred a) }
  ensures { (result = a.__split_fields.rec__lock) }
 
 function bool_eq #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts) (b : tamper_counts) : bool =
  (if (( ((System__atomic_counters__atomic_unsigned.to_rep a.__split_fields.rec__busy) = (System__atomic_counters__atomic_unsigned.to_rep b.__split_fields.rec__busy)) /\ ((System__atomic_counters__atomic_unsigned.to_rep a.__split_fields.rec__lock) = (System__atomic_counters__atomic_unsigned.to_rep b.__split_fields.rec__lock)) )) then (
   True) else (
   False))
 
 function user_eq #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts) (b : tamper_counts) : bool
 
 function value__size #"a-conhel.ads" 43 0 0# 
   : int
 
 function object__size #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : tamper_counts.
   ((object__size a) >= 0))
 
 function dummy #"a-conhel.ads" 43 0 0# 
   : tamper_counts
 
 type tamper_counts__ref #"a-conhel.ads" 43 0 0# =
  { mutable tamper_counts__content "model_trace:" : tamper_counts }
 
 function tamper_counts__ref___projection #"a-conhel.ads" 43 0 0# 
   (a : tamper_counts__ref) : tamper_counts =
  a.tamper_counts__content
 
 meta "model_projection" function tamper_counts__ref___projection
 
 meta "inline : no" function tamper_counts__ref___projection
 
 val tamper_counts__havoc #"a-conhel.ads" 43 0 0# 
   (x : tamper_counts__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "color_type" defined at a-crbltr.ads:37, created in Gnat2Why.Types.Translate_Type *)
module Ada__containers__red_black_trees__color_type
 use import "_gnatprove_standard".Main
 use import "int".Int

 type color_type #"a-crbltr.ads" 37 0 0# 
 
 function first #"a-crbltr.ads" 37 0 0# 
   : int =
  0
 
 function last #"a-crbltr.ads" 37 0 0# 
   : int =
  1
 
 predicate in_range #"a-crbltr.ads" 37 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = color_type, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type color_type__ref #"a-crbltr.ads" 37 0 0# =
  { mutable color_type__content "model_trace:" : color_type }
 
 function color_type__ref___projection #"a-crbltr.ads" 37 0 0# 
   (a : color_type__ref) : color_type =
  a.color_type__content
 
 meta "model_projection" function color_type__ref___projection
 
 meta "inline : no" function color_type__ref___projection
 
 val color_type__havoc #"a-crbltr.ads" 37 0 0# 
   (x : color_type__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "root_stream_type" defined at a-stream.ads:70, created in Gnat2Why.Types.Translate_Type *)
module Ada__streams__root_stream_type
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main

 type __split_fields #"a-crbltr.ads" 37 0 0# =
  { rec__ext__ "model_trace:" : Main.__private }
 
 function __split_fields_4__projection #"a-crbltr.ads" 37 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__ext__
 
 meta "model_projection" function __split_fields_4__projection
 
 meta "inline : no" function __split_fields_4__projection
 
 type __split_fields__ref #"a-crbltr.ads" 37 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_6__projection #"a-crbltr.ads" 37 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_6__projection
 
 meta "inline : no" function __split_fields__ref_6__projection
 
 val __split_fields__havoc #"a-crbltr.ads" 37 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type root_stream_type #"a-stream.ads" 70 0 0# =
  { __split_fields "model_trace:" : __split_fields; attr__tag "model_trace:" : int }
 
 function root_stream_type___projection #"a-stream.ads" 70 0 0# 
   (a : root_stream_type) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function root_stream_type___projection
 
 meta "inline : no" function root_stream_type___projection
 
 function root_stream_type_2__projection #"a-stream.ads" 70 0 0# 
   (a : root_stream_type) : int =
  a.attr__tag
 
 meta "model_projection" function root_stream_type_2__projection
 
 meta "inline : no" function root_stream_type_2__projection
 
 function user_eq #"a-stream.ads" 70 0 0# 
   (a : root_stream_type) (b : root_stream_type) : bool
 
 function __dispatch_eq #"a-stream.ads" 70 0 0# 
   (a : root_stream_type) (b : root_stream_type) : bool
 
 function __tag #"a-stream.ads" 70 0 0# 
   : int
 
 function value__size #"a-stream.ads" 70 0 0# 
   : int
 
 function object__size #"a-stream.ads" 70 0 0# 
   (a : root_stream_type) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : root_stream_type.
   ((object__size a) >= 0))
 
 function dummy #"a-stream.ads" 70 0 0# 
   : root_stream_type
 
 type root_stream_type__ref #"a-stream.ads" 70 0 0# =
  { mutable root_stream_type__content "model_trace:" : root_stream_type }
 
 function root_stream_type__ref___projection #"a-stream.ads" 70 0 0# 
   (a : root_stream_type__ref) : root_stream_type =
  a.root_stream_type__content
 
 meta "model_projection" function root_stream_type__ref___projection
 
 meta "inline : no" function root_stream_type__ref___projection
 
 val root_stream_type__havoc #"a-stream.ads" 70 0 0# 
   (x : root_stream_type__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "stream_element" defined at a-stream.ads:42, created in Gnat2Why.Types.Translate_Type *)
module Ada__streams__stream_element
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV8

 type stream_element #"a-stream.ads" 42 0 0# 
 
 function attr__ATTRIBUTE_MODULUS #"a-stream.ads" 42 0 0# 
   : BV8.t
 
 function first #"a-stream.ads" 42 0 0# 
   : BV8.t =
  ( BV8.of_int 0 )
 
 function last #"a-stream.ads" 42 0 0# 
   : BV8.t =
  ( BV8.of_int 255 )
 
 function first_int #"a-stream.ads" 42 0 0# 
   : int =
  0
 
 function last_int #"a-stream.ads" 42 0 0# 
   : int =
  255
 
 predicate in_range #"a-stream.ads" 42 0 0# 
   (x : BV8.t)  =
  true
 
 predicate in_range_int #"a-stream.ads" 42 0 0# 
   (x : int)  =
  BV8.uint_in_range x
 
 clone export "ada__model".Static_Modular_8 with
 type t = stream_element, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range, 
 predicate in_range_int = in_range_int
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type stream_element__ref #"a-stream.ads" 42 0 0# =
  { mutable stream_element__content "model_trace:" : stream_element }
 
 function stream_element__ref___projection #"a-stream.ads" 42 0 0# 
   (a : stream_element__ref) : stream_element =
  a.stream_element__content
 
 meta "model_projection" function stream_element__ref___projection
 
 meta "inline : no" function stream_element__ref___projection
 
 val stream_element__havoc #"a-stream.ads" 42 0 0# 
   (x : stream_element__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "Tstream_element_offsetB" defined at a-stream.ads:44, created in Gnat2Why.Types.Translate_Type *)
module Ada__streams__Tstream_element_offsetB
 use import "_gnatprove_standard".Main
 use import "int".Int

 type tstream_element_offsetB #"a-stream.ads" 44 0 0# 
 
 function first #"a-stream.ads" 44 0 0# 
   : int =
  ( -9223372036854775808 )
 
 function last #"a-stream.ads" 44 0 0# 
   : int =
  9223372036854775807
 
 predicate in_range #"a-stream.ads" 44 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = tstream_element_offsetB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type tstream_element_offsetB__ref #"a-stream.ads" 44 0 0# =
  { mutable tstream_element_offsetB__content "model_trace:" : tstream_element_offsetB }
 
 function tstream_element_offsetB__ref___projection #"a-stream.ads" 44 0 0# 
   (a : tstream_element_offsetB__ref) : tstream_element_offsetB =
  a.tstream_element_offsetB__content
 
 meta "model_projection" function tstream_element_offsetB__ref___projection
 
 meta "inline : no" function tstream_element_offsetB__ref___projection
 
 val tstream_element_offsetB__havoc #"a-stream.ads" 44 0 0# 
   (x : tstream_element_offsetB__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "stream_element_offset" defined at a-stream.ads:44, created in Gnat2Why.Types.Translate_Type *)
module Ada__streams__stream_element_offset
 use import "_gnatprove_standard".Main
 use import "int".Int

 type stream_element_offset #"a-stream.ads" 44 0 0# 
 
 function first #"a-stream.ads" 44 0 0# 
   : int =
  ( -9223372036854775808 )
 
 function last #"a-stream.ads" 44 0 0# 
   : int =
  9223372036854775807
 
 predicate in_range #"a-stream.ads" 44 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = stream_element_offset, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type stream_element_offset__ref #"a-stream.ads" 44 0 0# =
  { mutable stream_element_offset__content "model_trace:" : stream_element_offset }
 
 function stream_element_offset__ref___projection #"a-stream.ads" 44 0 0# 
   (a : stream_element_offset__ref) : stream_element_offset =
  a.stream_element_offset__content
 
 meta "model_projection" function stream_element_offset__ref___projection
 
 meta "inline : no" function stream_element_offset__ref___projection
 
 val stream_element_offset__havoc #"a-stream.ads" 44 0 0# 
   (x : stream_element_offset__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "stream_element_count" defined at a-stream.ads:51, created in Gnat2Why.Types.Translate_Type *)
module Ada__streams__stream_element_count
 use import "_gnatprove_standard".Main
 use import "int".Int

 type stream_element_count #"a-stream.ads" 51 0 0# 
 
 function first #"a-stream.ads" 51 0 0# 
   : int =
  0
 
 function last #"a-stream.ads" 51 0 0# 
   : int =
  9223372036854775807
 
 predicate in_range #"a-stream.ads" 51 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = stream_element_count, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type stream_element_count__ref #"a-stream.ads" 51 0 0# =
  { mutable stream_element_count__content "model_trace:" : stream_element_count }
 
 function stream_element_count__ref___projection #"a-stream.ads" 51 0 0# 
   (a : stream_element_count__ref) : stream_element_count =
  a.stream_element_count__content
 
 meta "model_projection" function stream_element_count__ref___projection
 
 meta "inline : no" function stream_element_count__ref___projection
 
 val stream_element_count__havoc #"a-stream.ads" 51 0 0# 
   (x : stream_element_count__ref) : unit
  writes {x}

end

(* Module for axiomatizing the array theory associated to type "stream_element_array" defined at a-stream.ads:54, created in Why.Gen.Arrays.Create_Rep_Array_Theory *)
module Array__Int__Ada__streams__stream_element
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__streams__stream_element

 function index_I1_one #"a-stream.ads" 51 0 0# 
   : int =
  1
 
 type component_type #"a-stream.ads" 51 0 0# =
  Ada__streams__stream_element.stream_element
 
 clone export "_gnatprove_standard".Array__1 with
 type I1.t = int, 
 predicate I1.le = Int.(<=), 
 predicate I1.lt = Int.(<), 
 predicate I1.gt = Int.(>), 
 function I1.add = Int.(+), 
 function I1.sub = Int.(-), 
 function I1.one = index_I1_one, 
 type component_type = component_type
 
 function index_Index_one #"a-stream.ads" 42 0 0# 
   : int =
  1
 
 clone export "ada__model".Array_BV8_Rep_Comparison_Axiom with
 type component_type = component_type, 
 function to_rep = Ada__streams__stream_element.to_rep, 
 type map = map, 
 type Index.t = int, 
 predicate Index.le = Int.(<=), 
 predicate Index.lt = Int.(<), 
 predicate Index.gt = Int.(>), 
 function Index.add = Int.(+), 
 function Index.sub = Int.(-), 
 function Index.one = index_Index_one, 
 function get = get, 
 function bool_eq = bool_eq

end

(* Module for axiomatizing type "stream_element_array" defined at a-stream.ads:54, created in Gnat2Why.Types.Translate_Type *)
module Ada__streams__stream_element_array
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__streams__stream_element
 use        Ada__streams__Tstream_element_offsetB
 use        Ada__streams__stream_element_offset
 use        Array__Int__Ada__streams__stream_element

 type component_type #"a-stream.ads" 42 0 0# =
  Ada__streams__stream_element.stream_element
 
 function index_1_id #"a-stream.ads" 42 0 0# 
   (x : int) : int =
  x
 
 clone export "ada__model".Unconstr_Array with
 type map = Array__Int__Ada__streams__stream_element.map, 
 function array_bool_eq = Array__Int__Ada__streams__stream_element.bool_eq, 
 type index_base_type = Ada__streams__Tstream_element_offsetB.tstream_element_offsetB, 
 type index_rep_type = int, 
 function to_rep = Ada__streams__Tstream_element_offsetB.to_rep, 
 function rep_to_int = index_1_id, 
 predicate in_range_base = Ada__streams__Tstream_element_offsetB.in_range, 
 predicate index_dynamic_property = Ada__streams__stream_element_offset.dynamic_property, 
 predicate index_rep_le = Int.(<=)
 
 type stream_element_array #"a-stream.ads" 54 0 0# =
  __t
 
 meta "model_projection" function to_array
 
 meta "inline : no" function to_array
 
 meta "model_projection" function first
 
 meta "inline : no" function first
 
 meta "model_projection" function last
 
 meta "inline : no" function last
 
 type stream_element_array__ref #"a-stream.ads" 54 0 0# =
  { mutable stream_element_array__content "model_trace:" : stream_element_array }
 
 function stream_element_array__ref___projection #"a-stream.ads" 54 0 0# 
   (a : stream_element_array__ref) : stream_element_array =
  a.stream_element_array__content
 
 meta "model_projection" function stream_element_array__ref___projection
 
 meta "inline : no" function stream_element_array__ref___projection
 
 val stream_element_array__havoc #"a-stream.ads" 54 0 0# 
   (x : stream_element_array__ref) : unit
  writes {x}

end

(* Module for defining the constant "item" defined at a-stream.ads:65, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__streams__write__item
 use import "_gnatprove_standard".Main
 use        Ada__streams__stream_element_array

 function item #"a-stream.ads" 65 0 0# "model_projected" "model_trace:36332" 
   : Ada__streams__stream_element_array.stream_element_array
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 54 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at a-stream.ads:65, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__write__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for axiomatizing type "Troot_stream_typeC" defined at a-stream.ads:39, created in Gnat2Why.Types.Translate_Type *)
module Ada__streams__Troot_stream_typeC
 use export Ada__streams__root_stream_type
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "v" defined at a-stream.ads:82, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__streams__write_sea__v
 use import "_gnatprove_standard".Main
 use        Ada__streams__stream_element_array

 function v #"a-stream.ads" 82 0 0# "model_projected" "model_trace:36402" 
   : Ada__streams__stream_element_array.stream_element_array
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 54 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "v" defined at a-stream.ads:82, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__write_sea__v__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "v" defined at a-stream.ads:85, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__streams__stream_element_arraySW__v
 use import "_gnatprove_standard".Main
 use        Ada__streams__stream_element_array

 function v #"a-stream.ads" 85 0 0# 
   : Ada__streams__stream_element_array.stream_element_array
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 54 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "v" defined at a-stream.ads:85, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__stream_element_arraySW__v__axiom
 use import "_gnatprove_standard".Main


end

(* Module for axiomatizing type "TnodeB" defined at graph.ads:7, created in Gnat2Why.Types.Translate_Type *)
module Graph__TnodeB
 use import "_gnatprove_standard".Main
 use import "int".Int

 type tnodeB #"graph.ads" 7 0 0# 
 
 function first #"graph.ads" 7 0 0# 
   : int =
  ( -128 )
 
 function last #"graph.ads" 7 0 0# 
   : int =
  127
 
 predicate in_range #"graph.ads" 7 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = tnodeB, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type tnodeB__ref #"graph.ads" 7 0 0# =
  { mutable tnodeB__content "model_trace:" : tnodeB }
 
 function tnodeB__ref___projection #"graph.ads" 7 0 0# 
   (a : tnodeB__ref) : tnodeB =
  a.tnodeB__content
 
 meta "model_projection" function tnodeB__ref___projection
 
 meta "inline : no" function tnodeB__ref___projection
 
 val tnodeB__havoc #"graph.ads" 7 0 0# 
   (x : tnodeB__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "node" defined at graph.ads:7, created in Gnat2Why.Types.Translate_Type *)
module Graph__node
 use import "_gnatprove_standard".Main
 use import "int".Int

 type node #"graph.ads" 7 0 0# 
 
 function first #"graph.ads" 7 0 0# 
   : int =
  0
 
 function last #"graph.ads" 7 0 0# 
   : int =
  10
 
 predicate in_range #"graph.ads" 7 0 0# 
   (x : int)  =
  ( (first <= x) /\ (x <= last) )
 
 clone export "ada__model".Static_Discrete with
 type t = node, 
 function first = first, 
 function last = last, 
 predicate in_range = in_range
 
 meta "model_projection" function to_rep
 
 meta "inline : no" function to_rep
 
 type node__ref #"graph.ads" 7 0 0# =
  { mutable node__content "model_trace:" : node }
 
 function node__ref___projection #"graph.ads" 7 0 0# 
   (a : node__ref) : node =
  a.node__content
 
 meta "model_projection" function node__ref___projection
 
 meta "inline : no" function node__ref___projection
 
 val node__havoc #"graph.ads" 7 0 0# 
   (x : node__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "edge" defined at graph.ads:8, created in Gnat2Why.Types.Translate_Type *)
module Graph__edge
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Graph__node

 type __split_fields #"graph.ads" 7 0 0# =
  { rec__to "model_trace:.3124" : Graph__node.node; rec__from "model_trace:.3134" : Graph__node.node }
 
 function __split_fields_To__projection #"graph.ads" 7 0 0# "model_trace:.3124" 
   (a : __split_fields) : Graph__node.node =
  a.rec__to
 
 meta "model_projection" function __split_fields_To__projection
 
 meta "inline : no" function __split_fields_To__projection
 
 function __split_fields_From__projection #"graph.ads" 8 0 0# "model_trace:.3134" 
   (a : __split_fields) : Graph__node.node =
  a.rec__from
 
 meta "model_projection" function __split_fields_From__projection
 
 meta "inline : no" function __split_fields_From__projection
 
 type __split_fields__ref #"graph.ads" 8 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_7__projection #"graph.ads" 8 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_7__projection
 
 meta "inline : no" function __split_fields__ref_7__projection
 
 val __split_fields__havoc #"graph.ads" 8 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type edge #"graph.ads" 8 0 0# =
  { __split_fields "model_trace:" : __split_fields }
 
 function edge___projection #"graph.ads" 8 0 0# 
   (a : edge) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function edge___projection
 
 meta "inline : no" function edge___projection
 
 predicate to____pred #"graph.ads" 8 0 0# 
   (a : edge)  =
  true
 
 val rec__to_ #"graph.ads" 8 0 0# 
   (a : edge) : Graph__node.node
  requires { (to____pred a) }
  ensures { (result = a.__split_fields.rec__to) }
 
 predicate from__pred #"graph.ads" 8 0 0# 
   (a : edge)  =
  true
 
 val rec__from_ #"graph.ads" 8 0 0# 
   (a : edge) : Graph__node.node
  requires { (from__pred a) }
  ensures { (result = a.__split_fields.rec__from) }
 
 function bool_eq #"graph.ads" 8 0 0# 
   (a : edge) (b : edge) : bool =
  (if (( ((Graph__node.to_rep a.__split_fields.rec__to) = (Graph__node.to_rep b.__split_fields.rec__to)) /\ ((Graph__node.to_rep a.__split_fields.rec__from) = (Graph__node.to_rep b.__split_fields.rec__from)) )) then (
   True) else (
   False))
 
 function user_eq #"graph.ads" 8 0 0# 
   (a : edge) (b : edge) : bool
 
 function value__size #"graph.ads" 8 0 0# 
   : int
 
 function object__size #"graph.ads" 8 0 0# 
   (a : edge) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : edge.
   ((object__size a) >= 0))
 
 function dummy #"graph.ads" 8 0 0# 
   : edge
 
 type edge__ref #"graph.ads" 8 0 0# =
  { mutable edge__content "model_trace:" : edge }
 
 function edge__ref___projection #"graph.ads" 8 0 0# 
   (a : edge__ref) : edge =
  a.edge__content
 
 meta "model_projection" function edge__ref___projection
 
 meta "inline : no" function edge__ref___projection
 
 val edge__havoc #"graph.ads" 8 0 0# 
   (x : edge__ref) : unit
  writes {x}

end

(* Module for defining the constant "e" defined at graph.ads:17, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__Olt__e
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function e #"graph.ads" 17 0 0# "model_projected" "model_trace:3153" 
   : Graph__edge.edge
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 8 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "e" defined at graph.ads:17, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__Olt__e__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "f" defined at graph.ads:17, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__Olt__f
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function f #"graph.ads" 17 0 0# "model_projected" "model_trace:3162" 
   : Graph__edge.edge
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 8 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "f" defined at graph.ads:17, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__Olt__f__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "Olt" defined at graph.ads:17, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Graph__Olt
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function olt #"graph.ads" 17 0 0# 
   (e : Graph__edge.edge) (f : Graph__edge.edge) : bool

end

(* Module for defining the constant "A1s" defined at graph.ads:21, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphnode__Olt__A1s
 use import "_gnatprove_standard".Main

 function a1s #"graph.ads" 21 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "A1s" defined at graph.ads:21, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphnode__Olt__A1s__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "B2s" defined at graph.ads:21, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphnode__Olt__B2s
 use import "_gnatprove_standard".Main

 function b2s #"graph.ads" 21 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "B2s" defined at graph.ads:21, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphnode__Olt__B2s__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "A4s" defined at graph.ads:21, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphnode__Oeq__A4s
 use import "_gnatprove_standard".Main

 function a4s #"graph.ads" 21 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "A4s" defined at graph.ads:21, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphnode__Oeq__A4s__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "B5s" defined at graph.ads:21, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphnode__Oeq__B5s
 use import "_gnatprove_standard".Main

 function b5s #"graph.ads" 21 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "B5s" defined at graph.ads:21, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphnode__Oeq__B5s__axiom
 use import "_gnatprove_standard".Main


end

(* Module for declaring a why type for the formal "element_type" defined at a-cforse.ads:62, created in Gnat2Why.External_Axioms.Parse_Parameters *)
module Graph__graphnode__element_type
 use export Graph__node
 use import "_gnatprove_standard".Main

 type element_type #"graph.ads" 7 0 0# =
  int

end

(* Module for declaring a logic function for the formal "Olt" defined at a-cforse.ads:64, created in Gnat2Why.External_Axioms.Parse_Parameters *)
module Graph__graphnode__Olt
 use        "_gnatprove_standard".Integer
 use        "_gnatprove_standard".Integer
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".Integer

 function olt #"graph.ads" 7 0 0# "inline" 
   (ada__containers__formal_ordered_sets__Olt__left : int) (ada__containers__formal_ordered_sets__Olt__right : int) : bool =
  (Integer.bool_lt ada__containers__formal_ordered_sets__Olt__left ada__containers__formal_ordered_sets__Olt__right)

end

(* Module for declaring a logic function for the formal "Oeq" defined at a-cforse.ads:65, created in Gnat2Why.External_Axioms.Parse_Parameters *)
module Graph__graphnode__Oeq
 use        "_gnatprove_standard".Integer
 use        "_gnatprove_standard".Integer
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".Integer

 function oeq #"a-cforse.ads" 64 0 0# "inline" 
   (ada__containers__formal_ordered_sets__Oeq__left : int) (ada__containers__formal_ordered_sets__Oeq__right : int) : bool =
  (Integer.bool_eq ada__containers__formal_ordered_sets__Oeq__left ada__containers__formal_ordered_sets__Oeq__right)

end


module Graph__graphnode__witness
  use import real.Real
  use Graph__node
  use Graph__graphnode__Olt

  function witness int : real

  axiom olt_witness :
    (forall k1  k2 : int [Graph__graphnode__Olt.olt k1 k2].
	Real.(<) (witness k1) (witness k2) <-> Graph__graphnode__Olt.olt k1 k2 = True)
end

module Graph__graphnode__set
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__hash_type
  use Ada__containers__count_type

  type __split_discrs = {rec__capacity : Ada__containers__count_type.count_type}

  type __split_discrs__ref = { mutable __split_discrs__content : __split_discrs }
  val __split_discrs__havoc (x : __split_discrs__ref) : unit
     writes { x }

  type __split_fields = { rec__main__ : __private }

  type __split_fields__ref = { mutable __split_fields__content : __split_fields }
  val __split_fields__havoc (x : __split_fields__ref) : unit
     writes { x }

  type set = { __split_discrs : __split_discrs; __split_fields : __split_fields }

  type set__ref = { mutable set__content : set }
  val set__havoc (x : set__ref) : unit
     writes { x }

  predicate set_inv "inline" (l : set) =
     l = { __split_discrs = { rec__capacity = l.__split_discrs.rec__capacity }; __split_fields = { rec__main__ = l.__split_fields.rec__main__ } }

   function capacity  (co : set) : int =
          Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  function bool_eq set set : bool
  function user_eq set set : bool
end

module Graph__graphnode__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Graph__graphnode__set

  function length__logic set : int

  function length_ "inline" (co : set) : int =
    length__logic co

  axiom length_range:
    forall co:set [length__logic co]. 0 <= length_ co <= capacity co

  val length (co : set) : int
     ensures { result = length__logic co }
end

module Graph__graphnode__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__length

  type __split_fields = { rec__main__ : __private }

  type __split_fields__ref = { mutable __split_fields__content : __split_fields }
  val __split_fields__havoc (x : __split_fields__ref) : unit
     writes { x }

  type cursor = { __split_fields : __split_fields }

  type cursor__ref = { mutable cursor__content : cursor }
  val cursor__havoc (x : cursor__ref) : unit
     writes { x }

  function dummy : cursor

  function position set cursor : int

  function position_inv set int : cursor

  axiom position_gte_zero:
    forall co:set, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:set, i :int [position co (position_inv co i)]. 0 < i <= length_ co ->
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:set, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu

  function bool_eq "inline" (c1:cursor) (c2:cursor) : bool = c1 = c2
  function user_eq cursor cursor : bool
end

module Graph__graphnode__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:set [position co no_element]. position co no_element = 0
end

module Graph__graphnode__empty_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length

  function empty_set : set

  axiom Empty_is_empty: length_ empty_set = 0
end

module Graph__graphnode__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length

  function is_empty__logic set : bool

  axiom is_empty:
    forall co:set [is_empty__logic (co)].
          is_empty__logic (co) = True <-> length_ co = 0

  val is_empty (co:set) : bool
     ensures  { result = is_empty__logic co }
end

module Graph__graphnode__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor

  function element__logic set cursor : int

  axiom element__range:
   forall co:set, cu:cursor. Graph__node.in_range (element__logic co cu)

  axiom ordered:
    forall s:set, cu1 cu2:cursor [element__logic s cu2, element__logic s cu1].
       position s cu1 > 0 -> position s cu2 > 0 ->
         (position s cu1 > position s cu2 <-> Real.(>) (witness (element__logic s cu1)) (witness (element__logic s cu2)))

  val element (co:set) (cu:cursor) : int
     requires { position co cu > 0 }
     ensures  { result = element__logic co cu }
end

module Graph__graphnode__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element

  function previous__logic set cursor : cursor

  axiom previous_in:
    forall co:set, cu:cursor [previous__logic co cu].
	(position co cu > 1 \/ position co (previous__logic co cu) > 0) ->
	position co (previous__logic co cu) = position co cu - 1

  axiom previous_ext:
    forall co:set, cu:cursor [previous__logic co cu].
        (position co cu = 1 \/ cu = no_element) -> previous__logic co cu = no_element

  val previous (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous__logic co cu }
end

module Graph__graphnode__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__previous

  val previous__2 (co:set) (cu:cursor__ref) : unit
     requires { cu.cursor__content = no_element \/ position co cu.cursor__content > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { cu.cursor__content = previous__logic co (old cu.cursor__content) }
end

module Graph__graphnode__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element

  function next__logic set cursor : cursor

  axiom next_in:
    forall co:set, cu:cursor [next__logic co cu].
	(length_ co > position co cu > 0 \/ position co (next__logic co cu) > 0) ->
	position co (next__logic co cu) = position co cu + 1

  axiom next_ext:
    forall co:set, cu:cursor [next__logic co cu].
        (position co cu = length_ co \/ cu = no_element) -> next__logic co cu = no_element

  val next (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next__logic co cu }
end

module Graph__graphnode__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__next

  val next__2 (co:set) (cu:cursor__ref) : unit
     requires { cu.cursor__content = no_element \/ position co cu.cursor__content > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { cu.cursor__content = next__logic co (old cu.cursor__content) }
end

module Graph__graphnode__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element

  function last__logic set : cursor

  axiom last_empty:
    forall co:set [last__logic co]. length_ co = 0 <-> last__logic co = no_element

  axiom last_gen:
    forall co:set [last__logic co]. length_ co = position co (last__logic co)

  val last (co:set) : cursor
     ensures  { result = last__logic co }
end

module Graph__graphnode__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element

  function first__logic set : cursor

  axiom first_empty:
    forall co:set [first__logic co]. length_ co = 0 <-> first__logic co = no_element

  axiom first_gen:
    forall co:set [first__logic co]. length_ co > 0 -> position co (first__logic co) = 1

  val first (co:set) : cursor
     ensures  { result = first__logic co }
end

module Graph__graphnode__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__first
  use import Graph__graphnode__element

  function first_element__logic (co:set) : int = element__logic co (first__logic co)

  val first_element (co:set) : int
     requires { length_ co > 0 }
     ensures  { result = element__logic co (first__logic co) }
end

module Graph__graphnode__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__last
  use import Graph__graphnode__element

  function last_element__logic (co:set) : int = element__logic co (last__logic co)

  val last_element (co:set) : int
     requires { length_ co > 0 }
     ensures  { result = element__logic co (last__logic co) }
end

module Graph__graphnode__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__witness
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__element

  function find_ set real : cursor

  predicate find__ (co : set) (i : real) (cu : cursor) =
    (cu = (no_element  : cursor) /\
      (forall cun:cursor.
        position co cun >  0 ->
         witness (element__logic co cun) <> i)) \/
     (position co cu > 0 /\
      witness (element__logic co cu) = i)

  axiom Find_find_val:
    (forall co:set.
      (forall i:real.
        ((find__ co i (find_ co i)) /\
         ((length_ co = 0) -> (find_ co i = no_element )))))

  function find__logic "inline" (co : set) (e:int) : cursor =
  find_ co (witness e)

  val find (co:set) (e:int)  : cursor
     ensures  { result = find__logic co e }
end

module Graph__graphnode__ceiling
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__witness
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__last
  use import Graph__graphnode__element

  function ceiling_ set real : cursor

  predicate is_ceiling (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
        Real.(>) i (witness (element__logic s (last__logic s))))) \/
      (position s cu > 0 /\
       Real.(<=) i (witness (element__logic s cu)) /\
	(forall cun : cursor [element__logic s cun]. 0 < position s cun < position s cu
	 -> Real.(>) i (witness (element__logic s cun))))

  axiom ceiling_is_ceiling:
    forall s:set.
      forall i:real [(ceiling_ s i : cursor)].
        is_ceiling s i (ceiling_ s i : cursor)

  function ceiling__logic  "inline" (co:set) (e:int) : cursor =
 ceiling_ co (witness e)

  val ceiling (co:set) (e:int) :cursor
     ensures { result = ceiling_ co (witness e) }
end

module Graph__graphnode__floor
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__witness
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__first
  use import Graph__graphnode__element

  function floor_ set real : cursor

  predicate is_floor (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
         Real.(<) i (witness (element__logic s (first__logic s))))) \/
      (position s cu > 0 /\
       Real.(>=) i (witness (element__logic s cu)) /\
	(forall cun : cursor. position s cu < position s cun
	 ->  Real.(<) i (witness (element__logic s cun))))

  axiom floor_is_floor:
    (forall s:set.
      (forall i:real [(floor_ s i : cursor)].
        (is_floor s i (floor_ s i : cursor))))

  function floor__logic  "inline" (co:set) (e:int) : cursor =
 floor_ co (witness e)

  val floor (co:set) (e:int) :cursor
     ensures { result = floor_ co (witness e) }
end

module Graph__graphnode__first_to_previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__element
  use import Graph__graphnode__find

  function first_to_previous__logic set cursor : set

  axiom first_to_previous_no_element:
    forall co:set [first_to_previous__logic co no_element]. first_to_previous__logic co no_element = co

  axiom first_to_previous_length_:
    forall co:set, cu:cursor [first_to_previous__logic co cu].
	position co cu > 0 -> length_ (first_to_previous__logic co cu) = position co cu - 1

  axiom first_to_previous_position_in:
    forall co:set, cu cun:cursor [position (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, position co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ position co cun < position co cu) ->
	position (first_to_previous__logic co cu) cun = position co cun

  axiom first_to_previous_position_ext:
    forall co:set, cu cun:cursor [position (first_to_previous__logic co cu) cun].
	position co cun >= position co cu > 0 ->
	position (first_to_previous__logic co cu) cun = 0

  axiom first_to_previous_element:
    forall co:set, cu cun:cursor [element__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, element__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element__logic (first_to_previous__logic co cu) cun = element__logic co cun

  axiom first_to_previous_find :
    forall co:set, cu:cursor, w:real [find_ co w, first_to_previous__logic co cu|
     find_ (first_to_previous__logic co cu) w].
     ((position co cu > position co (find_ co w) > 0 \/
      position (first_to_previous__logic co cu) (find_ (first_to_previous__logic co cu) w) > 0) ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
      (position co (find_ co w) >= position co cu -> find_ (first_to_previous__logic co cu) w = no_element)

  axiom first_to_previous_find_elt :
    forall co:set, cu:cursor, w:real [element__logic co cu, find_ co w, first_to_previous__logic co cu|
     element__logic co cu, find_ (first_to_previous__logic co cu) w].
     (Real.(>) (witness (element__logic co cu)) w  ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
     (Real.(<=) (witness (element__logic co cu)) w  ->
      find_ (first_to_previous__logic co cu) w = no_element)

  val first_to_previous (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = first_to_previous__logic co cu /\ set_inv result }
end

module Graph__graphnode__current_to_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__empty_set
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__element
  use import Graph__graphnode__find

  function current_to_last__logic set cursor : set

  axiom current_to_last_no_element:
    forall co:set [current_to_last__logic co no_element]. current_to_last__logic co no_element = empty_set

  axiom current_to_last_length_:
    forall co:set, cu:cursor [length_ (current_to_last__logic co cu) ].
	position co cu > 0 -> length_ (current_to_last__logic co cu) = (length_ co) - (position co cu) + 1

  axiom current_to_last_position_in:
    forall co:set, cu cun:cursor [position (current_to_last__logic co cu) cun | current_to_last__logic co cu, position co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (current_to_last__logic co cu) cun = (position co cun) - (position co cu) + 1

  axiom current_to_last_position_ext:
    forall co:set, cu cun:cursor [position (current_to_last__logic co cu) cun].
	position co cun < position co cu -> position (current_to_last__logic co cu) cun = 0

  axiom current_to_last_element:
    forall co:set, cu cun:cursor [element__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, element__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element__logic (current_to_last__logic co cu) cun = element__logic co cun

  axiom current_to_last_find :
    forall co:set, cu:cursor, w:real [find_ (current_to_last__logic co cu) w| current_to_last__logic co cu,
     find_ co w].
     ((0 < position co cu <= position co (find_ co w) \/
      position (current_to_last__logic co cu) (find_ (current_to_last__logic co cu) w) > 0) ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
      (position co (find_ co w) < position co cu -> find_ (current_to_last__logic co cu) w = no_element)

  axiom current_to_last_find_elt :
    forall co:set, cu:cursor, w:real [element__logic co cu, find_ co w, current_to_last__logic co cu|
     element__logic co cu, find_ (current_to_last__logic co cu) w].
     (Real.(<=) (witness (element__logic co cu)) w  ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
     (Real.(>) (witness (element__logic co cu)) w  ->
      find_ (current_to_last__logic co cu) w = no_element)

  val current_to_last (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = current_to_last__logic co cu /\ set_inv result }
end

module Graph__graphnode__replace
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use Graph__graphnode__Oeq
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__empty_set
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__element
  use import Graph__graphnode__find

  predicate replace (co1:set) (e:int) (co2:set) =
    (position co1 (find_ co1 (witness e)) > 0 /\
      length_ co1 = length_ co2 /\
       Graph__graphnode__Oeq.oeq (element__logic co2 (find_ co1 (witness e))) e /\
        (forall cun:cursor [position co2 cun | position co1 cun]. position co2 cun = position co1 cun) /\
         (forall cun:cursor [element__logic co2 cun | element__logic co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness e) ->
            element__logic co2 cun = element__logic co1 cun) /\
          (forall w:real [find_ co1 w | find_ co2 w]. find_ co1 w = find_ co2 w)) /\
     capacity co1 = capacity co2

  val replace (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (e:int) : unit
     requires { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes { co }
     reads { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   replace old_co e rec_co }
end

module Graph__graphnode__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use Graph__graphnode__Oeq
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__element
  use import Graph__graphnode__find

  predicate replace_element set cursor int set

  axiom replace_element_length_:
    forall co1 co2:set, cu:cursor, e:int
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:set, cu:cursor, e:int
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position:
    forall co1 co2:set, cu cun:cursor, e:int
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> (position co2 cun > 0 <-> position co1 cun > 0)

  axiom replace_element_element_in:
    forall co1 co2:set, cu:cursor, e:int
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Graph__graphnode__Oeq.oeq (element__logic co2 cu) e /\ find_ co2 (witness  e) = cu

  axiom replace_element_element_ext:
    forall co1 co2:set, cu cun:cursor, e:int
      [replace_element co1 cu e co2, element__logic co2 cun
     | replace_element co1 cu e co2, element__logic co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element__logic co2 cun = element__logic co1 cun

  axiom replace_element_find:
    forall co1 co2:set, cu:cursor, w:real, e:int
      [replace_element co1 cu e co2, find_ co2 w
     | replace_element co1 cu e co2, find_ co1 w].
       replace_element co1 cu e co2 -> not witness e = w ->
       find_ co1 w = find_ co2 w

  val replace_element (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (cu:cursor) (e:int) : unit
     requires { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   position rec_co cu > 0 /\ (find_ rec_co (witness e) = no_element \/ find_ rec_co (witness e) = cu) }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   replace_element old_co cu e rec_co }
end

module Graph__graphnode__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use Graph__graphnode__Oeq
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__last
  use import Graph__graphnode__element
  use import Graph__graphnode__find
  use import Graph__graphnode__ceiling

  predicate insert set int set

  axiom insert_length_:
    forall co1 co2:set,  e:int
      [insert co1 e co2].
      insert co1 e co2 -> length_ co1 + 1 = length_ co2 /\ find_ co1 (witness e) = no_element /\ Graph__graphnode__Oeq.oeq (element__logic co2 (find_ co2 (witness e))) e

  axiom insert_capacity:
    forall co1 co2:set, e:int
      [insert co1 e co2, capacity co1|insert co1 e co2, capacity co2].
      insert co1 e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:set, e:int [insert co1 e co2].
      insert co1 e co2 -> (ceiling_ co1 (witness e) <> no_element ->
      position co2 (find_ co2 (witness e)) = position co1 (ceiling_ co1 (witness e))) /\ (ceiling_ co1 (witness e) = no_element ->
      find_ co2 (witness e) = last__logic co2)

  axiom insert_position_before:
    forall co1 co2:set, cun:cursor, e:int
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (i > position co1 cun > 0 \/ position co2 cun < i) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:set, cun:cursor, e:int
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (position co1 cun >= i \/ position co2 cun > i) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_element:
    forall co1 co2:set, cun:cursor, e:int
      [insert co1 e co2,  element__logic co1 cun
     | insert co1 e co2,  element__logic co2 cun].
      insert co1 e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness e) <> cun) ->
        element__logic co1 cun = element__logic co2 cun

  axiom insert_find :
    forall co1:set, co2:set, w:real, e:int
     [insert co1 e co2, find_ co1 w| insert co1 e co2, find_ co2 w].
     insert co1 e co2 -> not witness e = w -> find_ co1 w = find_ co2 w

  val insert (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (e:int)  (p:cursor__ref) (inserted : bool__ref) : unit
     requires { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co }
     writes     { co, p, inserted }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   (inserted.bool__content = True <-> find_ old_co (witness e) = no_element) /\ p.cursor__content = find_ rec_co (witness e) /\
                          if inserted.bool__content = True then (insert old_co e rec_co)
                                                                 else (co.Graph__graphnode__set.__split_fields__content = old co.Graph__graphnode__set.__split_fields__content) }
end

module Graph__graphnode__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__insert
  use import Graph__graphnode__find

  val insert__2 (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (e:int) : unit
     requires { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co /\ find_ rec_co (witness e) = no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   insert old_co e rec_co }
end

module Graph__graphnode__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__next
  use import Graph__graphnode__element
  use import Graph__graphnode__find

  predicate delete set cursor set

  axiom delete_capacity:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu /\ find_ co2 (witness (element__logic co1 cu)) = no_element

  axiom delete_position_next:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next__logic co1 cu) >= 0

  axiom delete_element:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  element__logic co1 cun
     | delete co1 cu co2,  element__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element__logic co1 cun = element__logic co2 cun

  axiom delete_find :
    forall co1:set, co2:set, cu:cursor, w:real [delete co1 cu co2,
     find_ co1 w| delete co1 cu co2, find_ co2 w].
     delete co1 cu co2 -> not witness (element__logic co1 cu) = w -> find_ co1 w = find_ co2 w

  val delete (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (e : int) : unit
     requires { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   delete old_co (find_ old_co (witness e)) rec_co }
end

module Graph__graphnode__delete__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__delete

  val delete__2 (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (cu:cursor__ref) : unit
     requires { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   position rec_co cu.cursor__content > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   delete old_co (old cu.cursor__content) rec_co /\ cu.cursor__content = no_element}
 end

module Graph__graphnode__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__first
  use import Graph__graphnode__delete

  val delete__first (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   if length_ old_co = 0 then co.Graph__graphnode__set.__split_fields__content = (old co.Graph__graphnode__set.__split_fields__content) else delete old_co (first__logic old_co) rec_co }
 end

module Graph__graphnode__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__last
  use import Graph__graphnode__delete

  val delete__last (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   if length_ old_co = 0 then co.Graph__graphnode__set.__split_fields__content = (old co.Graph__graphnode__set.__split_fields__content) else delete old_co (last__logic old_co) rec_co }
 end

module Graph__graphnode__include
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__replace
  use import Graph__graphnode__insert
  use import Graph__graphnode__find

  val include (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (e :int) : unit
     requires { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   length_ rec_co  < capacity rec_co}
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   if find_ old_co (witness e) <> no_element then replace old_co e rec_co
                         else insert old_co e rec_co  }
end

module Graph__graphnode__exclude
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__delete
  use import Graph__graphnode__find

  val exclude (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (e :int) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co = {Graph__graphnode__set.__split_fields = old co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   if find_ old_co (witness e) = no_element then  old co.Graph__graphnode__set.__split_fields__content = co.Graph__graphnode__set.__split_fields__content
                         else delete old_co (find_ old_co (witness e)) rec_co  }
end

module Graph__graphnode__to_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use Graph__graphnode__Oeq
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__first
  use import Graph__graphnode__element

  function to_set__logic int : set

  axiom to_set__def:
  forall e : int [to_set__logic e].
    length_ (to_set__logic e) = 1 /\ Graph__graphnode__Oeq.oeq (element__logic (to_set__logic e) (first__logic (to_set__logic e))) e

 val  to_set  (e: int) : set
     ensures { result = to_set__logic e /\ set_inv result }
end

module Graph__graphnode__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor

  function has_element__logic set cursor : bool

  axiom has_element_pos:
    forall co:set, cu:cursor [has_element__logic co cu].
    has_element__logic co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:set, cu:cursor [has_element__logic co cu].
    has_element__logic co cu <> True -> position co cu = 0

  val has_element (co:set) (cu:cursor) : bool
     ensures { has_element__logic co cu = result }
end

module Graph__graphnode__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__find

  function contains__logic set int : bool

  axiom contains_c:
  forall co : set, e : int [contains__logic co e].
    contains__logic co e = True <-> 0 < position co (find_ co (witness e))

  val contains (co:set) (e:int) : bool
     ensures { contains__logic co e = result }
end

module Graph__graphnode__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__element

  function strict_equal__logic set set : bool

  axiom strict_equal__def:
    forall co1 co2 : set [strict_equal__logic co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu > 0 <-> position co2 cu > 0) /\
     (forall cu:cursor [element__logic co1 cu | element__logic co2 cu]. position co1 cu > 0 ->
        element__logic co1 cu = element__logic co2 cu)) <->  strict_equal__logic co1 co2 = True

  axiom strict_equal__pos:
    forall co1 co2 : set [strict_equal__logic co1 co2].
    strict_equal__logic co1 co2 = True -> (forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu)

  axiom strict_equal_length_:
    forall co1 co2 : set [strict_equal__logic co1 co2].
     strict_equal__logic co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:set) (co2:set) : bool
     ensures  { result  = strict_equal__logic co1 co2 }
end

module Graph__graphnode__Oeq__2
  use import int.Int
  use Graph__node
  use Graph__graphnode__Oeq
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__element
  use import Graph__graphnode__find

  function oeq__2__logic set set : bool

  axiom oeq__2_length_:
   forall co1 co2 : set [oeq__2__logic co1 co2].
   oeq__2__logic co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : set [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 = True ->
   forall cu1 : cursor [element__logic co1 cu1]. position co1 cu1 > 0 ->
	let cu2 = find_ co2 (witness (element__logic co1 cu1)) in
          position co2 cu2 > 0 /\
          Graph__graphnode__Oeq.oeq (element__logic co2 cu2) (element__logic co1 cu1) = True

  axiom oeq__2_inv:
   forall co1 co2 : set [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists e : real. position co1 (find_ co1 e) > 0 /\
         (find_ co2 e = no_element \/ position co2 (find_ co2 e) > 0 /\
          Graph__graphnode__Oeq.oeq (element__logic co2 (find_ co2 e)) (element__logic co1 (find_ co1 e)) <> True))

  axiom oeq__2_sym :
  forall e1 e2 : set [oeq__2__logic e1 e2].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e1 = True

  axiom oeq__2_trans :
  forall e1 e2 e3 : set [oeq__2__logic e1 e2, oeq__2__logic e1 e3 | oeq__2__logic e1 e2, oeq__2__logic e2 e3].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e3 = True -> oeq__2__logic e1 e3 = True

  val oeq__2 (co1:set) (co2:set) : bool
     ensures  { result  = oeq__2__logic co1 co2 }
end

module Graph__graphnode__equivalent_sets
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__find

  function equivalent_sets__logic set set : bool

  axiom equivalent_sets__def :
    forall co1:set, co2:set [equivalent_sets__logic co1 co2].
     (forall i:real.
       not find_ co1 i = no_element -> not find_ co2 i = no_element) /\
      length_ co1 = length_ co2 <-> equivalent_sets__logic co1 co2 = True

  axiom equivalent_sym :
    forall co1:set.
     forall co2:set [equivalent_sets__logic co2 co1| equivalent_sets__logic co1 co2].
      equivalent_sets__logic co1 co2 = True -> equivalent_sets__logic co2 co1 = True

  val equivalent_sets (co1:set) (co2:set) : bool
  ensures { result  = equivalent_sets__logic co1 co2 }
end

module Graph__graphnode__intersection
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__find

  function intersection set set : set

  predicate is_inter (s1:set) (s2:set) (i:set) =
    forall j:real [find_ s1 j, find_ s2 j| find_ i j].
     (not find_ s1 j = no_element /\ not find_ s2 j = no_element ->
       not find_ i j = no_element) /\
      (find_ s1 j = no_element \/ find_ s2 j = no_element ->
        find_ i j = no_element)

  axiom Inter_is_inter :
    forall s1:set.
     forall s2:set [intersection s1 s2].
      is_inter s1 s2 (intersection s1 s2) /\
       length_ (intersection s1 s2) = length_ (intersection s2 s1)

  val intersection (co1:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphnode__set.__split_fields = co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphnode__set.__split_fields = old co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   rec_co1 = intersection old_co1 co2 }
end

module Graph__graphnode__intersection__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__intersection

  function intersection__2__logic "inline" (co1 co2 : set) : set = intersection co1 co2

  val intersection__2 (co1 co2 : set) : set
    ensures { result = intersection co1 co2 /\ set_inv result }
end

module Graph__graphnode__union
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__find
  use import Graph__graphnode__intersection

  function union set set : set

  predicate is_union (s1:set) (s2:set) (u:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ u i].
      (not find_ s1 i = no_element \/ not find_ s2 i = no_element ->
        not find_ u i = no_element) /\
       (find_ s1 i = no_element /\ find_ s2 i = no_element ->
         find_ u i = no_element)) /\
     length_ u = ((length_ s1 + length_ s2) - length_ (intersection s1 s2))

  axiom union_is_union :
    forall s1:set. forall s2:set [union s1 s2]. is_union s1 s2 (union s1 s2)

  val union (co1:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs)(co2:set) :unit
     requires { let rec_co1 = {Graph__graphnode__set.__split_fields = co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   length_ (union rec_co1 co2) <= capacity rec_co1}
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphnode__set.__split_fields = co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphnode__set.__split_fields = old co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   rec_co1 = union old_co1 co2 }
end

module Graph__graphnode__union__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__union

  function union__2__logic set set : set

  axiom union__2__def :
     forall co1 co2 : set [union__2__logic co1 co2].
	  length_ (union co1 co2) <=  Ada__containers__count_type.last ->
          union__2__logic co1 co2 = union co1 co2

  val union__2 (co1 co2 : set) : set
    requires { length_ (union co1 co2) <=  Ada__containers__count_type.last }
    ensures { result = union co1 co2 /\ set_inv result }
end

module Graph__graphnode__difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__find
  use import Graph__graphnode__intersection

  function difference set set : set

  predicate is_diff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (find_ s1 i = no_element \/ not find_ s2 i = no_element ->
         find_ d i = no_element)) /\
     length_ d = (length_ s1 - length_ (intersection s1 s2))

  axiom diff_is_diff :
    forall s1:set.
     forall s2:set [difference s1 s2]. is_diff s1 s2 (difference s1 s2)

  val difference (co1:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphnode__set.__split_fields = co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphnode__set.__split_fields = old co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   rec_co1 = difference old_co1 co2 }
end

module Graph__graphnode__difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__difference

  function difference__2__logic "inline" (co1 co2 : set) : set = difference co1 co2

  val difference__2 (co1 co2 : set) : set
    ensures { result = difference co1 co2 /\ set_inv result }
end

module Graph__graphnode__symmetric_difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__find
  use import Graph__graphnode__intersection

  function symmetric_difference set set : set

  predicate is_sdiff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (not find_ s2 i = no_element /\ find_ s1 i = no_element ->
         not find_ d i = no_element) /\
        (find_ s2 i = no_element /\ find_ s1 i = no_element ->
          find_ d i = no_element) /\
         (not find_ s2 i = no_element /\ not find_ s1 i = no_element ->
           find_ d i = no_element)) /\
     length_ d =
      ((length_ s1 + length_ s2) - (2 * length_ (intersection s1 s2)))

  axiom sdiff_is_sdiff :
    forall s1:set.
     forall s2:set [symmetric_difference s1 s2].
      is_sdiff s1 s2 (symmetric_difference s1 s2)

  val symmetric_difference (co1:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (co2:set) :unit
     requires { let rec_co1 = {Graph__graphnode__set.__split_fields = co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   length_ (symmetric_difference rec_co1 co2) <= capacity rec_co1}
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphnode__set.__split_fields = co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphnode__set.__split_fields = old co1.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   rec_co1 = symmetric_difference old_co1 co2 }
end

module Graph__graphnode__symmetric_difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__symmetric_difference

  function symmetric_difference__2__logic set set : set

  axiom symmetric_difference__2__def :
     forall co1 co2 : set [symmetric_difference__2__logic co1 co2].
	  length_ (symmetric_difference co1 co2) <=
          Ada__containers__count_type.last ->
          symmetric_difference__2__logic co1 co2 = symmetric_difference co1 co2

  val symmetric_difference__2 (co1 co2 : set) : set
    requires { length_ (symmetric_difference co1 co2) <=
    Ada__containers__count_type.last }
    ensures { result = symmetric_difference co1 co2 /\ set_inv result }
end

module Graph__graphnode__is_subset
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__find

  function is_subset__logic set set : bool

  axiom is_subset__def :
    forall s1:set, s2:set [is_subset__logic s1 s2].
     is_subset__logic s1 s2 = True <->
      (forall i:real [find_ s1 i | find_ s2 i]. find_ s1 i = no_element -> find_ s2 i = no_element)

  val is_subset (co1 co2:set) : bool
     ensures { result = is_subset__logic co1 co2 }
end

module Graph__graphnode__overlap
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__node
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__cursor
  use import Graph__graphnode__no_element
  use import Graph__graphnode__find

  function overlap__logic set set : bool

  axiom overlap__def :
    forall s1:set, s2:set [overlap__logic s1 s2].
     overlap__logic s1 s2 <> True <->
      (forall i:real [find_ s1 i| find_ s2 i].
        find_ s1 i = no_element \/ find_ s2 i = no_element)

  val overlap (co1 co2:set) : bool
     ensures { result = overlap__logic co1 co2 }
end

module Graph__graphnode__capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Graph__graphnode__set
  use import Graph__graphnode__length

  function capacity__logic (co : set) : int = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  val capacity (co : set) : int
    ensures { result = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co)) }
end

module Graph__graphnode__reserve_capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set

  val reserve_capacity (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (c : int) : unit
    requires { Ada__containers__count_type.to_rep (cap.rec__capacity) >= c }
    ensures { co.Graph__graphnode__set.__split_fields__content = old co.Graph__graphnode__set.__split_fields__content }
end

module Graph__graphnode__equivalent_elements__2
  use Graph__node
  use import Graph__graphnode__witness
  use import Graph__graphnode__set
  use import Graph__graphnode__cursor
  use import Graph__graphnode__element

  function equivalent_elements__2__logic (co1:set) (e1:int) (co2:set) (e2:int) : bool =
  if witness e1 = witness e2 then True else False

 val equivalent_elements__2  (co1:set) (e1:int) (co2:set) (e2:int) : bool
	ensures {  result = equivalent_elements__2__logic co1 e1 co2 e2 }
end

module Graph__graphnode__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length

  val clear (co:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) : unit
     writes     { co }
     ensures { let rec_co = {Graph__graphnode__set.__split_fields = co.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   length_ rec_co = 0 }
end

module Graph__graphnode__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__Oeq__2

  val assign (target:Graph__graphnode__set.__split_fields__ref) (cap : Graph__graphnode__set.__split_discrs) (source:set) : unit
     requires { Ada__containers__count_type.to_rep (cap.rec__capacity) >= length_ source }
     writes     { target }
     reads      { target }
     ensures { let rec_t = {Graph__graphnode__set.__split_fields = target.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = cap}  in
                   oeq__2__logic rec_t source = True }
end

module Graph__graphnode__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__Oeq__2

  val move (target:Graph__graphnode__set.__split_fields__ref) (t_cap : Graph__graphnode__set.__split_discrs) (source:Graph__graphnode__set.__split_fields__ref) (s_cap : Graph__graphnode__set.__split_discrs) : unit
     requires { let rec_s = {Graph__graphnode__set.__split_fields = source.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = s_cap}  in
                   Ada__containers__count_type.to_rep (t_cap.rec__capacity) >= length_ rec_s }
     writes     { target, source }
     reads      { target, source }
     ensures { let rec_t = {Graph__graphnode__set.__split_fields = target.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = t_cap}  in
               let rec_s = {Graph__graphnode__set.__split_fields = source.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = s_cap}  in
               let old_s = {Graph__graphnode__set.__split_fields = old source.Graph__graphnode__set.__split_fields__content;
                              Graph__graphnode__set.__split_discrs = s_cap}  in
                   oeq__2__logic rec_t old_s = True /\ length_ rec_s = 0 }
end

module Graph__graphnode__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphnode__set
  use import Graph__graphnode__length
  use import Graph__graphnode__strict_equal

  function copy__logic set int : set

  axiom copy__def:
    forall co : set, cap : int [copy__logic co cap].
       strict_equal__logic co (copy__logic co cap) = True /\
       (cap = 0 -> capacity co = capacity (copy__logic co cap)) /\
       (cap >= capacity co ->  capacity (copy__logic co cap) = cap)

  val copy (co: set) (cap:int) : set
     requires { cap = 0 \/ cap >= capacity co}
     ensures { result = copy__logic co cap /\ set_inv result }
end


(* Module for defining the constant "left" defined at graph.ads:25, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphedge__Olt__left
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function left #"graph.ads" 25 0 0# 
   : Graph__edge.edge
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 8 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at graph.ads:25, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphedge__Olt__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "right" defined at graph.ads:25, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphedge__Olt__right
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function right #"graph.ads" 25 0 0# 
   : Graph__edge.edge
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 8 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at graph.ads:25, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphedge__Olt__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "A50s" defined at graph.ads:25, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphedge__Oeq__A50s
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function a50s #"graph.ads" 25 0 0# 
   : Graph__edge.edge
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 8 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "A50s" defined at graph.ads:25, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphedge__Oeq__A50s__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "B51s" defined at graph.ads:25, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__graphedge__Oeq__B51s
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function b51s #"graph.ads" 25 0 0# 
   : Graph__edge.edge
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 8 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "B51s" defined at graph.ads:25, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__graphedge__Oeq__B51s__axiom
 use import "_gnatprove_standard".Main


end

(* Module for declaring a why type for the formal "element_type" defined at a-cforse.ads:62, created in Gnat2Why.External_Axioms.Parse_Parameters *)
module Graph__graphedge__element_type
 use export Graph__edge
 use import "_gnatprove_standard".Main
 use        Graph__edge

 type element_type #"graph.ads" 8 0 0# =
  Graph__edge.edge
 
 function to_base #"graph.ads" 8 0 0# 
   (a : element_type) : element_type =
  a
 
 function of_base #"graph.ads" 8 0 0# 
   (a : element_type) : element_type =
  a

end

(* Module for declaring a logic function for the formal "Olt" defined at a-cforse.ads:64, created in Gnat2Why.External_Axioms.Parse_Parameters *)
module Graph__graphedge__Olt
 use        Graph__Olt
 use import "_gnatprove_standard".Main
 use        Graph__edge
 use        Graph__Olt

 function olt #"graph.ads" 8 0 0# "inline" 
   (ada__containers__formal_ordered_sets__Olt__left : Graph__edge.edge) (ada__containers__formal_ordered_sets__Olt__right : Graph__edge.edge) : bool =
  (Graph__Olt.olt ada__containers__formal_ordered_sets__Olt__left ada__containers__formal_ordered_sets__Olt__right)

end

(* Module for declaring a logic function for the formal "Oeq" defined at a-cforse.ads:65, created in Gnat2Why.External_Axioms.Parse_Parameters *)
module Graph__graphedge__Oeq
 use        Graph__edge
 use        Graph__edge
 use import "_gnatprove_standard".Main
 use        Graph__edge

 function oeq #"graph.ads" 17 0 0# "inline" 
   (ada__containers__formal_ordered_sets__Oeq__left : Graph__edge.edge) (ada__containers__formal_ordered_sets__Oeq__right : Graph__edge.edge) : bool =
  (Graph__edge.bool_eq ada__containers__formal_ordered_sets__Oeq__left ada__containers__formal_ordered_sets__Oeq__right)

end


module Graph__graphedge__witness
  use import real.Real
  use Graph__edge
  use Graph__graphedge__Olt

  function witness Graph__edge.edge : real

  axiom olt_witness :
    (forall k1  k2 : Graph__edge.edge [Graph__graphedge__Olt.olt k1 k2].
	Real.(<) (witness k1) (witness k2) <-> Graph__graphedge__Olt.olt k1 k2 = True)
end

module Graph__graphedge__set
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__hash_type
  use Ada__containers__count_type

  type __split_discrs = {rec__capacity : Ada__containers__count_type.count_type}

  type __split_discrs__ref = { mutable __split_discrs__content : __split_discrs }
  val __split_discrs__havoc (x : __split_discrs__ref) : unit
     writes { x }

  type __split_fields = { rec__main__ : __private }

  type __split_fields__ref = { mutable __split_fields__content : __split_fields }
  val __split_fields__havoc (x : __split_fields__ref) : unit
     writes { x }

  type set = { __split_discrs : __split_discrs; __split_fields : __split_fields }

  type set__ref = { mutable set__content : set }
  val set__havoc (x : set__ref) : unit
     writes { x }

  predicate set_inv "inline" (l : set) =
     l = { __split_discrs = { rec__capacity = l.__split_discrs.rec__capacity }; __split_fields = { rec__main__ = l.__split_fields.rec__main__ } }

   function capacity  (co : set) : int =
          Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  function bool_eq set set : bool
  function user_eq set set : bool
end

module Graph__graphedge__length
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Graph__graphedge__set

  function length__logic set : int

  function length_ "inline" (co : set) : int =
    length__logic co

  axiom length_range:
    forall co:set [length__logic co]. 0 <= length_ co <= capacity co

  val length (co : set) : int
     ensures { result = length__logic co }
end

module Graph__graphedge__cursor
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__length

  type __split_fields = { rec__main__ : __private }

  type __split_fields__ref = { mutable __split_fields__content : __split_fields }
  val __split_fields__havoc (x : __split_fields__ref) : unit
     writes { x }

  type cursor = { __split_fields : __split_fields }

  type cursor__ref = { mutable cursor__content : cursor }
  val cursor__havoc (x : cursor__ref) : unit
     writes { x }

  function dummy : cursor

  function position set cursor : int

  function position_inv set int : cursor

  axiom position_gte_zero:
    forall co:set, cu:cursor [position co cu].
        length_ co >= position co cu >= 0

  axiom position_eq1:
   forall co:set, i :int [position co (position_inv co i)]. 0 < i <= length_ co ->
              position co (position_inv co i) = i

  axiom position_eq2:
    forall co:set, cu:cursor [position co cu].
          position co cu > 0 -> position_inv co (position co cu) = cu

  function bool_eq "inline" (c1:cursor) (c2:cursor) : bool = c1 = c2
  function user_eq cursor cursor : bool
end

module Graph__graphedge__no_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor

  function no_element : cursor

  axiom position_no_element:
    forall co:set [position co no_element]. position co no_element = 0
end

module Graph__graphedge__empty_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length

  function empty_set : set

  axiom Empty_is_empty: length_ empty_set = 0
end

module Graph__graphedge__is_empty
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length

  function is_empty__logic set : bool

  axiom is_empty:
    forall co:set [is_empty__logic (co)].
          is_empty__logic (co) = True <-> length_ co = 0

  val is_empty (co:set) : bool
     ensures  { result = is_empty__logic co }
end

module Graph__graphedge__element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor

  function element__logic set cursor : Graph__edge.edge

  axiom element__range:
   forall co:set, cu:cursor. __ignore (element__logic co cu)

  axiom ordered:
    forall s:set, cu1 cu2:cursor [element__logic s cu2, element__logic s cu1].
       position s cu1 > 0 -> position s cu2 > 0 ->
         (position s cu1 > position s cu2 <-> Real.(>) (witness (element__logic s cu1)) (witness (element__logic s cu2)))

  val element (co:set) (cu:cursor) : Graph__edge.edge
     requires { position co cu > 0 }
     ensures  { result = element__logic co cu }
end

module Graph__graphedge__previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element

  function previous__logic set cursor : cursor

  axiom previous_in:
    forall co:set, cu:cursor [previous__logic co cu].
	(position co cu > 1 \/ position co (previous__logic co cu) > 0) ->
	position co (previous__logic co cu) = position co cu - 1

  axiom previous_ext:
    forall co:set, cu:cursor [previous__logic co cu].
        (position co cu = 1 \/ cu = no_element) -> previous__logic co cu = no_element

  val previous (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = previous__logic co cu }
end

module Graph__graphedge__previous__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__previous

  val previous__2 (co:set) (cu:cursor__ref) : unit
     requires { cu.cursor__content = no_element \/ position co cu.cursor__content > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { cu.cursor__content = previous__logic co (old cu.cursor__content) }
end

module Graph__graphedge__next
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element

  function next__logic set cursor : cursor

  axiom next_in:
    forall co:set, cu:cursor [next__logic co cu].
	(length_ co > position co cu > 0 \/ position co (next__logic co cu) > 0) ->
	position co (next__logic co cu) = position co cu + 1

  axiom next_ext:
    forall co:set, cu:cursor [next__logic co cu].
        (position co cu = length_ co \/ cu = no_element) -> next__logic co cu = no_element

  val next (co:set) (cu:cursor) : cursor
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = next__logic co cu }
end

module Graph__graphedge__next__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__next

  val next__2 (co:set) (cu:cursor__ref) : unit
     requires { cu.cursor__content = no_element \/ position co cu.cursor__content > 0 }
     writes     { cu }
     reads      { cu }
     ensures  { cu.cursor__content = next__logic co (old cu.cursor__content) }
end

module Graph__graphedge__last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element

  function last__logic set : cursor

  axiom last_empty:
    forall co:set [last__logic co]. length_ co = 0 <-> last__logic co = no_element

  axiom last_gen:
    forall co:set [last__logic co]. length_ co = position co (last__logic co)

  val last (co:set) : cursor
     ensures  { result = last__logic co }
end

module Graph__graphedge__first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element

  function first__logic set : cursor

  axiom first_empty:
    forall co:set [first__logic co]. length_ co = 0 <-> first__logic co = no_element

  axiom first_gen:
    forall co:set [first__logic co]. length_ co > 0 -> position co (first__logic co) = 1

  val first (co:set) : cursor
     ensures  { result = first__logic co }
end

module Graph__graphedge__first_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__first
  use import Graph__graphedge__element

  function first_element__logic (co:set) : Graph__edge.edge = element__logic co (first__logic co)

  val first_element (co:set) : Graph__edge.edge
     requires { length_ co > 0 }
     ensures  { result = element__logic co (first__logic co) }
end

module Graph__graphedge__last_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__last
  use import Graph__graphedge__element

  function last_element__logic (co:set) : Graph__edge.edge = element__logic co (last__logic co)

  val last_element (co:set) : Graph__edge.edge
     requires { length_ co > 0 }
     ensures  { result = element__logic co (last__logic co) }
end

module Graph__graphedge__find
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__witness
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__element

  function find_ set real : cursor

  predicate find__ (co : set) (i : real) (cu : cursor) =
    (cu = (no_element  : cursor) /\
      (forall cun:cursor.
        position co cun >  0 ->
         witness (element__logic co cun) <> i)) \/
     (position co cu > 0 /\
      witness (element__logic co cu) = i)

  axiom Find_find_val:
    (forall co:set.
      (forall i:real.
        ((find__ co i (find_ co i)) /\
         ((length_ co = 0) -> (find_ co i = no_element )))))

  function find__logic "inline" (co : set) (e:Graph__edge.edge) : cursor =
  find_ co (witness e)

  val find (co:set) (e:Graph__edge.edge)  : cursor
     ensures  { result = find__logic co e }
end

module Graph__graphedge__ceiling
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__witness
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__last
  use import Graph__graphedge__element

  function ceiling_ set real : cursor

  predicate is_ceiling (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
        Real.(>) i (witness (element__logic s (last__logic s))))) \/
      (position s cu > 0 /\
       Real.(<=) i (witness (element__logic s cu)) /\
	(forall cun : cursor [element__logic s cun]. 0 < position s cun < position s cu
	 -> Real.(>) i (witness (element__logic s cun))))

  axiom ceiling_is_ceiling:
    forall s:set.
      forall i:real [(ceiling_ s i : cursor)].
        is_ceiling s i (ceiling_ s i : cursor)

  function ceiling__logic  "inline" (co:set) (e:Graph__edge.edge) : cursor =
 ceiling_ co (witness e)

  val ceiling (co:set) (e:Graph__edge.edge) :cursor
     ensures { result = ceiling_ co (witness e) }
end

module Graph__graphedge__floor
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__witness
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__first
  use import Graph__graphedge__element

  function floor_ set real : cursor

  predicate is_floor (s : set) (i : real) (cu : cursor) =
     (cu = no_element  /\
       (length_ s = 0 \/ length_ s > 0 /\
         Real.(<) i (witness (element__logic s (first__logic s))))) \/
      (position s cu > 0 /\
       Real.(>=) i (witness (element__logic s cu)) /\
	(forall cun : cursor. position s cu < position s cun
	 ->  Real.(<) i (witness (element__logic s cun))))

  axiom floor_is_floor:
    (forall s:set.
      (forall i:real [(floor_ s i : cursor)].
        (is_floor s i (floor_ s i : cursor))))

  function floor__logic  "inline" (co:set) (e:Graph__edge.edge) : cursor =
 floor_ co (witness e)

  val floor (co:set) (e:Graph__edge.edge) :cursor
     ensures { result = floor_ co (witness e) }
end

module Graph__graphedge__first_to_previous
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__element
  use import Graph__graphedge__find

  function first_to_previous__logic set cursor : set

  axiom first_to_previous_no_element:
    forall co:set [first_to_previous__logic co no_element]. first_to_previous__logic co no_element = co

  axiom first_to_previous_length_:
    forall co:set, cu:cursor [first_to_previous__logic co cu].
	position co cu > 0 -> length_ (first_to_previous__logic co cu) = position co cu - 1

  axiom first_to_previous_position_in:
    forall co:set, cu cun:cursor [position (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, position co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ position co cun < position co cu) ->
	position (first_to_previous__logic co cu) cun = position co cun

  axiom first_to_previous_position_ext:
    forall co:set, cu cun:cursor [position (first_to_previous__logic co cu) cun].
	position co cun >= position co cu > 0 ->
	position (first_to_previous__logic co cu) cun = 0

  axiom first_to_previous_element:
    forall co:set, cu cun:cursor [element__logic (first_to_previous__logic co cu) cun | first_to_previous__logic co cu, element__logic co cun].
	(position (first_to_previous__logic co cu) cun > 0 \/ 0 < position co cun < position co cu) ->
	element__logic (first_to_previous__logic co cu) cun = element__logic co cun

  axiom first_to_previous_find :
    forall co:set, cu:cursor, w:real [find_ co w, first_to_previous__logic co cu|
     find_ (first_to_previous__logic co cu) w].
     ((position co cu > position co (find_ co w) > 0 \/
      position (first_to_previous__logic co cu) (find_ (first_to_previous__logic co cu) w) > 0) ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
      (position co (find_ co w) >= position co cu -> find_ (first_to_previous__logic co cu) w = no_element)

  axiom first_to_previous_find_elt :
    forall co:set, cu:cursor, w:real [element__logic co cu, find_ co w, first_to_previous__logic co cu|
     element__logic co cu, find_ (first_to_previous__logic co cu) w].
     (Real.(>) (witness (element__logic co cu)) w  ->
      find_ co w = find_ (first_to_previous__logic co cu) w) /\
     (Real.(<=) (witness (element__logic co cu)) w  ->
      find_ (first_to_previous__logic co cu) w = no_element)

  val first_to_previous (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = first_to_previous__logic co cu /\ set_inv result }
end

module Graph__graphedge__current_to_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__empty_set
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__element
  use import Graph__graphedge__find

  function current_to_last__logic set cursor : set

  axiom current_to_last_no_element:
    forall co:set [current_to_last__logic co no_element]. current_to_last__logic co no_element = empty_set

  axiom current_to_last_length_:
    forall co:set, cu:cursor [length_ (current_to_last__logic co cu) ].
	position co cu > 0 -> length_ (current_to_last__logic co cu) = (length_ co) - (position co cu) + 1

  axiom current_to_last_position_in:
    forall co:set, cu cun:cursor [position (current_to_last__logic co cu) cun | current_to_last__logic co cu, position co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ position co cun >= position co cu > 0) ->
	position (current_to_last__logic co cu) cun = (position co cun) - (position co cu) + 1

  axiom current_to_last_position_ext:
    forall co:set, cu cun:cursor [position (current_to_last__logic co cu) cun].
	position co cun < position co cu -> position (current_to_last__logic co cu) cun = 0

  axiom current_to_last_element:
    forall co:set, cu cun:cursor [element__logic (current_to_last__logic co cu) cun | current_to_last__logic co cu, element__logic co cun].
	(position (current_to_last__logic co cu) cun > 0 \/ 0 < position co cu <= position co cun) ->
	element__logic (current_to_last__logic co cu) cun = element__logic co cun

  axiom current_to_last_find :
    forall co:set, cu:cursor, w:real [find_ (current_to_last__logic co cu) w| current_to_last__logic co cu,
     find_ co w].
     ((0 < position co cu <= position co (find_ co w) \/
      position (current_to_last__logic co cu) (find_ (current_to_last__logic co cu) w) > 0) ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
      (position co (find_ co w) < position co cu -> find_ (current_to_last__logic co cu) w = no_element)

  axiom current_to_last_find_elt :
    forall co:set, cu:cursor, w:real [element__logic co cu, find_ co w, current_to_last__logic co cu|
     element__logic co cu, find_ (current_to_last__logic co cu) w].
     (Real.(<=) (witness (element__logic co cu)) w  ->
      find_ co w = find_ (current_to_last__logic co cu) w) /\
     (Real.(>) (witness (element__logic co cu)) w  ->
      find_ (current_to_last__logic co cu) w = no_element)

  val current_to_last (co:set) (cu:cursor) : set
     requires { cu = no_element \/ position co cu > 0 }
     ensures  { result = current_to_last__logic co cu /\ set_inv result }
end

module Graph__graphedge__replace
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use Graph__graphedge__Oeq
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__empty_set
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__element
  use import Graph__graphedge__find

  predicate replace (co1:set) (e:Graph__edge.edge) (co2:set) =
    (position co1 (find_ co1 (witness e)) > 0 /\
      length_ co1 = length_ co2 /\
       Graph__graphedge__Oeq.oeq (element__logic co2 (find_ co1 (witness e))) e /\
        (forall cun:cursor [position co2 cun | position co1 cun]. position co2 cun = position co1 cun) /\
         (forall cun:cursor [element__logic co2 cun | element__logic co1 cun].
           position co1 cun > 0 /\ not cun = find_ co1 (witness e) ->
            element__logic co2 cun = element__logic co1 cun) /\
          (forall w:real [find_ co1 w | find_ co2 w]. find_ co1 w = find_ co2 w)) /\
     capacity co1 = capacity co2

  val replace (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (e:Graph__edge.edge) : unit
     requires { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes { co }
     reads { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   replace old_co e rec_co }
end

module Graph__graphedge__replace_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use Graph__graphedge__Oeq
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__element
  use import Graph__graphedge__find

  predicate replace_element set cursor Graph__edge.edge set

  axiom replace_element_length_:
    forall co1 co2:set, cu:cursor, e:Graph__edge.edge
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> length_ co1 = length_ co2

  axiom replace_element_capacity:
    forall co1 co2:set, cu:cursor, e:Graph__edge.edge
      [replace_element co1 cu e co2, capacity co1|replace_element co1 cu e co2, capacity co2].
      replace_element co1 cu e co2 -> capacity co1 = capacity co2

  axiom replace_element_position:
    forall co1 co2:set, cu cun:cursor, e:Graph__edge.edge
      [replace_element co1 cu e co2, position co2 cun
     | replace_element co1 cu e co2, position co1 cun].
      replace_element co1 cu e co2 -> (position co2 cun > 0 <-> position co1 cun > 0)

  axiom replace_element_element_in:
    forall co1 co2:set, cu:cursor, e:Graph__edge.edge
      [replace_element co1 cu e co2].
      replace_element co1 cu e co2 -> Graph__graphedge__Oeq.oeq (element__logic co2 cu) e /\ find_ co2 (witness  e) = cu

  axiom replace_element_element_ext:
    forall co1 co2:set, cu cun:cursor, e:Graph__edge.edge
      [replace_element co1 cu e co2, element__logic co2 cun
     | replace_element co1 cu e co2, element__logic co1 cun].
      replace_element co1 cu e co2 -> cu <> cun -> position co1 cun > 0 ->
        element__logic co2 cun = element__logic co1 cun

  axiom replace_element_find:
    forall co1 co2:set, cu:cursor, w:real, e:Graph__edge.edge
      [replace_element co1 cu e co2, find_ co2 w
     | replace_element co1 cu e co2, find_ co1 w].
       replace_element co1 cu e co2 -> not witness e = w ->
       find_ co1 w = find_ co2 w

  val replace_element (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (cu:cursor) (e:Graph__edge.edge) : unit
     requires { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   position rec_co cu > 0 /\ (find_ rec_co (witness e) = no_element \/ find_ rec_co (witness e) = cu) }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   replace_element old_co cu e rec_co }
end

module Graph__graphedge__insert
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use Graph__graphedge__Oeq
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__last
  use import Graph__graphedge__element
  use import Graph__graphedge__find
  use import Graph__graphedge__ceiling

  predicate insert set Graph__edge.edge set

  axiom insert_length_:
    forall co1 co2:set,  e:Graph__edge.edge
      [insert co1 e co2].
      insert co1 e co2 -> length_ co1 + 1 = length_ co2 /\ find_ co1 (witness e) = no_element /\ Graph__graphedge__Oeq.oeq (element__logic co2 (find_ co2 (witness e))) e

  axiom insert_capacity:
    forall co1 co2:set, e:Graph__edge.edge
      [insert co1 e co2, capacity co1|insert co1 e co2, capacity co2].
      insert co1 e co2 -> capacity co1 = capacity co2

  axiom insert_new:
    forall co1 co2:set, e:Graph__edge.edge [insert co1 e co2].
      insert co1 e co2 -> (ceiling_ co1 (witness e) <> no_element ->
      position co2 (find_ co2 (witness e)) = position co1 (ceiling_ co1 (witness e))) /\ (ceiling_ co1 (witness e) = no_element ->
      find_ co2 (witness e) = last__logic co2)

  axiom insert_position_before:
    forall co1 co2:set, cun:cursor, e:Graph__edge.edge
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (i > position co1 cun > 0 \/ position co2 cun < i) ->
        position co1 cun = position co2 cun

  axiom insert_position_after:
    forall co1 co2:set, cun:cursor, e:Graph__edge.edge
      [insert co1 e co2,  position co1 cun
     | insert co1 e co2,  position co2 cun].
    let i = position co2 (find_ co2 (witness e)) in
      insert co1 e co2 ->
      (position co1 cun >= i \/ position co2 cun > i) ->
        position co1 cun + 1 = position co2 cun

  axiom insert_element:
    forall co1 co2:set, cun:cursor, e:Graph__edge.edge
      [insert co1 e co2,  element__logic co1 cun
     | insert co1 e co2,  element__logic co2 cun].
      insert co1 e co2 ->
      (position co1 cun > 0 \/ position co2 cun > 0 /\ find_ co2 (witness e) <> cun) ->
        element__logic co1 cun = element__logic co2 cun

  axiom insert_find :
    forall co1:set, co2:set, w:real, e:Graph__edge.edge
     [insert co1 e co2, find_ co1 w| insert co1 e co2, find_ co2 w].
     insert co1 e co2 -> not witness e = w -> find_ co1 w = find_ co2 w

  val insert (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (e:Graph__edge.edge)  (p:cursor__ref) (inserted : bool__ref) : unit
     requires { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co }
     writes     { co, p, inserted }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   (inserted.bool__content = True <-> find_ old_co (witness e) = no_element) /\ p.cursor__content = find_ rec_co (witness e) /\
                          if inserted.bool__content = True then (insert old_co e rec_co)
                                                                 else (co.Graph__graphedge__set.__split_fields__content = old co.Graph__graphedge__set.__split_fields__content) }
end

module Graph__graphedge__insert__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__insert
  use import Graph__graphedge__find

  val insert__2 (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (e:Graph__edge.edge) : unit
     requires { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   length_ rec_co < capacity rec_co /\ find_ rec_co (witness e) = no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   insert old_co e rec_co }
end

module Graph__graphedge__delete
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__next
  use import Graph__graphedge__element
  use import Graph__graphedge__find

  predicate delete set cursor set

  axiom delete_capacity:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2, capacity co1|delete co1 cu co2, capacity co2].
      delete co1 cu co2 -> capacity co1 = capacity co2

  axiom delete_length_:
    forall co1 co2:set, cu:cursor
      [delete co1 cu co2].
      delete co1 cu co2 -> length_ co1 = length_ co2 + 1

  axiom delete_position_before:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun
     | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cu > position co1 cun \/ 0 < position co2 cun < position co1 cu) ->
        position co1 cun = position co2 cun

  axiom delete_position_after:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  position co1 cun | delete co1 cu co2,  position co2 cun].
      delete co1 cu co2 ->
      (position co1 cun > position co1 cu \/ position co2 cun >= position co1 cu) ->
        position co1 cun = position co2 cun + 1

  axiom delete_position_range:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co2 cu = 0 /\ 0 < position co1 cu /\ find_ co2 (witness (element__logic co1 cu)) = no_element

  axiom delete_position_next:
    forall co1 co2:set, cu:cursor [delete co1 cu co2].
      delete co1 cu co2 -> position co1 (next__logic co1 cu) >= 0

  axiom delete_element:
    forall co1 co2:set, cu cun:cursor
      [delete co1 cu co2,  element__logic co1 cun
     | delete co1 cu co2,  element__logic co2 cun].
      delete co1 cu co2 ->
      0 < position co2 cun ->
        element__logic co1 cun = element__logic co2 cun

  axiom delete_find :
    forall co1:set, co2:set, cu:cursor, w:real [delete co1 cu co2,
     find_ co1 w| delete co1 cu co2, find_ co2 w].
     delete co1 cu co2 -> not witness (element__logic co1 cu) = w -> find_ co1 w = find_ co2 w

  val delete (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (e : Graph__edge.edge) : unit
     requires { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   find_ rec_co (witness e) <> no_element }
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   delete old_co (find_ old_co (witness e)) rec_co }
end

module Graph__graphedge__delete__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__delete

  val delete__2 (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (cu:cursor__ref) : unit
     requires { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   position rec_co cu.cursor__content > 0 }
     writes     { co, cu }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   delete old_co (old cu.cursor__content) rec_co /\ cu.cursor__content = no_element}
 end

module Graph__graphedge__delete_first
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__first
  use import Graph__graphedge__delete

  val delete__first (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   if length_ old_co = 0 then co.Graph__graphedge__set.__split_fields__content = (old co.Graph__graphedge__set.__split_fields__content) else delete old_co (first__logic old_co) rec_co }
 end

module Graph__graphedge__delete_last
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__last
  use import Graph__graphedge__delete

  val delete__last (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   if length_ old_co = 0 then co.Graph__graphedge__set.__split_fields__content = (old co.Graph__graphedge__set.__split_fields__content) else delete old_co (last__logic old_co) rec_co }
 end

module Graph__graphedge__include
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__replace
  use import Graph__graphedge__insert
  use import Graph__graphedge__find

  val include (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (e :Graph__edge.edge) : unit
     requires { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   length_ rec_co  < capacity rec_co}
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   if find_ old_co (witness e) <> no_element then replace old_co e rec_co
                         else insert old_co e rec_co  }
end

module Graph__graphedge__exclude
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__delete
  use import Graph__graphedge__find

  val exclude (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (e :Graph__edge.edge) : unit
     writes     { co }
     reads      { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co = {Graph__graphedge__set.__split_fields = old co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   if find_ old_co (witness e) = no_element then  old co.Graph__graphedge__set.__split_fields__content = co.Graph__graphedge__set.__split_fields__content
                         else delete old_co (find_ old_co (witness e)) rec_co  }
end

module Graph__graphedge__to_set
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use Graph__graphedge__Oeq
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__first
  use import Graph__graphedge__element

  function to_set__logic Graph__edge.edge : set

  axiom to_set__def:
  forall e : Graph__edge.edge [to_set__logic e].
    length_ (to_set__logic e) = 1 /\ Graph__graphedge__Oeq.oeq (element__logic (to_set__logic e) (first__logic (to_set__logic e))) e

 val  to_set  (e: Graph__edge.edge) : set
     ensures { result = to_set__logic e /\ set_inv result }
end

module Graph__graphedge__has_element
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor

  function has_element__logic set cursor : bool

  axiom has_element_pos:
    forall co:set, cu:cursor [has_element__logic co cu].
    has_element__logic co cu = True -> 0 < position co cu

  axiom has_element_neg:
    forall co:set, cu:cursor [has_element__logic co cu].
    has_element__logic co cu <> True -> position co cu = 0

  val has_element (co:set) (cu:cursor) : bool
     ensures { has_element__logic co cu = result }
end

module Graph__graphedge__contains
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__find

  function contains__logic set Graph__edge.edge : bool

  axiom contains_c:
  forall co : set, e : Graph__edge.edge [contains__logic co e].
    contains__logic co e = True <-> 0 < position co (find_ co (witness e))

  val contains (co:set) (e:Graph__edge.edge) : bool
     ensures { contains__logic co e = result }
end

module Graph__graphedge__strict_equal
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__element

  function strict_equal__logic set set : bool

  axiom strict_equal__def:
    forall co1 co2 : set [strict_equal__logic co1 co2].
    ((forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu > 0 <-> position co2 cu > 0) /\
     (forall cu:cursor [element__logic co1 cu | element__logic co2 cu]. position co1 cu > 0 ->
        element__logic co1 cu = element__logic co2 cu)) <->  strict_equal__logic co1 co2 = True

  axiom strict_equal__pos:
    forall co1 co2 : set [strict_equal__logic co1 co2].
    strict_equal__logic co1 co2 = True -> (forall cu:cursor [position co1 cu | position co2 cu].
       position co1 cu = position co2 cu)

  axiom strict_equal_length_:
    forall co1 co2 : set [strict_equal__logic co1 co2].
     strict_equal__logic co1 co2 = True -> length_ co1 = length_ co2

    val strict_equal (co1:set) (co2:set) : bool
     ensures  { result  = strict_equal__logic co1 co2 }
end

module Graph__graphedge__Oeq__2
  use import int.Int
  use Graph__edge
  use Graph__graphedge__Oeq
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__element
  use import Graph__graphedge__find

  function oeq__2__logic set set : bool

  axiom oeq__2_length_:
   forall co1 co2 : set [oeq__2__logic co1 co2].
   oeq__2__logic co1 co2 = True -> length_ co1 = length_ co2

  axiom oeq__2_element:
   forall co1 co2 : set [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 = True ->
   forall cu1 : cursor [element__logic co1 cu1]. position co1 cu1 > 0 ->
	let cu2 = find_ co2 (witness (element__logic co1 cu1)) in
          position co2 cu2 > 0 /\
          Graph__graphedge__Oeq.oeq (element__logic co2 cu2) (element__logic co1 cu1) = True

  axiom oeq__2_inv:
   forall co1 co2 : set [oeq__2__logic co1 co2]. oeq__2__logic co1 co2 <> True ->
   (length_ co1 <> length_ co2 \/
   exists e : real. position co1 (find_ co1 e) > 0 /\
         (find_ co2 e = no_element \/ position co2 (find_ co2 e) > 0 /\
          Graph__graphedge__Oeq.oeq (element__logic co2 (find_ co2 e)) (element__logic co1 (find_ co1 e)) <> True))

  axiom oeq__2_sym :
  forall e1 e2 : set [oeq__2__logic e1 e2].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e1 = True

  axiom oeq__2_trans :
  forall e1 e2 e3 : set [oeq__2__logic e1 e2, oeq__2__logic e1 e3 | oeq__2__logic e1 e2, oeq__2__logic e2 e3].
	oeq__2__logic e1 e2 = True -> oeq__2__logic e2 e3 = True -> oeq__2__logic e1 e3 = True

  val oeq__2 (co1:set) (co2:set) : bool
     ensures  { result  = oeq__2__logic co1 co2 }
end

module Graph__graphedge__equivalent_sets
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__find

  function equivalent_sets__logic set set : bool

  axiom equivalent_sets__def :
    forall co1:set, co2:set [equivalent_sets__logic co1 co2].
     (forall i:real.
       not find_ co1 i = no_element -> not find_ co2 i = no_element) /\
      length_ co1 = length_ co2 <-> equivalent_sets__logic co1 co2 = True

  axiom equivalent_sym :
    forall co1:set.
     forall co2:set [equivalent_sets__logic co2 co1| equivalent_sets__logic co1 co2].
      equivalent_sets__logic co1 co2 = True -> equivalent_sets__logic co2 co1 = True

  val equivalent_sets (co1:set) (co2:set) : bool
  ensures { result  = equivalent_sets__logic co1 co2 }
end

module Graph__graphedge__intersection
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__find

  function intersection set set : set

  predicate is_inter (s1:set) (s2:set) (i:set) =
    forall j:real [find_ s1 j, find_ s2 j| find_ i j].
     (not find_ s1 j = no_element /\ not find_ s2 j = no_element ->
       not find_ i j = no_element) /\
      (find_ s1 j = no_element \/ find_ s2 j = no_element ->
        find_ i j = no_element)

  axiom Inter_is_inter :
    forall s1:set.
     forall s2:set [intersection s1 s2].
      is_inter s1 s2 (intersection s1 s2) /\
       length_ (intersection s1 s2) = length_ (intersection s2 s1)

  val intersection (co1:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphedge__set.__split_fields = co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphedge__set.__split_fields = old co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   rec_co1 = intersection old_co1 co2 }
end

module Graph__graphedge__intersection__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__intersection

  function intersection__2__logic "inline" (co1 co2 : set) : set = intersection co1 co2

  val intersection__2 (co1 co2 : set) : set
    ensures { result = intersection co1 co2 /\ set_inv result }
end

module Graph__graphedge__union
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__find
  use import Graph__graphedge__intersection

  function union set set : set

  predicate is_union (s1:set) (s2:set) (u:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ u i].
      (not find_ s1 i = no_element \/ not find_ s2 i = no_element ->
        not find_ u i = no_element) /\
       (find_ s1 i = no_element /\ find_ s2 i = no_element ->
         find_ u i = no_element)) /\
     length_ u = ((length_ s1 + length_ s2) - length_ (intersection s1 s2))

  axiom union_is_union :
    forall s1:set. forall s2:set [union s1 s2]. is_union s1 s2 (union s1 s2)

  val union (co1:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs)(co2:set) :unit
     requires { let rec_co1 = {Graph__graphedge__set.__split_fields = co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   length_ (union rec_co1 co2) <= capacity rec_co1}
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphedge__set.__split_fields = co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphedge__set.__split_fields = old co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   rec_co1 = union old_co1 co2 }
end

module Graph__graphedge__union__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__union

  function union__2__logic set set : set

  axiom union__2__def :
     forall co1 co2 : set [union__2__logic co1 co2].
	  length_ (union co1 co2) <=  Ada__containers__count_type.last ->
          union__2__logic co1 co2 = union co1 co2

  val union__2 (co1 co2 : set) : set
    requires { length_ (union co1 co2) <=  Ada__containers__count_type.last }
    ensures { result = union co1 co2 /\ set_inv result }
end

module Graph__graphedge__difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__find
  use import Graph__graphedge__intersection

  function difference set set : set

  predicate is_diff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (find_ s1 i = no_element \/ not find_ s2 i = no_element ->
         find_ d i = no_element)) /\
     length_ d = (length_ s1 - length_ (intersection s1 s2))

  axiom diff_is_diff :
    forall s1:set.
     forall s2:set [difference s1 s2]. is_diff s1 s2 (difference s1 s2)

  val difference (co1:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (co2:set) :unit
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphedge__set.__split_fields = co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphedge__set.__split_fields = old co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   rec_co1 = difference old_co1 co2 }
end

module Graph__graphedge__difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__difference

  function difference__2__logic "inline" (co1 co2 : set) : set = difference co1 co2

  val difference__2 (co1 co2 : set) : set
    ensures { result = difference co1 co2 /\ set_inv result }
end

module Graph__graphedge__symmetric_difference
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__find
  use import Graph__graphedge__intersection

  function symmetric_difference set set : set

  predicate is_sdiff (s1:set) (s2:set) (d:set) =
    (forall i:real [find_ s1 i, find_ s2 i| find_ d i].
      (not find_ s1 i = no_element /\ find_ s2 i = no_element ->
        not find_ d i = no_element) /\
       (not find_ s2 i = no_element /\ find_ s1 i = no_element ->
         not find_ d i = no_element) /\
        (find_ s2 i = no_element /\ find_ s1 i = no_element ->
          find_ d i = no_element) /\
         (not find_ s2 i = no_element /\ not find_ s1 i = no_element ->
           find_ d i = no_element)) /\
     length_ d =
      ((length_ s1 + length_ s2) - (2 * length_ (intersection s1 s2)))

  axiom sdiff_is_sdiff :
    forall s1:set.
     forall s2:set [symmetric_difference s1 s2].
      is_sdiff s1 s2 (symmetric_difference s1 s2)

  val symmetric_difference (co1:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (co2:set) :unit
     requires { let rec_co1 = {Graph__graphedge__set.__split_fields = co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   length_ (symmetric_difference rec_co1 co2) <= capacity rec_co1}
     reads { co1 }
     writes { co1 }
     ensures { let rec_co1 = {Graph__graphedge__set.__split_fields = co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
               let old_co1 = {Graph__graphedge__set.__split_fields = old co1.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   rec_co1 = symmetric_difference old_co1 co2 }
end

module Graph__graphedge__symmetric_difference__2
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__symmetric_difference

  function symmetric_difference__2__logic set set : set

  axiom symmetric_difference__2__def :
     forall co1 co2 : set [symmetric_difference__2__logic co1 co2].
	  length_ (symmetric_difference co1 co2) <=
          Ada__containers__count_type.last ->
          symmetric_difference__2__logic co1 co2 = symmetric_difference co1 co2

  val symmetric_difference__2 (co1 co2 : set) : set
    requires { length_ (symmetric_difference co1 co2) <=
    Ada__containers__count_type.last }
    ensures { result = symmetric_difference co1 co2 /\ set_inv result }
end

module Graph__graphedge__is_subset
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__find

  function is_subset__logic set set : bool

  axiom is_subset__def :
    forall s1:set, s2:set [is_subset__logic s1 s2].
     is_subset__logic s1 s2 = True <->
      (forall i:real [find_ s1 i | find_ s2 i]. find_ s1 i = no_element -> find_ s2 i = no_element)

  val is_subset (co1 co2:set) : bool
     ensures { result = is_subset__logic co1 co2 }
end

module Graph__graphedge__overlap
  use import int.Int
  use import "_gnatprove_standard".Main
  use Graph__edge
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__cursor
  use import Graph__graphedge__no_element
  use import Graph__graphedge__find

  function overlap__logic set set : bool

  axiom overlap__def :
    forall s1:set, s2:set [overlap__logic s1 s2].
     overlap__logic s1 s2 <> True <->
      (forall i:real [find_ s1 i| find_ s2 i].
        find_ s1 i = no_element \/ find_ s2 i = no_element)

  val overlap (co1 co2:set) : bool
     ensures { result = overlap__logic co1 co2 }
end

module Graph__graphedge__capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use Ada__containers__count_type
  use import Graph__graphedge__set
  use import Graph__graphedge__length

  function capacity__logic (co : set) : int = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co))

  val capacity (co : set) : int
    ensures { result = Ada__containers__count_type.to_rep (rec__capacity (__split_discrs co)) }
end

module Graph__graphedge__reserve_capacity
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set

  val reserve_capacity (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (c : int) : unit
    requires { Ada__containers__count_type.to_rep (cap.rec__capacity) >= c }
    ensures { co.Graph__graphedge__set.__split_fields__content = old co.Graph__graphedge__set.__split_fields__content }
end

module Graph__graphedge__equivalent_elements__2
  use Graph__edge
  use import Graph__graphedge__witness
  use import Graph__graphedge__set
  use import Graph__graphedge__cursor
  use import Graph__graphedge__element

  function equivalent_elements__2__logic (co1:set) (e1:Graph__edge.edge) (co2:set) (e2:Graph__edge.edge) : bool =
  if witness e1 = witness e2 then True else False

 val equivalent_elements__2  (co1:set) (e1:Graph__edge.edge) (co2:set) (e2:Graph__edge.edge) : bool
	ensures {  result = equivalent_elements__2__logic co1 e1 co2 e2 }
end

module Graph__graphedge__clear
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length

  val clear (co:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) : unit
     writes     { co }
     ensures { let rec_co = {Graph__graphedge__set.__split_fields = co.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   length_ rec_co = 0 }
end

module Graph__graphedge__assign
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__Oeq__2

  val assign (target:Graph__graphedge__set.__split_fields__ref) (cap : Graph__graphedge__set.__split_discrs) (source:set) : unit
     requires { Ada__containers__count_type.to_rep (cap.rec__capacity) >= length_ source }
     writes     { target }
     reads      { target }
     ensures { let rec_t = {Graph__graphedge__set.__split_fields = target.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = cap}  in
                   oeq__2__logic rec_t source = True }
end

module Graph__graphedge__move
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__Oeq__2

  val move (target:Graph__graphedge__set.__split_fields__ref) (t_cap : Graph__graphedge__set.__split_discrs) (source:Graph__graphedge__set.__split_fields__ref) (s_cap : Graph__graphedge__set.__split_discrs) : unit
     requires { let rec_s = {Graph__graphedge__set.__split_fields = source.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = s_cap}  in
                   Ada__containers__count_type.to_rep (t_cap.rec__capacity) >= length_ rec_s }
     writes     { target, source }
     reads      { target, source }
     ensures { let rec_t = {Graph__graphedge__set.__split_fields = target.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = t_cap}  in
               let rec_s = {Graph__graphedge__set.__split_fields = source.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = s_cap}  in
               let old_s = {Graph__graphedge__set.__split_fields = old source.Graph__graphedge__set.__split_fields__content;
                              Graph__graphedge__set.__split_discrs = s_cap}  in
                   oeq__2__logic rec_t old_s = True /\ length_ rec_s = 0 }
end

module Graph__graphedge__copy
  use import int.Int
  use import "_gnatprove_standard".Main
  use import Graph__graphedge__set
  use import Graph__graphedge__length
  use import Graph__graphedge__strict_equal

  function copy__logic set int : set

  axiom copy__def:
    forall co : set, cap : int [copy__logic co cap].
       strict_equal__logic co (copy__logic co cap) = True /\
       (cap = 0 -> capacity co = capacity (copy__logic co cap)) /\
       (cap >= capacity co ->  capacity (copy__logic co cap) = cap)

  val copy (co: set) (cap:int) : set
     requires { cap = 0 \/ cap >= capacity co}
     ensures { result = copy__logic co cap /\ set_inv result }
end


(* Module for axiomatizing type "T95s" defined at graph.ads:29, created in Gnat2Why.Types.Translate_Type *)
module Graph__mygraph__T95s
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main
 use        Ada__containers__count_type
 use        Graph__graphnode__set

 type __split_fields #"graph.ads" 8 0 0# =
  { rec__main__ "model_trace:" : Main.__private }
 
 function __split_fields_5__projection #"graph.ads" 8 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__main__
 
 meta "model_projection" function __split_fields_5__projection
 
 meta "inline : no" function __split_fields_5__projection
 
 type __split_fields__ref #"graph.ads" 8 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_8__projection #"graph.ads" 8 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_8__projection
 
 meta "inline : no" function __split_fields__ref_8__projection
 
 val __split_fields__havoc #"graph.ads" 8 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type t95s #"graph.ads" 29 0 0# =
  { __split_discrs "model_trace:" : Graph__graphnode__set.__split_discrs; __split_fields "model_trace:" : __split_fields }
 
 function t95s___projection #"graph.ads" 29 0 0# 
   (a : t95s) : Graph__graphnode__set.__split_discrs =
  a.__split_discrs
 
 meta "model_projection" function t95s___projection
 
 meta "inline : no" function t95s___projection
 
 function t95s_2__projection #"graph.ads" 29 0 0# 
   (a : t95s) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function t95s_2__projection
 
 meta "inline : no" function t95s_2__projection
 
 function to_base #"graph.ads" 29 0 0# 
   (a : t95s) : Graph__graphnode__set.set =
  { Graph__graphnode__set.__split_discrs = a.__split_discrs; Graph__graphnode__set.__split_fields = { Graph__graphnode__set.rec__main__ = a.__split_fields.rec__main__ } }
 
 function of_base #"a-cforse.ads" 78 0 0# 
   (r : Graph__graphnode__set.set) : t95s =
  { __split_discrs = r.Graph__graphnode__set.__split_discrs; __split_fields = { rec__main__ = r.Graph__graphnode__set.__split_fields.Graph__graphnode__set.rec__main__ } }
 
 val rec__capacity_ #"a-cforse.ads" 78 0 0# 
   (a : t95s) : Ada__containers__count_type.count_type
  requires { true }
  ensures { (result = a.__split_discrs.Graph__graphnode__set.rec__capacity) }
 
 function bool_eq #"a-cforse.ads" 78 0 0# 
   (a : t95s) (b : t95s) : bool =
  (if (( ((Ada__containers__count_type.to_rep a.__split_discrs.Graph__graphnode__set.rec__capacity) = (Ada__containers__count_type.to_rep b.__split_discrs.Graph__graphnode__set.rec__capacity)) /\ (a.__split_fields.rec__main__ = b.__split_fields.rec__main__) )) then (
   True) else (
   False))
 
 function user_eq #"a-cforse.ads" 78 0 0# 
   (a : t95s) (b : t95s) : bool
 
 function value__size #"graph.ads" 29 0 0# 
   : int
 
 function object__size #"graph.ads" 29 0 0# 
   (a : t95s) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : t95s.
   ((object__size a) >= 0))
 
 predicate in_range #"graph.ads" 29 0 0# 
   (rec__capacity : int) (a : Graph__graphnode__set.set)  =
  (rec__capacity = (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity a.Graph__graphnode__set.__split_discrs)))
 
 val range_check_ #"a-cforse.ads" 78 0 0# 
   (rec__capacity : int) (a : Graph__graphnode__set.set) : Graph__graphnode__set.set
  requires { (in_range rec__capacity a) }
  ensures { (result = a) }
 
 function dummy #"a-cforse.ads" 78 0 0# 
   : t95s
 
 type t95s__ref #"graph.ads" 29 0 0# =
  { mutable t95s__content "model_trace:" : t95s }
 
 function t95s__ref___projection #"graph.ads" 29 0 0# 
   (a : t95s__ref) : t95s =
  a.t95s__content
 
 meta "model_projection" function t95s__ref___projection
 
 meta "inline : no" function t95s__ref___projection
 
 val t95s__havoc #"graph.ads" 29 0 0# 
   (x : t95s__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "T97s" defined at graph.ads:30, created in Gnat2Why.Types.Translate_Type *)
module Graph__mygraph__T97s
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main
 use        Ada__containers__count_type
 use        Graph__graphedge__set

 type __split_fields #"graph.ads" 29 0 0# =
  { rec__main__ "model_trace:" : Main.__private }
 
 function __split_fields_6__projection #"graph.ads" 29 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__main__
 
 meta "model_projection" function __split_fields_6__projection
 
 meta "inline : no" function __split_fields_6__projection
 
 type __split_fields__ref #"graph.ads" 29 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_9__projection #"graph.ads" 29 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_9__projection
 
 meta "inline : no" function __split_fields__ref_9__projection
 
 val __split_fields__havoc #"graph.ads" 29 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type t97s #"graph.ads" 30 0 0# =
  { __split_discrs "model_trace:" : Graph__graphedge__set.__split_discrs; __split_fields "model_trace:" : __split_fields }
 
 function t97s___projection #"graph.ads" 30 0 0# 
   (a : t97s) : Graph__graphedge__set.__split_discrs =
  a.__split_discrs
 
 meta "model_projection" function t97s___projection
 
 meta "inline : no" function t97s___projection
 
 function t97s_2__projection #"graph.ads" 30 0 0# 
   (a : t97s) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function t97s_2__projection
 
 meta "inline : no" function t97s_2__projection
 
 function to_base #"graph.ads" 30 0 0# 
   (a : t97s) : Graph__graphedge__set.set =
  { Graph__graphedge__set.__split_discrs = a.__split_discrs; Graph__graphedge__set.__split_fields = { Graph__graphedge__set.rec__main__ = a.__split_fields.rec__main__ } }
 
 function of_base #"a-cforse.ads" 78 0 0# 
   (r : Graph__graphedge__set.set) : t97s =
  { __split_discrs = r.Graph__graphedge__set.__split_discrs; __split_fields = { rec__main__ = r.Graph__graphedge__set.__split_fields.Graph__graphedge__set.rec__main__ } }
 
 val rec__capacity_ #"a-cforse.ads" 78 0 0# 
   (a : t97s) : Ada__containers__count_type.count_type
  requires { true }
  ensures { (result = a.__split_discrs.Graph__graphedge__set.rec__capacity) }
 
 function bool_eq #"a-cforse.ads" 78 0 0# 
   (a : t97s) (b : t97s) : bool =
  (if (( ((Ada__containers__count_type.to_rep a.__split_discrs.Graph__graphedge__set.rec__capacity) = (Ada__containers__count_type.to_rep b.__split_discrs.Graph__graphedge__set.rec__capacity)) /\ (a.__split_fields.rec__main__ = b.__split_fields.rec__main__) )) then (
   True) else (
   False))
 
 function user_eq #"a-cforse.ads" 78 0 0# 
   (a : t97s) (b : t97s) : bool
 
 function value__size #"graph.ads" 30 0 0# 
   : int
 
 function object__size #"graph.ads" 30 0 0# 
   (a : t97s) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : t97s.
   ((object__size a) >= 0))
 
 predicate in_range #"graph.ads" 30 0 0# 
   (rec__capacity : int) (a : Graph__graphedge__set.set)  =
  (rec__capacity = (Ada__containers__count_type.to_rep (Graph__graphedge__set.rec__capacity a.Graph__graphedge__set.__split_discrs)))
 
 val range_check_ #"a-cforse.ads" 78 0 0# 
   (rec__capacity : int) (a : Graph__graphedge__set.set) : Graph__graphedge__set.set
  requires { (in_range rec__capacity a) }
  ensures { (result = a) }
 
 function dummy #"a-cforse.ads" 78 0 0# 
   : t97s
 
 type t97s__ref #"graph.ads" 30 0 0# =
  { mutable t97s__content "model_trace:" : t97s }
 
 function t97s__ref___projection #"graph.ads" 30 0 0# 
   (a : t97s__ref) : t97s =
  a.t97s__content
 
 meta "model_projection" function t97s__ref___projection
 
 meta "inline : no" function t97s__ref___projection
 
 val t97s__havoc #"graph.ads" 30 0 0# 
   (x : t97s__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "mygraph" defined at graph.ads:28, created in Gnat2Why.Types.Translate_Type *)
module Graph__mygraph
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Graph__mygraph__T95s
 use        Graph__mygraph__T97s

 type __split_fields #"graph.ads" 30 0 0# =
  { rec__gnode "model_trace:.3245" : Graph__mygraph__T95s.t95s; rec__gedge "model_trace:.3260" : Graph__mygraph__T97s.t97s }
 
 function __split_fields_gnode__projection #"graph.ads" 30 0 0# "model_trace:.3245" 
   (a : __split_fields) : Graph__mygraph__T95s.t95s =
  a.rec__gnode
 
 meta "model_projection" function __split_fields_gnode__projection
 
 meta "inline : no" function __split_fields_gnode__projection
 
 function __split_fields_gedge__projection #"graph.ads" 28 0 0# "model_trace:.3260" 
   (a : __split_fields) : Graph__mygraph__T97s.t97s =
  a.rec__gedge
 
 meta "model_projection" function __split_fields_gedge__projection
 
 meta "inline : no" function __split_fields_gedge__projection
 
 type __split_fields__ref #"graph.ads" 28 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_10__projection #"graph.ads" 28 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_10__projection
 
 meta "inline : no" function __split_fields__ref_10__projection
 
 val __split_fields__havoc #"graph.ads" 28 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type mygraph #"graph.ads" 28 0 0# =
  { __split_fields "model_trace:" : __split_fields }
 
 function mygraph___projection #"graph.ads" 28 0 0# 
   (a : mygraph) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function mygraph___projection
 
 meta "inline : no" function mygraph___projection
 
 predicate gnode__pred #"graph.ads" 28 0 0# 
   (a : mygraph)  =
  true
 
 val rec__gnode_ #"graph.ads" 28 0 0# 
   (a : mygraph) : Graph__mygraph__T95s.t95s
  requires { (gnode__pred a) }
  ensures { (result = a.__split_fields.rec__gnode) }
 
 predicate gedge__pred #"graph.ads" 28 0 0# 
   (a : mygraph)  =
  true
 
 val rec__gedge_ #"graph.ads" 28 0 0# 
   (a : mygraph) : Graph__mygraph__T97s.t97s
  requires { (gedge__pred a) }
  ensures { (result = a.__split_fields.rec__gedge) }
 
 function bool_eq #"graph.ads" 28 0 0# 
   (a : mygraph) (b : mygraph) : bool =
  (if (( ((Graph__mygraph__T95s.bool_eq a.__split_fields.rec__gnode b.__split_fields.rec__gnode) = True) /\ ((Graph__mygraph__T97s.bool_eq a.__split_fields.rec__gedge b.__split_fields.rec__gedge) = True) )) then (
   True) else (
   False))
 
 function user_eq #"graph.ads" 28 0 0# 
   (a : mygraph) (b : mygraph) : bool
 
 function value__size #"graph.ads" 28 0 0# 
   : int
 
 function object__size #"graph.ads" 28 0 0# 
   (a : mygraph) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : mygraph.
   ((object__size a) >= 0))
 
 function dummy #"graph.ads" 28 0 0# 
   : mygraph
 
 type mygraph__ref #"graph.ads" 28 0 0# =
  { mutable mygraph__content "model_trace:" : mygraph }
 
 function mygraph__ref___projection #"graph.ads" 28 0 0# 
   (a : mygraph__ref) : mygraph =
  a.mygraph__content
 
 meta "model_projection" function mygraph__ref___projection
 
 meta "inline : no" function mygraph__ref___projection
 
 val mygraph__havoc #"graph.ads" 28 0 0# 
   (x : mygraph__ref) : unit
  writes {x}

end

(* Module for defining the constant "n" defined at graph.ads:33, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__addnode__n
 use import "_gnatprove_standard".Main

 function n #"graph.ads" 33 0 0# "model" "model_trace:3293" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "n" defined at graph.ads:33, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__addnode__n__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "from" defined at graph.ads:38, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__addedge__from
 use import "_gnatprove_standard".Main

 function from #"graph.ads" 38 0 0# "model" "model_trace:3356" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "from" defined at graph.ads:38, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__addedge__from__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "to" defined at graph.ads:38, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__addedge__to
 use import "_gnatprove_standard".Main

 function to__ #"graph.ads" 38 0 0# "model" "model_trace:3365" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "to" defined at graph.ads:38, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__addedge__to__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "n" defined at graph.ads:43, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__findnext__n
 use import "_gnatprove_standard".Main

 function n #"graph.ads" 43 0 0# "model" "model_trace:3423" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "n" defined at graph.ads:43, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__findnext__n__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "g" defined at graph.ads:43, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__findnext__g
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function g #"graph.ads" 43 0 0# "model_projected" "model_trace:3432" 
   : Graph__mygraph.mygraph
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 28 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "g" defined at graph.ads:43, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__findnext__g__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "findnext" defined at graph.ads:43, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Graph__findnext
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__set
 use        Graph__mygraph

 function findnext #"graph.ads" 43 0 0# 
   (n : int) (g : Graph__mygraph.mygraph) : Graph__graphnode__set.set

end

(* Module for defining the constant "source" defined at graph.ads:51, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__distance__source
 use import "_gnatprove_standard".Main

 function source #"graph.ads" 51 0 0# "model" "model_trace:3495" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "source" defined at graph.ads:51, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__source__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "target" defined at graph.ads:51, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__distance__target
 use import "_gnatprove_standard".Main

 function target #"graph.ads" 51 0 0# "model" "model_trace:3504" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "target" defined at graph.ads:51, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__target__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "g" defined at graph.ads:51, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__distance__g
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function g #"graph.ads" 51 0 0# "model_projected" "model_trace:3513" 
   : Graph__mygraph.mygraph
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 28 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "g" defined at graph.ads:51, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__g__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "distance" defined at graph.ads:51, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Graph__distance
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function distance #"graph.ads" 51 0 0# 
   (source : int) (target : int) (g : Graph__mygraph.mygraph) : int

end

(* Module for defining the constant "g" defined at graph.ads:55, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__diameter__g
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function g #"graph.ads" 55 0 0# "model_projected" "model_trace:3561" 
   : Graph__mygraph.mygraph
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 28 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "g" defined at graph.ads:55, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__g__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "diameter" defined at graph.ads:55, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Graph__diameter
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function diameter #"graph.ads" 55 0 0# 
   (g : Graph__mygraph.mygraph) : int

end

(* Module for defining the constant "x" defined at graph.ads:58, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__small__x
 use import "_gnatprove_standard".Main

 function x #"graph.ads" 58 0 0# "model" "model_trace:3607" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "x" defined at graph.ads:58, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__small__x__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "g" defined at graph.ads:58, created in Gnat2Why.Decls.Translate_Constant *)
module Graph__small__g
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function g #"graph.ads" 58 0 0# "model_projected" "model_trace:3616" 
   : Graph__mygraph.mygraph
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 28 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "g" defined at graph.ads:58, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__small__g__axiom
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "small" defined at graph.ads:58, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Graph__small
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function small #"graph.ads" 58 0 0# 
   (x : int) (g : Graph__mygraph.mygraph) : bool

end

(* Module for defining the constant "s" defined at io.ads:4, created in Gnat2Why.Decls.Translate_Constant *)
module Io__myprint__s
 use import "_gnatprove_standard".Main
 use        Standard__string

 function s #"io.ads" 4 0 0# "model_projected" "model_trace:8682" 
   : Standard__string.string
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "s" defined at io.ads:4, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Io__myprint__s__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "ns" defined at io.ads:6, created in Gnat2Why.Decls.Translate_Constant *)
module Io__myprintnodes__ns
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__set

 function ns #"io.ads" 6 0 0# 
   : Graph__graphnode__set.set
 
 function attr__ATTRIBUTE_ADDRESS #"a-cforse.ads" 78 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "ns" defined at io.ads:6, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Io__myprintnodes__ns__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "es" defined at io.ads:7, created in Gnat2Why.Decls.Translate_Constant *)
module Io__myprintedges__es
 use import "_gnatprove_standard".Main
 use        Graph__graphedge__set

 function es #"io.ads" 7 0 0# 
   : Graph__graphedge__set.set
 
 function attr__ATTRIBUTE_ADDRESS #"a-cforse.ads" 78 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "es" defined at io.ads:7, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Io__myprintedges__es__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "g" defined at io.ads:8, created in Gnat2Why.Decls.Translate_Constant *)
module Io__myprintgraph__g
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 function g #"io.ads" 8 0 0# "model_projected" "model_trace:8745" 
   : Graph__mygraph.mygraph
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 28 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "g" defined at io.ads:8, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Io__myprintgraph__g__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "n" defined at io.ads:9, created in Gnat2Why.Decls.Translate_Constant *)
module Io__printnode__n
 use import "_gnatprove_standard".Main

 function n #"io.ads" 9 0 0# "model" "model_trace:8763" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "n" defined at io.ads:9, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Io__printnode__n__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "i" defined at io.ads:10, created in Gnat2Why.Decls.Translate_Constant *)
module Io__printnumber__i
 use import "_gnatprove_standard".Main

 function i #"io.ads" 10 0 0# "model" "model_trace:8781" 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "i" defined at io.ads:10, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Io__printnumber__i__axiom
 use import "_gnatprove_standard".Main


end

(* Module for axiomatizing type "TworkingS" defined at graph.adb:27, created in Gnat2Why.Types.Translate_Type *)
module Graph__findnext__TworkingS
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main
 use        Ada__containers__count_type
 use        Graph__graphnode__set

 type __split_fields #"system.ads" 1 0 0# =
  { rec__main__ "model_trace:" : Main.__private }
 
 function __split_fields_7__projection #"system.ads" 1 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__main__
 
 meta "model_projection" function __split_fields_7__projection
 
 meta "inline : no" function __split_fields_7__projection
 
 type __split_fields__ref #"system.ads" 1 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_11__projection #"system.ads" 1 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_11__projection
 
 meta "inline : no" function __split_fields__ref_11__projection
 
 val __split_fields__havoc #"system.ads" 1 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type tworkingS #"graph.adb" 27 0 0# =
  { __split_discrs "model_trace:" : Graph__graphnode__set.__split_discrs; __split_fields "model_trace:" : __split_fields }
 
 function tworkingS___projection #"graph.adb" 27 0 0# 
   (a : tworkingS) : Graph__graphnode__set.__split_discrs =
  a.__split_discrs
 
 meta "model_projection" function tworkingS___projection
 
 meta "inline : no" function tworkingS___projection
 
 function tworkingS_2__projection #"graph.adb" 27 0 0# 
   (a : tworkingS) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function tworkingS_2__projection
 
 meta "inline : no" function tworkingS_2__projection
 
 function to_base #"graph.adb" 27 0 0# 
   (a : tworkingS) : Graph__graphnode__set.set =
  { Graph__graphnode__set.__split_discrs = a.__split_discrs; Graph__graphnode__set.__split_fields = { Graph__graphnode__set.rec__main__ = a.__split_fields.rec__main__ } }
 
 function of_base #"a-cforse.ads" 78 0 0# 
   (r : Graph__graphnode__set.set) : tworkingS =
  { __split_discrs = r.Graph__graphnode__set.__split_discrs; __split_fields = { rec__main__ = r.Graph__graphnode__set.__split_fields.Graph__graphnode__set.rec__main__ } }
 
 val rec__capacity_ #"a-cforse.ads" 78 0 0# 
   (a : tworkingS) : Ada__containers__count_type.count_type
  requires { true }
  ensures { (result = a.__split_discrs.Graph__graphnode__set.rec__capacity) }
 
 function bool_eq #"a-cforse.ads" 78 0 0# 
   (a : tworkingS) (b : tworkingS) : bool =
  (if (( ((Ada__containers__count_type.to_rep a.__split_discrs.Graph__graphnode__set.rec__capacity) = (Ada__containers__count_type.to_rep b.__split_discrs.Graph__graphnode__set.rec__capacity)) /\ (a.__split_fields.rec__main__ = b.__split_fields.rec__main__) )) then (
   True) else (
   False))
 
 function user_eq #"a-cforse.ads" 78 0 0# 
   (a : tworkingS) (b : tworkingS) : bool
 
 function value__size #"graph.adb" 27 0 0# 
   : int
 
 function object__size #"graph.adb" 27 0 0# 
   (a : tworkingS) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : tworkingS.
   ((object__size a) >= 0))
 
 predicate in_range #"graph.adb" 27 0 0# 
   (rec__capacity : int) (a : Graph__graphnode__set.set)  =
  (rec__capacity = (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity a.Graph__graphnode__set.__split_discrs)))
 
 val range_check_ #"a-cforse.ads" 78 0 0# 
   (rec__capacity : int) (a : Graph__graphnode__set.set) : Graph__graphnode__set.set
  requires { (in_range rec__capacity a) }
  ensures { (result = a) }
 
 function dummy #"a-cforse.ads" 78 0 0# 
   : tworkingS
 
 type tworkingS__ref #"graph.adb" 27 0 0# =
  { mutable tworkingS__content "model_trace:" : tworkingS }
 
 function tworkingS__ref___projection #"graph.adb" 27 0 0# 
   (a : tworkingS__ref) : tworkingS =
  a.tworkingS__content
 
 meta "model_projection" function tworkingS__ref___projection
 
 meta "inline : no" function tworkingS__ref___projection
 
 val tworkingS__havoc #"graph.adb" 27 0 0# 
   (x : tworkingS__ref) : unit
  writes {x}

end

(* Module for axiomatizing type "TreachS" defined at graph.adb:47, created in Gnat2Why.Types.Translate_Type *)
module Graph__distance__TreachS
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Main
 use        Ada__containers__count_type
 use        Graph__graphnode__set

 type __split_fields #"graph.adb" 27 0 0# =
  { rec__main__ "model_trace:" : Main.__private }
 
 function __split_fields_8__projection #"graph.adb" 27 0 0# 
   (a : __split_fields) : Main.__private =
  a.rec__main__
 
 meta "model_projection" function __split_fields_8__projection
 
 meta "inline : no" function __split_fields_8__projection
 
 type __split_fields__ref #"graph.adb" 27 0 0# =
  { mutable __split_fields__content "model_trace:" : __split_fields }
 
 function __split_fields__ref_12__projection #"graph.adb" 27 0 0# 
   (a : __split_fields__ref) : __split_fields =
  a.__split_fields__content
 
 meta "model_projection" function __split_fields__ref_12__projection
 
 meta "inline : no" function __split_fields__ref_12__projection
 
 val __split_fields__havoc #"graph.adb" 27 0 0# 
   (x : __split_fields__ref) : unit
  writes {x}
 
 type treachS #"graph.adb" 47 0 0# =
  { __split_discrs "model_trace:" : Graph__graphnode__set.__split_discrs; __split_fields "model_trace:" : __split_fields }
 
 function treachS___projection #"graph.adb" 47 0 0# 
   (a : treachS) : Graph__graphnode__set.__split_discrs =
  a.__split_discrs
 
 meta "model_projection" function treachS___projection
 
 meta "inline : no" function treachS___projection
 
 function treachS_2__projection #"graph.adb" 47 0 0# 
   (a : treachS) : __split_fields =
  a.__split_fields
 
 meta "model_projection" function treachS_2__projection
 
 meta "inline : no" function treachS_2__projection
 
 function to_base #"graph.adb" 47 0 0# 
   (a : treachS) : Graph__graphnode__set.set =
  { Graph__graphnode__set.__split_discrs = a.__split_discrs; Graph__graphnode__set.__split_fields = { Graph__graphnode__set.rec__main__ = a.__split_fields.rec__main__ } }
 
 function of_base #"a-cforse.ads" 78 0 0# 
   (r : Graph__graphnode__set.set) : treachS =
  { __split_discrs = r.Graph__graphnode__set.__split_discrs; __split_fields = { rec__main__ = r.Graph__graphnode__set.__split_fields.Graph__graphnode__set.rec__main__ } }
 
 val rec__capacity_ #"a-cforse.ads" 78 0 0# 
   (a : treachS) : Ada__containers__count_type.count_type
  requires { true }
  ensures { (result = a.__split_discrs.Graph__graphnode__set.rec__capacity) }
 
 function bool_eq #"a-cforse.ads" 78 0 0# 
   (a : treachS) (b : treachS) : bool =
  (if (( ((Ada__containers__count_type.to_rep a.__split_discrs.Graph__graphnode__set.rec__capacity) = (Ada__containers__count_type.to_rep b.__split_discrs.Graph__graphnode__set.rec__capacity)) /\ (a.__split_fields.rec__main__ = b.__split_fields.rec__main__) )) then (
   True) else (
   False))
 
 function user_eq #"a-cforse.ads" 78 0 0# 
   (a : treachS) (b : treachS) : bool
 
 function value__size #"graph.adb" 47 0 0# 
   : int
 
 function object__size #"graph.adb" 47 0 0# 
   (a : treachS) : int
 
 axiom value__size_axiom :
  ((value__size ) >= 0)
 
 axiom object__size_axiom :
  (forall a : treachS.
   ((object__size a) >= 0))
 
 predicate in_range #"graph.adb" 47 0 0# 
   (rec__capacity : int) (a : Graph__graphnode__set.set)  =
  (rec__capacity = (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity a.Graph__graphnode__set.__split_discrs)))
 
 val range_check_ #"a-cforse.ads" 78 0 0# 
   (rec__capacity : int) (a : Graph__graphnode__set.set) : Graph__graphnode__set.set
  requires { (in_range rec__capacity a) }
  ensures { (result = a) }
 
 function dummy #"a-cforse.ads" 78 0 0# 
   : treachS
 
 type treachS__ref #"graph.adb" 47 0 0# =
  { mutable treachS__content "model_trace:" : treachS }
 
 function treachS__ref___projection #"graph.adb" 47 0 0# 
   (a : treachS__ref) : treachS =
  a.treachS__content
 
 meta "model_projection" function treachS__ref___projection
 
 meta "inline : no" function treachS__ref___projection
 
 val treachS__havoc #"graph.adb" 47 0 0# 
   (x : treachS__ref) : unit
  writes {x}

end
(* Module for defining a ref holding the value of variable "object" defined at s-finroo.ads:42, created in Gnat2Why.Decls.Translate_Variable *)
module System__finalization_root__adjust__object
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled

 val object__split_fields #"s-finroo.ads" 42 0 0# "model_projected" "model_trace:8316"  : System__finalization_root__root_controlled.__split_fields__ref 
 
 function object__attr__tag #"s-finroo.ads" 42 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"s-finroo.ads" 42 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at s-finroo.ads:42, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__finalization_root__adjust__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "object" defined at s-finroo.ads:43, created in Gnat2Why.Decls.Translate_Variable *)
module System__finalization_root__finalize__object
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled

 val object__split_fields #"s-finroo.ads" 43 0 0# "model_projected" "model_trace:8334"  : System__finalization_root__root_controlled.__split_fields__ref 
 
 function object__attr__tag #"s-finroo.ads" 43 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"s-finroo.ads" 43 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at s-finroo.ads:43, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__finalization_root__finalize__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "object" defined at s-finroo.ads:44, created in Gnat2Why.Decls.Translate_Variable *)
module System__finalization_root__initialize__object
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled

 val object__split_fields #"s-finroo.ads" 44 0 0# "model_projected" "model_trace:8352"  : System__finalization_root__root_controlled.__split_fields__ref 
 
 function object__attr__tag #"s-finroo.ads" 44 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"s-finroo.ads" 44 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at s-finroo.ads:44, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__finalization_root__initialize__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "object" defined at a-finali.ads:46, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__finalization__initialize__object
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled

 val object__split_fields #"a-finali.ads" 46 0 0# "model_projected" "model_trace:7240"  : Ada__finalization__controlled.__split_fields__ref 
 
 function object__attr__tag #"a-finali.ads" 46 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"a-finali.ads" 46 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at a-finali.ads:46, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__finalization__initialize__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "object" defined at a-finali.ads:47, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__finalization__adjust__object
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled

 val object__split_fields #"a-finali.ads" 47 0 0# "model_projected" "model_trace:7258"  : Ada__finalization__controlled.__split_fields__ref 
 
 function object__attr__tag #"a-finali.ads" 47 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"a-finali.ads" 47 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at a-finali.ads:47, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__finalization__adjust__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "object" defined at a-finali.ads:48, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__finalization__finalize__object
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled

 val object__split_fields #"a-finali.ads" 48 0 0# "model_projected" "model_trace:7276"  : Ada__finalization__controlled.__split_fields__ref 
 
 function object__attr__tag #"a-finali.ads" 48 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"a-finali.ads" 48 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at a-finali.ads:48, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__finalization__finalize__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "object" defined at a-finali.ads:53, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__finalization__initialize__2__object
 use import "_gnatprove_standard".Main
 use        Ada__finalization__limited_controlled

 val object__split_fields #"a-finali.ads" 53 0 0# "model_projected" "model_trace:7306"  : Ada__finalization__limited_controlled.__split_fields__ref 
 
 function object__attr__tag #"a-finali.ads" 53 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"a-finali.ads" 53 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at a-finali.ads:53, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__finalization__initialize__2__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "object" defined at a-finali.ads:54, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__finalization__finalize__2__object
 use import "_gnatprove_standard".Main
 use        Ada__finalization__limited_controlled

 val object__split_fields #"a-finali.ads" 54 0 0# "model_projected" "model_trace:7324"  : Ada__finalization__limited_controlled.__split_fields__ref 
 
 function object__attr__tag #"a-finali.ads" 54 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"a-finali.ads" 54 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "object" defined at a-finali.ads:54, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__finalization__finalize__2__object__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "item" defined at s-atocou.ads:57, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__increment__item
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter

 val item__split_fields #"s-atocou.ads" 57 0 0#  : System__atomic_counters__atomic_counter.__split_fields__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 102 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at s-atocou.ads:57, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__increment__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "item" defined at s-atocou.ads:61, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__decrement__item
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter

 val item__split_fields #"s-atocou.ads" 61 0 0#  : System__atomic_counters__atomic_counter.__split_fields__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 102 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at s-atocou.ads:61, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__decrement__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "item" defined at s-atocou.ads:69, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__initialize__item
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter

 val item__split_fields #"s-atocou.ads" 69 0 0#  : System__atomic_counters__atomic_counter.__split_fields__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 102 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at s-atocou.ads:69, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__initialize__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "item" defined at s-atocou.ads:81, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__increment__2__item
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 val item #"s-atocou.ads" 81 0 0# "model" "model_trace:8509"  : BV32.t__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 75 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at s-atocou.ads:81, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__increment__2__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "item" defined at s-atocou.ads:85, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__decrement__2__item
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 val item #"s-atocou.ads" 85 0 0# "model" "model_trace:8531"  : BV32.t__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 75 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at s-atocou.ads:85, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__decrement__2__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "item" defined at s-atocou.ads:88, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__decrement__3__item
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 val item #"s-atocou.ads" 88 0 0# "model" "model_trace:8554"  : BV32.t__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 75 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at s-atocou.ads:88, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__decrement__3__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "left" defined at s-atocou.ads:95, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__Oadd__left
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 val left #"s-atocou.ads" 95 0 0# "model" "model_trace:8576"  : BV32.t__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 75 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at s-atocou.ads:95, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__Oadd__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "right" defined at s-atocou.ads:95, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__Oadd__right
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 val right #"s-atocou.ads" 95 0 0# "model" "model_trace:8583"  : BV32.t__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 75 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at s-atocou.ads:95, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__Oadd__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "left" defined at s-atocou.ads:98, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__Osubtract__left
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 val left #"s-atocou.ads" 98 0 0# "model" "model_trace:8603"  : BV32.t__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 75 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "left" defined at s-atocou.ads:98, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__Osubtract__left__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "right" defined at s-atocou.ads:98, created in Gnat2Why.Decls.Translate_Variable *)
module System__atomic_counters__Osubtract__right
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32

 val right #"s-atocou.ads" 98 0 0# "model" "model_trace:8610"  : BV32.t__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"s-atocou.ads" 75 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "right" defined at s-atocou.ads:98, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module System__atomic_counters__Osubtract__right__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "stream" defined at a-stream.ads:58, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__streams__read__stream
 use import "_gnatprove_standard".Main
 use        Ada__streams__root_stream_type

 val stream__split_fields #"a-stream.ads" 58 0 0# "model_projected" "model_trace:36287"  : Ada__streams__root_stream_type.__split_fields__ref 
 
 function stream__attr__tag #"a-stream.ads" 58 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 58 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "stream" defined at a-stream.ads:58, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__read__stream__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "item" defined at a-stream.ads:59, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__streams__read__item
 use import "_gnatprove_standard".Main
 use        Ada__streams__Tstream_element_offsetB
 use        Array__Int__Ada__streams__stream_element

 val item #"a-stream.ads" 59 0 0# "model_projected" "model_trace:36296"  : Array__Int__Ada__streams__stream_element.map__ref 
 
 function item__first #"a-stream.ads" 59 0 0# "model_projected" "model_trace:36296'First" 
   : Ada__streams__Tstream_element_offsetB.tstream_element_offsetB
 
 function item__last #"a-stream.ads" 59 0 0# "model_projected" "model_trace:36296'Last" 
   : Ada__streams__Tstream_element_offsetB.tstream_element_offsetB
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 44 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "item" defined at a-stream.ads:59, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__read__item__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "last" defined at a-stream.ads:60, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__streams__read__last
 use import "_gnatprove_standard".Main

 val last #"a-stream.ads" 60 0 0# "model" "model_trace:36305"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 44 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "last" defined at a-stream.ads:60, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__read__last__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "stream" defined at a-stream.ads:64, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__streams__write__stream
 use import "_gnatprove_standard".Main
 use        Ada__streams__root_stream_type

 val stream__split_fields #"a-stream.ads" 64 0 0# "model_projected" "model_trace:36323"  : Ada__streams__root_stream_type.__split_fields__ref 
 
 function stream__attr__tag #"a-stream.ads" 64 0 0# 
   : int
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 64 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "stream" defined at a-stream.ads:64, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__write__stream__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "v" defined at a-stream.ads:78, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__streams__read_sea__v
 use import "_gnatprove_standard".Main
 use        Ada__streams__Tstream_element_offsetB
 use        Array__Int__Ada__streams__stream_element

 val v #"a-stream.ads" 78 0 0# "model_projected" "model_trace:36372"  : Array__Int__Ada__streams__stream_element.map__ref 
 
 function v__first #"a-stream.ads" 78 0 0# "model_projected" "model_trace:36372'First" 
   : Ada__streams__Tstream_element_offsetB.tstream_element_offsetB
 
 function v__last #"a-stream.ads" 78 0 0# "model_projected" "model_trace:36372'Last" 
   : Ada__streams__Tstream_element_offsetB.tstream_element_offsetB
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 44 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "v" defined at a-stream.ads:78, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__read_sea__v__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "v" defined at a-stream.ads:84, created in Gnat2Why.Decls.Translate_Variable *)
module Ada__streams__stream_element_arraySR__v
 use import "_gnatprove_standard".Main
 use        Ada__streams__Tstream_element_offsetB
 use        Array__Int__Ada__streams__stream_element

 val v #"a-stream.ads" 84 0 0#  : Array__Int__Ada__streams__stream_element.map__ref 
 
 function v__first #"a-stream.ads" 84 0 0# 
   : Ada__streams__Tstream_element_offsetB.tstream_element_offsetB
 
 function v__last #"a-stream.ads" 84 0 0# 
   : Ada__streams__Tstream_element_offsetB.tstream_element_offsetB
 
 function attr__ATTRIBUTE_ADDRESS #"a-stream.ads" 44 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "v" defined at a-stream.ads:84, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Ada__streams__stream_element_arraySR__v__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "g" defined at graph.ads:33, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__addnode__g
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 val g__split_fields #"graph.ads" 33 0 0# "model_projected" "model_trace:3284"  : Graph__mygraph.__split_fields__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 28 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "g" defined at graph.ads:33, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__addnode__g__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "g" defined at graph.ads:38, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__addedge__g
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 val g__split_fields #"graph.ads" 38 0 0# "model_projected" "model_trace:3347"  : Graph__mygraph.__split_fields__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 28 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "g" defined at graph.ads:38, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__addedge__g__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "e" defined at graph.adb:16, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__addedge__e
 use import "_gnatprove_standard".Main
 use        Graph__edge

 val e__split_fields #"graph.adb" 16 0 0# "model_projected" "model_trace:2397"  : Graph__edge.__split_fields__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 8 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "e" defined at graph.adb:16, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__addedge__e__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "working" defined at graph.adb:27, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__findnext__working
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__set
 use        Graph__findnext__TworkingS

 val working__split_fields #"graph.adb" 27 0 0#  : Graph__findnext__TworkingS.__split_fields__ref 
 
 function working__split_discrs #"graph.adb" 27 0 0# 
   : Graph__graphnode__set.__split_discrs
 
 function attr__ATTRIBUTE_ADDRESS #"graph.adb" 27 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "working" defined at graph.adb:27, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__findnext__working__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "c" defined at graph.adb:28, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__findnext__c
 use import "_gnatprove_standard".Main
 use        Graph__graphedge__cursor

 val c #"graph.adb" 28 0 0#  : Graph__graphedge__cursor.cursor__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"a-cforse.ads" 86 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "c" defined at graph.adb:28, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__findnext__c__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "next" defined at graph.adb:45, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__distance__next
 use import "_gnatprove_standard".Main

 val next #"graph.adb" 45 0 0# "model" "model_trace:2631"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "next" defined at graph.adb:45, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__next__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "reach" defined at graph.adb:47, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__distance__reach
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__set
 use        Graph__distance__TreachS

 val reach__split_fields #"graph.adb" 47 0 0#  : Graph__distance__TreachS.__split_fields__ref 
 
 function reach__split_discrs #"graph.adb" 47 0 0# 
   : Graph__graphnode__set.__split_discrs
 
 function attr__ATTRIBUTE_ADDRESS #"graph.adb" 47 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "reach" defined at graph.adb:47, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__reach__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "c1" defined at graph.adb:49, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__distance__c1
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__cursor

 val c1 #"graph.adb" 49 0 0#  : Graph__graphnode__cursor.cursor__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"a-cforse.ads" 86 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "c1" defined at graph.adb:49, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__c1__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "distance" defined at graph.adb:50, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__distance__distance
 use import "_gnatprove_standard".Main

 val distance #"graph.adb" 50 0 0# "model" "model_trace:2665"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "distance" defined at graph.adb:50, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__distance__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "source" defined at graph.adb:71, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__diameter__source
 use import "_gnatprove_standard".Main

 val source #"graph.adb" 71 0 0# "model" "model_trace:2784"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "source" defined at graph.adb:71, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__source__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "target" defined at graph.adb:72, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__diameter__target
 use import "_gnatprove_standard".Main

 val target #"graph.adb" 72 0 0# "model" "model_trace:2793"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"graph.ads" 7 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "target" defined at graph.adb:72, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__target__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "c" defined at graph.adb:74, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__diameter__c
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__cursor

 val c #"graph.adb" 74 0 0#  : Graph__graphnode__cursor.cursor__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"a-cforse.ads" 86 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "c" defined at graph.adb:74, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__c__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "c1" defined at graph.adb:76, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__diameter__c1
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__cursor

 val c1 #"graph.adb" 76 0 0#  : Graph__graphnode__cursor.cursor__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"a-cforse.ads" 86 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "c1" defined at graph.adb:76, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__c1__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "diameter" defined at graph.adb:77, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__diameter__diameter
 use import "_gnatprove_standard".Main

 val diameter #"graph.adb" 77 0 0# "model" "model_trace:2833"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "diameter" defined at graph.adb:77, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__diameter__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "value" defined at graph.adb:78, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__diameter__value
 use import "_gnatprove_standard".Main

 val value #"graph.adb" 78 0 0# "model" "model_trace:2843"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "value" defined at graph.adb:78, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__value__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "diametervalue" defined at graph.adb:98, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__small__diametervalue
 use import "_gnatprove_standard".Main

 val diametervalue #"graph.adb" 98 0 0# "model" "model_trace:2991"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "diametervalue" defined at graph.adb:98, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__small__diametervalue__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining a ref holding the value of variable "nodenumber" defined at graph.adb:99, created in Gnat2Why.Decls.Translate_Variable *)
module Graph__small__nodenumber
 use import "_gnatprove_standard".Main

 val nodenumber #"graph.adb" 99 0 0# "model" "model_trace:3000"  : int__ref 
 
 function attr__ATTRIBUTE_ADDRESS #"system.ads" 1 0 0# 
   : int

end

(* Module giving an empty axiom for the entity "nodenumber" defined at graph.adb:99, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__small__nodenumber__axiom
 use import "_gnatprove_standard".Main


end

(* Module declaring the external object "io__myprintnodes__n," created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintnodes__n
 use import "ref".Ref
 use import "_gnatprove_standard".Main

 val n #"system.ads" 1 0 0#  : Main.__private__ref 

end

(* Module giving an empty axiom for the entity "io__myprintnodes__n", created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintnodes__n__axiom
 use import "_gnatprove_standard".Main


end

(* Module declaring the external object "io__myprintnodes__c," created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintnodes__c
 use import "ref".Ref
 use import "_gnatprove_standard".Main

 val c #"system.ads" 1 0 0#  : Main.__private__ref 

end

(* Module giving an empty axiom for the entity "io__myprintnodes__c", created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintnodes__c__axiom
 use import "_gnatprove_standard".Main


end

(* Module declaring the external object "io__myprintedges__e," created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintedges__e
 use import "ref".Ref
 use import "_gnatprove_standard".Main

 val e #"system.ads" 1 0 0#  : Main.__private__ref 

end

(* Module giving an empty axiom for the entity "io__myprintedges__e", created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintedges__e__axiom
 use import "_gnatprove_standard".Main


end

(* Module declaring the external object "io__myprintedges__c," created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintedges__c
 use import "ref".Ref
 use import "_gnatprove_standard".Main

 val c #"system.ads" 1 0 0#  : Main.__private__ref 

end

(* Module giving an empty axiom for the entity "io__myprintedges__c", created in Gnat2Why.Decls.Translate_External_Object *)
module Io__myprintedges__c__axiom
 use import "_gnatprove_standard".Main


end
(* Module giving axioms for type "short_short_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__short_short_integer__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__short_short_integer

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_3 : int) (temp___is_init_0 : bool) (temp___do_constant_1 : bool) (temp___do_toplevel_2 : bool)  =
  (if (( temp___is_init_0 \/ (Standard__short_short_integer.first <= Standard__short_short_integer.last) )) then (
   (Standard__short_short_integer.dynamic_property Standard__short_short_integer.first Standard__short_short_integer.last temp___expr_3)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___4 : int) (temp___5 : bool)  =
  true

end

(* Module giving axioms for type "short_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__short_integer__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__short_integer

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_9 : int) (temp___is_init_6 : bool) (temp___do_constant_7 : bool) (temp___do_toplevel_8 : bool)  =
  (if (( temp___is_init_6 \/ (Standard__short_integer.first <= Standard__short_integer.last) )) then (
   (Standard__short_integer.dynamic_property Standard__short_integer.first Standard__short_integer.last temp___expr_9)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___10 : int) (temp___11 : bool)  =
  true

end

(* Module giving axioms for type "integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_15 : int) (temp___is_init_12 : bool) (temp___do_constant_13 : bool) (temp___do_toplevel_14 : bool)  =
  (if (( temp___is_init_12 \/ (Standard__integer.first <= Standard__integer.last) )) then (
   (Standard__integer.dynamic_property Standard__integer.first Standard__integer.last temp___expr_15)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___16 : int) (temp___17 : bool)  =
  true

end

(* Module giving axioms for type "long_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__long_integer__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__long_integer

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_21 : int) (temp___is_init_18 : bool) (temp___do_constant_19 : bool) (temp___do_toplevel_20 : bool)  =
  (if (( temp___is_init_18 \/ (Standard__long_integer.first <= Standard__long_integer.last) )) then (
   (Standard__long_integer.dynamic_property Standard__long_integer.first Standard__long_integer.last temp___expr_21)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___22 : int) (temp___23 : bool)  =
  true

end

(* Module giving axioms for type "long_long_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__long_long_integer__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__long_long_integer

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_27 : int) (temp___is_init_24 : bool) (temp___do_constant_25 : bool) (temp___do_toplevel_26 : bool)  =
  (if (( temp___is_init_24 \/ (Standard__long_long_integer.first <= Standard__long_long_integer.last) )) then (
   (Standard__long_long_integer.dynamic_property Standard__long_long_integer.first Standard__long_long_integer.last temp___expr_27)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___28 : int) (temp___29 : bool)  =
  true

end

(* Module giving axioms for type "natural", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__natural__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__natural

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_33 : int) (temp___is_init_30 : bool) (temp___do_constant_31 : bool) (temp___do_toplevel_32 : bool)  =
  (if (( temp___is_init_30 \/ (Standard__natural.first <= Standard__natural.last) )) then (
   (Standard__natural.dynamic_property Standard__natural.first Standard__natural.last temp___expr_33)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___34 : int) (temp___35 : bool)  =
  true

end

(* Module giving axioms for type "positive", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__positive__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__positive

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_39 : int) (temp___is_init_36 : bool) (temp___do_constant_37 : bool) (temp___do_toplevel_38 : bool)  =
  (if (( temp___is_init_36 \/ (Standard__positive.first <= Standard__positive.last) )) then (
   (Standard__positive.dynamic_property Standard__positive.first Standard__positive.last temp___expr_39)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___40 : int) (temp___41 : bool)  =
  true

end

(* Module giving axioms for type "short_float", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__short_float__axiom
 use import "_gnatprove_standard".Main
 use        Standard__short_float

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_45 : Standard__short_float.short_float) (temp___is_init_42 : bool) (temp___do_constant_43 : bool) (temp___do_toplevel_44 : bool)  =
  true
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___46 : Standard__short_float.short_float) (temp___47 : bool)  =
  true

end

(* Module giving axioms for type "float", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__float__axiom
 use import "_gnatprove_standard".Main
 use        Standard__float

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_51 : Standard__float.float) (temp___is_init_48 : bool) (temp___do_constant_49 : bool) (temp___do_toplevel_50 : bool)  =
  true
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___52 : Standard__float.float) (temp___53 : bool)  =
  true

end

(* Module giving axioms for type "long_float", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__long_float__axiom
 use import "_gnatprove_standard".Main
 use        Standard__long_float

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_57 : Standard__long_float.long_float) (temp___is_init_54 : bool) (temp___do_constant_55 : bool) (temp___do_toplevel_56 : bool)  =
  true
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___58 : Standard__long_float.long_float) (temp___59 : bool)  =
  true

end

(* Module giving axioms for type "long_long_float", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__long_long_float__axiom
 use import "_gnatprove_standard".Main
 use        Standard__long_long_float

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_63 : Standard__long_long_float.long_long_float) (temp___is_init_60 : bool) (temp___do_constant_61 : bool) (temp___do_toplevel_62 : bool)  =
  true
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___64 : Standard__long_long_float.long_long_float) (temp___65 : bool)  =
  true

end

(* Module giving axioms for type "character", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__character__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__character

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_69 : int) (temp___is_init_66 : bool) (temp___do_constant_67 : bool) (temp___do_toplevel_68 : bool)  =
  (if (( temp___is_init_66 \/ (Standard__character.first <= Standard__character.last) )) then (
   (Standard__character.dynamic_property Standard__character.first Standard__character.last temp___expr_69)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___70 : int) (temp___71 : bool)  =
  true

end

(* Module giving axioms for type "wide_character", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_character__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__wide_character

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_75 : int) (temp___is_init_72 : bool) (temp___do_constant_73 : bool) (temp___do_toplevel_74 : bool)  =
  (if (( temp___is_init_72 \/ (Standard__wide_character.first <= Standard__wide_character.last) )) then (
   (Standard__wide_character.dynamic_property Standard__wide_character.first Standard__wide_character.last temp___expr_75)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___76 : int) (temp___77 : bool)  =
  true

end

(* Module giving axioms for type "wide_wide_character", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_wide_character__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__wide_wide_character

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_81 : int) (temp___is_init_78 : bool) (temp___do_constant_79 : bool) (temp___do_toplevel_80 : bool)  =
  (if (( temp___is_init_78 \/ (Standard__wide_wide_character.first <= Standard__wide_wide_character.last) )) then (
   (Standard__wide_wide_character.dynamic_property Standard__wide_wide_character.first Standard__wide_wide_character.last temp___expr_81)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___82 : int) (temp___83 : bool)  =
  true

end

(* Module giving axioms for type "string", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__string__axiom
 use import "_gnatprove_standard".Main
 use        Standard__string
 use        Standard__positive

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_87 : Standard__string.string) (temp___is_init_84 : bool) (temp___do_constant_85 : bool) (temp___do_toplevel_86 : bool)  =
  (if (temp___do_constant_85) then (
   true) else (
   (Standard__string.dynamic_property Standard__positive.first Standard__positive.last (Standard__string.first temp___expr_87) (Standard__string.last temp___expr_87))))

end

(* Module giving axioms for type "wide_string", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_string__axiom
 use import "_gnatprove_standard".Main
 use        Standard__positive
 use        Standard__wide_string

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_92 : Standard__wide_string.wide_string) (temp___is_init_89 : bool) (temp___do_constant_90 : bool) (temp___do_toplevel_91 : bool)  =
  (if (temp___do_constant_90) then (
   true) else (
   (Standard__wide_string.dynamic_property Standard__positive.first Standard__positive.last (Standard__wide_string.first temp___expr_92) (Standard__wide_string.last temp___expr_92))))

end

(* Module giving axioms for type "wide_wide_string", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__wide_wide_string__axiom
 use import "_gnatprove_standard".Main
 use        Standard__positive
 use        Standard__wide_wide_string

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_97 : Standard__wide_wide_string.wide_wide_string) (temp___is_init_94 : bool) (temp___do_constant_95 : bool) (temp___do_toplevel_96 : bool)  =
  (if (temp___do_constant_95) then (
   true) else (
   (Standard__wide_wide_string.dynamic_property Standard__positive.first Standard__positive.last (Standard__wide_wide_string.first temp___expr_97) (Standard__wide_wide_string.last temp___expr_97))))

end

(* Module giving axioms for type "duration", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__duration__axiom
 use import "_gnatprove_standard".Main
 use        Standard__duration

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_102 : Standard__duration.duration) (temp___is_init_99 : bool) (temp___do_constant_100 : bool) (temp___do_toplevel_101 : bool)  =
  true
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___103 : Standard__duration.duration) (temp___104 : bool)  =
  true

end

(* Module giving axioms for type "integer_8", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_8__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer_8

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_108 : int) (temp___is_init_105 : bool) (temp___do_constant_106 : bool) (temp___do_toplevel_107 : bool)  =
  (if (( temp___is_init_105 \/ (Standard__integer_8.first <= Standard__integer_8.last) )) then (
   (Standard__integer_8.dynamic_property Standard__integer_8.first Standard__integer_8.last temp___expr_108)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___109 : int) (temp___110 : bool)  =
  true

end

(* Module giving axioms for type "integer_16", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_16__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer_16

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_114 : int) (temp___is_init_111 : bool) (temp___do_constant_112 : bool) (temp___do_toplevel_113 : bool)  =
  (if (( temp___is_init_111 \/ (Standard__integer_16.first <= Standard__integer_16.last) )) then (
   (Standard__integer_16.dynamic_property Standard__integer_16.first Standard__integer_16.last temp___expr_114)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___115 : int) (temp___116 : bool)  =
  true

end

(* Module giving axioms for type "integer_32", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_32__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer_32

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_120 : int) (temp___is_init_117 : bool) (temp___do_constant_118 : bool) (temp___do_toplevel_119 : bool)  =
  (if (( temp___is_init_117 \/ (Standard__integer_32.first <= Standard__integer_32.last) )) then (
   (Standard__integer_32.dynamic_property Standard__integer_32.first Standard__integer_32.last temp___expr_120)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___121 : int) (temp___122 : bool)  =
  true

end

(* Module giving axioms for type "integer_64", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__integer_64__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer_64

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_126 : int) (temp___is_init_123 : bool) (temp___do_constant_124 : bool) (temp___do_toplevel_125 : bool)  =
  (if (( temp___is_init_123 \/ (Standard__integer_64.first <= Standard__integer_64.last) )) then (
   (Standard__integer_64.dynamic_property Standard__integer_64.first Standard__integer_64.last temp___expr_126)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___127 : int) (temp___128 : bool)  =
  true

end

(* Module giving axioms for type "universal_integer", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__universal_integer__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__universal_integer

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_132 : int) (temp___is_init_129 : bool) (temp___do_constant_130 : bool) (temp___do_toplevel_131 : bool)  =
  (if (( temp___is_init_129 \/ (Standard__universal_integer.first <= Standard__universal_integer.last) )) then (
   (Standard__universal_integer.dynamic_property Standard__universal_integer.first Standard__universal_integer.last temp___expr_132)) else true)
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___133 : int) (temp___134 : bool)  =
  true

end

(* Module giving axioms for type "universal_real", created in Gnat2Why.Types.Generate_Type_Completion *)
module Standard__universal_real__axiom
 use import "_gnatprove_standard".Main
 use        Standard__universal_real

 predicate dynamic_invariant #"system.ads" 1 0 0# "inline" 
   (temp___expr_138 : Standard__universal_real.universal_real) (temp___is_init_135 : bool) (temp___do_constant_136 : bool) (temp___do_toplevel_137 : bool)  =
  true
 
 predicate default_initial_assumption #"system.ads" 1 0 0# "inline" 
   (temp___139 : Standard__universal_real.universal_real) (temp___140 : bool)  =
  true

end

(* Module for defining the constant "min_int" defined at system.ads:51, created in Gnat2Why.Decls.Translate_Constant *)
module System__min_int
 use import "_gnatprove_standard".Main

 function min_int #"system.ads" 51 0 0# "model" "model_trace:7423" 
   : int

end

(* Module for defining the constant "max_int" defined at system.ads:52, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_int
 use import "_gnatprove_standard".Main

 function max_int #"system.ads" 52 0 0# "model" "model_trace:7434" 
   : int

end

(* Module for defining the constant "max_binary_modulus" defined at system.ads:54, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_binary_modulus
 use import "_gnatprove_standard".Main

 function max_binary_modulus #"system.ads" 54 0 0# "model" "model_trace:7445" 
   : int

end

(* Module for defining the constant "max_nonbinary_modulus" defined at system.ads:55, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_nonbinary_modulus
 use import "_gnatprove_standard".Main

 function max_nonbinary_modulus #"system.ads" 55 0 0# "model" "model_trace:7458" 
   : int

end

(* Module for defining the constant "max_base_digits" defined at system.ads:57, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_base_digits
 use import "_gnatprove_standard".Main

 function max_base_digits #"system.ads" 57 0 0# "model" "model_trace:7473" 
   : int

end

(* Module for defining the constant "max_digits" defined at system.ads:58, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_digits
 use import "_gnatprove_standard".Main

 function max_digits #"system.ads" 58 0 0# "model" "model_trace:7483" 
   : int

end

(* Module for defining the constant "max_mantissa" defined at system.ads:60, created in Gnat2Why.Decls.Translate_Constant *)
module System__max_mantissa
 use import "_gnatprove_standard".Main

 function max_mantissa #"system.ads" 60 0 0# "model" "model_trace:7493" 
   : int

end

(* Module for defining the constant "fine_delta" defined at system.ads:61, created in Gnat2Why.Decls.Translate_Constant *)
module System__fine_delta
 use import "_gnatprove_standard".Main
 use        Standard__universal_real

 function fine_delta #"system.ads" 61 0 0# 
   : Standard__universal_real.universal_real

end

(* Module for defining the constant "tick" defined at system.ads:63, created in Gnat2Why.Decls.Translate_Constant *)
module System__tick
 use import "_gnatprove_standard".Main
 use        Standard__universal_real

 function tick #"system.ads" 63 0 0# 
   : Standard__universal_real.universal_real

end

(* Module for defining the constant "storage_unit" defined at system.ads:71, created in Gnat2Why.Decls.Translate_Constant *)
module System__storage_unit
 use import "_gnatprove_standard".Main

 function storage_unit #"system.ads" 71 0 0# "model" "model_trace:7544" 
   : int

end

(* Module for defining the constant "word_size" defined at system.ads:72, created in Gnat2Why.Decls.Translate_Constant *)
module System__word_size
 use import "_gnatprove_standard".Main

 function word_size #"system.ads" 72 0 0# "model" "model_trace:7553" 
   : int

end

(* Module for defining the constant "memory_size" defined at system.ads:73, created in Gnat2Why.Decls.Translate_Constant *)
module System__memory_size
 use import "_gnatprove_standard".Main

 function memory_size #"system.ads" 73 0 0# "model" "model_trace:7562" 
   : int

end

(* Module for defining the value of the aggregate at system.ads:166, created in Gnat2Why.Expr.Transform_Aggregate.Generate_Logic_Function *)
module System__underlying_priorities__aggregate_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Standard__integer
 use        Array__Int__Standard__integer
 use        Array__Int__Standard__integer
 use        Array__Int__Standard__integer

 function system__underlying_priorities__aggregate_def #"system.ads" 166 0 0# 
   (temp___142 : int) (temp___143 : int) (temp___144 : int) (temp___145 : int) (temp___146 : int) (temp___147 : int) (temp___148 : int) (temp___149 : int) (temp___150 : int) (temp___151 : int) (temp___152 : int) (temp___153 : int) (temp___154 : int) (temp___155 : int) (temp___156 : int) (temp___157 : int) : Array__Int__Standard__integer.map
 
 axiom def_axiom :
  (forall temp___142 temp___143 temp___144 temp___145 temp___146 temp___147 temp___148 temp___149 temp___150 temp___151 temp___152 temp___153 temp___154 temp___155 temp___156 temp___157 : int.
   (let temp___141 = (system__underlying_priorities__aggregate_def temp___142 temp___143 temp___144 temp___145 temp___146 temp___147 temp___148 temp___149 temp___150 temp___151 temp___152 temp___153 temp___154 temp___155 temp___156 temp___157) in (
    (forall temp___158 : int.
     (if (( (31 <= temp___158) /\ (temp___158 <= 31) )) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___157))) else if (( (21 <= temp___158) /\ (temp___158 <= 30) )) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___156)))  else if ((temp___158 = 20)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___155)))  else if ((temp___158 = 19)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___154)))  else if ((temp___158 = 18)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___153)))  else if ((temp___158 = 17)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___152)))  else if ((temp___158 = 16)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___151)))  else if ((temp___158 = 15)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___150)))  else if ((temp___158 = 14)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___149)))  else if ((temp___158 = 13)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___148)))  else if ((temp___158 = 12)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___147)))  else if ((temp___158 = 11)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___146)))  else if ((temp___158 = 10)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___145)))  else if ((temp___158 = 9)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___144)))  else if ((temp___158 = 8)) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___143)))  else if (( (0 <= temp___158) /\ (temp___158 <= 7) )) then (
      ((Array__Int__Standard__integer.get temp___141 temp___158) = (Standard__integer.of_rep temp___142))) else (
      true)))))
  )

end

(* Module for possibly declaring a logic function for "adjust" defined at s-finroo.ads:42, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__finalization_root__adjust
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "finalize" defined at s-finroo.ads:43, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__finalization_root__finalize
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "initialize" defined at s-finroo.ads:44, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__finalization_root__initialize
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "initialize" defined at a-finali.ads:46, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__finalization__initialize
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "adjust" defined at a-finali.ads:47, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__finalization__adjust
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "finalize" defined at a-finali.ads:48, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__finalization__finalize
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "initialize__2" defined at a-finali.ads:53, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__finalization__initialize__2
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "finalize__2" defined at a-finali.ads:54, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__finalization__finalize__2
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "increment" defined at s-atocou.ads:57, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__atomic_counters__increment
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "initialize" defined at s-atocou.ads:69, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__atomic_counters__initialize
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "increment__2" defined at s-atocou.ads:80, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__atomic_counters__increment__2
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "decrement__3" defined at s-atocou.ads:87, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module System__atomic_counters__decrement__3
 use import "_gnatprove_standard".Main


end

(* Module for defining the constant "count_type_last" defined at a-conhel.ads:39, created in Gnat2Why.Decls.Translate_Constant *)
module Ada__containers__helpers__count_type_last
 use import "_gnatprove_standard".Main

 function count_type_last #"a-conhel.ads" 39 0 0# "model" "model_trace:6691" 
   : int

end

(* Module for possibly declaring a logic function for "read" defined at a-stream.ads:57, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__streams__read
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "write" defined at a-stream.ads:63, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Ada__streams__write
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "addnode" defined at graph.ads:33, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Graph__addnode
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "addedge" defined at graph.ads:38, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Graph__addedge
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "myprint" defined at io.ads:4, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Io__myprint
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "myprintnodes" defined at io.ads:6, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Io__myprintnodes
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "myprintedges" defined at io.ads:7, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Io__myprintedges
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "myprintgraph" defined at io.ads:8, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Io__myprintgraph
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "printnode" defined at io.ads:9, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Io__printnode
 use import "_gnatprove_standard".Main


end

(* Module for possibly declaring a logic function for "printnumber" defined at io.ads:10, created in Gnat2Why.Subprograms.Translate_Subprogram_Spec *)
module Io__printnumber
 use import "_gnatprove_standard".Main


end

(* Module for defining the loop exit exception for the loop "L_1" defined at graph.adb:30, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Graph__findnext__L_1
 use import "_gnatprove_standard".Main

 exception L_1

end

(* Module giving an empty axiom for the entity "L_1" defined at graph.adb:30, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__findnext__L_1__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the loop exit exception for the loop "L_2" defined at graph.adb:58, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Graph__distance__L_2
 use import "_gnatprove_standard".Main

 exception L_2

end

(* Module giving an empty axiom for the entity "L_2" defined at graph.adb:58, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__distance__L_2__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the loop exit exception for the loop "L_3" defined at graph.adb:80, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Graph__diameter__L_3
 use import "_gnatprove_standard".Main

 exception L_3

end

(* Module giving an empty axiom for the entity "L_3" defined at graph.adb:80, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__L_3__axiom
 use import "_gnatprove_standard".Main


end

(* Module for defining the loop exit exception for the loop "L_4" defined at graph.adb:83, created in Gnat2Why.Decls.Translate_Loop_Entity *)
module Graph__diameter__L_4
 use import "_gnatprove_standard".Main

 exception L_4

end

(* Module giving an empty axiom for the entity "L_4" defined at graph.adb:83, created in Gnat2Why.Driver.Translate_Entity.Generate_Empty_Axiom_Theory *)
module Graph__diameter__L_4__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "name" defined at system.ads:46, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__name__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__name

 predicate dynamic_invariant #"graph.adb" 83 0 0# "inline" 
   (temp___expr_162 : int) (temp___is_init_159 : bool) (temp___do_constant_160 : bool) (temp___do_toplevel_161 : bool)  =
  (if (( temp___is_init_159 \/ (System__name.first <= System__name.last) )) then (
   (System__name.dynamic_property System__name.first System__name.last temp___expr_162)) else true)
 
 predicate default_initial_assumption #"system.ads" 46 0 0# "inline" 
   (temp___163 : int) (temp___164 : bool)  =
  true

end

(* Module giving axioms for type "address" defined at system.ads:108, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__address__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__address

 predicate dynamic_invariant #"system.ads" 46 0 0# "inline" 
   (temp___expr_168 : BV32.t) (temp___is_init_165 : bool) (temp___do_constant_166 : bool) (temp___do_toplevel_167 : bool)  =
  (if (( temp___is_init_165 \/ (BV32.ule System__address.first System__address.last) )) then (
   (System__address.dynamic_property System__address.first System__address.last temp___expr_168)) else true)
 
 predicate default_initial_assumption #"system.ads" 108 0 0# "inline" 
   (temp___169 : BV32.t) (temp___170 : bool)  =
  true

end

(* Module giving axioms for type "bit_order" defined at system.ads:91, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__bit_order__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__bit_order

 predicate dynamic_invariant #"system.ads" 108 0 0# "inline" 
   (temp___expr_174 : int) (temp___is_init_171 : bool) (temp___do_constant_172 : bool) (temp___do_toplevel_173 : bool)  =
  (if (( temp___is_init_171 \/ (System__bit_order.first <= System__bit_order.last) )) then (
   (System__bit_order.dynamic_property System__bit_order.first System__bit_order.last temp___expr_174)) else true)
 
 predicate default_initial_assumption #"system.ads" 91 0 0# "inline" 
   (temp___175 : int) (temp___176 : bool)  =
  true

end

(* Module giving axioms for type "any_priority" defined at system.ads:100, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__any_priority__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__any_priority

 predicate dynamic_invariant #"system.ads" 91 0 0# "inline" 
   (temp___expr_180 : int) (temp___is_init_177 : bool) (temp___do_constant_178 : bool) (temp___do_toplevel_179 : bool)  =
  (if (( temp___is_init_177 \/ (System__any_priority.first <= System__any_priority.last) )) then (
   (System__any_priority.dynamic_property System__any_priority.first System__any_priority.last temp___expr_180)) else true)
 
 predicate default_initial_assumption #"system.ads" 100 0 0# "inline" 
   (temp___181 : int) (temp___182 : bool)  =
  true

end

(* Module giving axioms for type "priority" defined at system.ads:101, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__priority__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__priority

 predicate dynamic_invariant #"system.ads" 100 0 0# "inline" 
   (temp___expr_186 : int) (temp___is_init_183 : bool) (temp___do_constant_184 : bool) (temp___do_toplevel_185 : bool)  =
  (if (( temp___is_init_183 \/ (System__priority.first <= System__priority.last) )) then (
   (System__priority.dynamic_property System__priority.first System__priority.last temp___expr_186)) else true)
 
 predicate default_initial_assumption #"system.ads" 101 0 0# "inline" 
   (temp___187 : int) (temp___188 : bool)  =
  true

end

(* Module giving axioms for type "interrupt_priority" defined at system.ads:102, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__interrupt_priority__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__interrupt_priority

 predicate dynamic_invariant #"system.ads" 101 0 0# "inline" 
   (temp___expr_192 : int) (temp___is_init_189 : bool) (temp___do_constant_190 : bool) (temp___do_toplevel_191 : bool)  =
  (if (( temp___is_init_189 \/ (System__interrupt_priority.first <= System__interrupt_priority.last) )) then (
   (System__interrupt_priority.dynamic_property System__interrupt_priority.first System__interrupt_priority.last temp___expr_192)) else true)
 
 predicate default_initial_assumption #"system.ads" 102 0 0# "inline" 
   (temp___193 : int) (temp___194 : bool)  =
  true

end

(* Module giving axioms for type "Tpriorities_mappingB" defined at system.ads:161, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__Tpriorities_mappingB__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "priorities_mapping" defined at system.ads:161, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__priorities_mapping__axiom
 use import "_gnatprove_standard".Main
 use        Array__Int__Standard__integer
 use        Array__Int__Standard__integer

 predicate dynamic_invariant #"system.ads" 102 0 0# "inline" 
   (temp___expr_198 : Array__Int__Standard__integer.map) (temp___is_init_195 : bool) (temp___do_constant_196 : bool) (temp___do_toplevel_197 : bool)  =
  true
 
 predicate default_initial_assumption #"system.ads" 161 0 0# "inline" 
   (temp___200 : Array__Int__Standard__integer.map) (temp___201 : bool)  =
  true

end

(* Module giving axioms for type "T3s" defined at system.ads:166, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__T3s__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "T4s" defined at system.ads:166, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__T4s__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "root_controlled" defined at s-finroo.ads:40, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__finalization_root__root_controlled__axiom
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled

 predicate dynamic_invariant #"system.ads" 161 0 0# "inline" 
   (temp___expr_207 : System__finalization_root__root_controlled.root_controlled) (temp___is_init_204 : bool) (temp___do_constant_205 : bool) (temp___do_toplevel_206 : bool)  =
  true
 
 predicate default_initial_assumption #"s-finroo.ads" 40 0 0# "inline" 
   (temp___208 : System__finalization_root__root_controlled.root_controlled) (temp___209 : bool)  =
  ((System__finalization_root__root_controlled.attr__tag temp___208) = System__finalization_root__root_controlled.__tag)

end

(* Module giving axioms for type "Troot_controlledC" defined at s-finroo.ads:40, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__finalization_root__Troot_controlledC__axiom
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled

 predicate dynamic_invariant #"s-finroo.ads" 40 0 0# "inline" 
   (temp___expr_213 : System__finalization_root__root_controlled.root_controlled) (temp___is_init_210 : bool) (temp___do_constant_211 : bool) (temp___do_toplevel_212 : bool)  =
  true

end

(* Module giving axioms for type "controlled" defined at a-finali.ads:59, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__finalization__controlled__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled

 predicate dynamic_invariant #"s-finroo.ads" 40 0 0# "inline" 
   (temp___expr_217 : Ada__finalization__controlled.controlled) (temp___is_init_214 : bool) (temp___do_constant_215 : bool) (temp___do_toplevel_216 : bool)  =
  true
 
 predicate default_initial_assumption #"a-finali.ads" 59 0 0# "inline" 
   (temp___218 : Ada__finalization__controlled.controlled) (temp___219 : bool)  =
  ((Ada__finalization__controlled.attr__tag temp___218) = Ada__finalization__controlled.__tag)

end

(* Module giving axioms for type "limited_controlled" defined at a-finali.ads:65, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__finalization__limited_controlled__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__limited_controlled

 predicate dynamic_invariant #"a-finali.ads" 59 0 0# "inline" 
   (temp___expr_223 : Ada__finalization__limited_controlled.limited_controlled) (temp___is_init_220 : bool) (temp___do_constant_221 : bool) (temp___do_toplevel_222 : bool)  =
  true
 
 predicate default_initial_assumption #"a-finali.ads" 65 0 0# "inline" 
   (temp___224 : Ada__finalization__limited_controlled.limited_controlled) (temp___225 : bool)  =
  ((Ada__finalization__limited_controlled.attr__tag temp___224) = Ada__finalization__limited_controlled.__tag)

end

(* Module giving axioms for type "TcontrolledC" defined at a-finali.ads:43, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__finalization__TcontrolledC__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled

 predicate dynamic_invariant #"a-finali.ads" 65 0 0# "inline" 
   (temp___expr_229 : Ada__finalization__controlled.controlled) (temp___is_init_226 : bool) (temp___do_constant_227 : bool) (temp___do_toplevel_228 : bool)  =
  true

end

(* Module giving axioms for type "Tlimited_controlledC" defined at a-finali.ads:50, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__finalization__Tlimited_controlledC__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__limited_controlled

 predicate dynamic_invariant #"a-finali.ads" 59 0 0# "inline" 
   (temp___expr_233 : Ada__finalization__limited_controlled.limited_controlled) (temp___is_init_230 : bool) (temp___do_constant_231 : bool) (temp___do_toplevel_232 : bool)  =
  true

end

(* Module giving axioms for type "atomic_unsigned" defined at s-atocou.ads:75, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__atomic_counters__atomic_unsigned__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV32
 use        System__atomic_counters__atomic_unsigned

 predicate dynamic_invariant #"a-finali.ads" 65 0 0# "inline" 
   (temp___expr_237 : BV32.t) (temp___is_init_234 : bool) (temp___do_constant_235 : bool) (temp___do_toplevel_236 : bool)  =
  (if (( temp___is_init_234 \/ (BV32.ule System__atomic_counters__atomic_unsigned.first System__atomic_counters__atomic_unsigned.last) )) then (
   (System__atomic_counters__atomic_unsigned.dynamic_property System__atomic_counters__atomic_unsigned.first System__atomic_counters__atomic_unsigned.last temp___expr_237)) else true)
 
 predicate default_initial_assumption #"s-atocou.ads" 75 0 0# "inline" 
   (temp___238 : BV32.t) (temp___239 : bool)  =
  (temp___238 = (BV32.of_int 0))

end

(* Module giving axioms for type "atomic_counter" defined at s-atocou.ads:102, created in Gnat2Why.Types.Generate_Type_Completion *)
module System__atomic_counters__atomic_counter__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__atomic_counters__atomic_unsigned
 use        System__atomic_counters__atomic_counter

 predicate dynamic_invariant #"s-atocou.ads" 75 0 0# "inline" 
   (temp___expr_243 : System__atomic_counters__atomic_counter.atomic_counter) (temp___is_init_240 : bool) (temp___do_constant_241 : bool) (temp___do_toplevel_242 : bool)  =
  true
 
 predicate default_initial_assumption #"s-atocou.ads" 102 0 0# "inline" 
   (temp___244 : System__atomic_counters__atomic_counter.atomic_counter) (temp___245 : bool)  =
  (if ((System__atomic_counters__atomic_counter.value__pred temp___244)) then (
   ((System__atomic_counters__atomic_unsigned.to_rep (System__atomic_counters__atomic_counter.rec__value (System__atomic_counters__atomic_counter.__split_fields temp___244))) = ( BV32.of_int 1 ))) else true)

end

(* Module giving axioms for type "hash_type" defined at a-contai.ads:19, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__containers__hash_type__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        Ada__containers__hash_type

 predicate dynamic_invariant #"s-atocou.ads" 102 0 0# "inline" 
   (temp___expr_249 : BV32.t) (temp___is_init_246 : bool) (temp___do_constant_247 : bool) (temp___do_toplevel_248 : bool)  =
  (if (( temp___is_init_246 \/ (BV32.ule Ada__containers__hash_type.first Ada__containers__hash_type.last) )) then (
   (Ada__containers__hash_type.dynamic_property Ada__containers__hash_type.first Ada__containers__hash_type.last temp___expr_249)) else true)
 
 predicate default_initial_assumption #"a-contai.ads" 19 0 0# "inline" 
   (temp___250 : BV32.t) (temp___251 : bool)  =
  true

end

(* Module giving axioms for type "Tcount_typeB" defined at a-contai.ads:20, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__containers__Tcount_typeB__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "count_type" defined at a-contai.ads:20, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__containers__count_type__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type

 predicate dynamic_invariant #"a-contai.ads" 19 0 0# "inline" 
   (temp___expr_255 : int) (temp___is_init_252 : bool) (temp___do_constant_253 : bool) (temp___do_toplevel_254 : bool)  =
  (if (( temp___is_init_252 \/ (Ada__containers__count_type.first <= Ada__containers__count_type.last) )) then (
   (Ada__containers__count_type.dynamic_property Ada__containers__count_type.first Ada__containers__count_type.last temp___expr_255)) else true)
 
 predicate default_initial_assumption #"a-contai.ads" 20 0 0# "inline" 
   (temp___256 : int) (temp___257 : bool)  =
  true

end

(* Module giving axioms for type "tamper_counts" defined at a-conhel.ads:43, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__containers__helpers__tamper_counts__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__atomic_counters__atomic_unsigned
 use        Ada__containers__helpers__tamper_counts

 predicate dynamic_invariant #"a-contai.ads" 20 0 0# "inline" 
   (temp___expr_261 : Ada__containers__helpers__tamper_counts.tamper_counts) (temp___is_init_258 : bool) (temp___do_constant_259 : bool) (temp___do_toplevel_260 : bool)  =
  true
 
 predicate default_initial_assumption #"a-conhel.ads" 43 0 0# "inline" 
   (temp___262 : Ada__containers__helpers__tamper_counts.tamper_counts) (temp___263 : bool)  =
  ( (if ((Ada__containers__helpers__tamper_counts.busy__pred temp___262)) then (
   ((System__atomic_counters__atomic_unsigned.to_rep (Ada__containers__helpers__tamper_counts.rec__busy (Ada__containers__helpers__tamper_counts.__split_fields temp___262))) = ( BV32.of_int 0 ))) else true) /\ (if ((Ada__containers__helpers__tamper_counts.lock__pred temp___262)) then (
   ((System__atomic_counters__atomic_unsigned.to_rep (Ada__containers__helpers__tamper_counts.rec__lock (Ada__containers__helpers__tamper_counts.__split_fields temp___262))) = ( BV32.of_int 0 ))) else true) )

end

(* Module giving axioms for type "color_type" defined at a-crbltr.ads:37, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__containers__red_black_trees__color_type__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__red_black_trees__color_type

 predicate dynamic_invariant #"a-conhel.ads" 43 0 0# "inline" 
   (temp___expr_267 : int) (temp___is_init_264 : bool) (temp___do_constant_265 : bool) (temp___do_toplevel_266 : bool)  =
  (if (( temp___is_init_264 \/ (Ada__containers__red_black_trees__color_type.first <= Ada__containers__red_black_trees__color_type.last) )) then (
   (Ada__containers__red_black_trees__color_type.dynamic_property Ada__containers__red_black_trees__color_type.first Ada__containers__red_black_trees__color_type.last temp___expr_267)) else true)
 
 predicate default_initial_assumption #"a-crbltr.ads" 37 0 0# "inline" 
   (temp___268 : int) (temp___269 : bool)  =
  true

end

(* Module giving axioms for type "root_stream_type" defined at a-stream.ads:70, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__streams__root_stream_type__axiom
 use import "_gnatprove_standard".Main
 use        Ada__streams__root_stream_type

 predicate dynamic_invariant #"a-crbltr.ads" 37 0 0# "inline" 
   (temp___expr_273 : Ada__streams__root_stream_type.root_stream_type) (temp___is_init_270 : bool) (temp___do_constant_271 : bool) (temp___do_toplevel_272 : bool)  =
  true
 
 predicate default_initial_assumption #"a-stream.ads" 70 0 0# "inline" 
   (temp___274 : Ada__streams__root_stream_type.root_stream_type) (temp___275 : bool)  =
  ((Ada__streams__root_stream_type.attr__tag temp___274) = Ada__streams__root_stream_type.__tag)

end

(* Module giving axioms for type "stream_element" defined at a-stream.ads:42, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__streams__stream_element__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV8
 use        Ada__streams__stream_element

 predicate dynamic_invariant #"a-stream.ads" 70 0 0# "inline" 
   (temp___expr_279 : BV8.t) (temp___is_init_276 : bool) (temp___do_constant_277 : bool) (temp___do_toplevel_278 : bool)  =
  (if (( temp___is_init_276 \/ (BV8.ule Ada__streams__stream_element.first Ada__streams__stream_element.last) )) then (
   (Ada__streams__stream_element.dynamic_property Ada__streams__stream_element.first Ada__streams__stream_element.last temp___expr_279)) else true)
 
 predicate default_initial_assumption #"a-stream.ads" 42 0 0# "inline" 
   (temp___280 : BV8.t) (temp___281 : bool)  =
  true

end

(* Module giving axioms for type "Tstream_element_offsetB" defined at a-stream.ads:44, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__streams__Tstream_element_offsetB__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "stream_element_offset" defined at a-stream.ads:44, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__streams__stream_element_offset__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__streams__stream_element_offset

 predicate dynamic_invariant #"a-stream.ads" 42 0 0# "inline" 
   (temp___expr_285 : int) (temp___is_init_282 : bool) (temp___do_constant_283 : bool) (temp___do_toplevel_284 : bool)  =
  (if (( temp___is_init_282 \/ (Ada__streams__stream_element_offset.first <= Ada__streams__stream_element_offset.last) )) then (
   (Ada__streams__stream_element_offset.dynamic_property Ada__streams__stream_element_offset.first Ada__streams__stream_element_offset.last temp___expr_285)) else true)
 
 predicate default_initial_assumption #"a-stream.ads" 44 0 0# "inline" 
   (temp___286 : int) (temp___287 : bool)  =
  true

end

(* Module giving axioms for type "stream_element_count" defined at a-stream.ads:51, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__streams__stream_element_count__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__streams__stream_element_count

 predicate dynamic_invariant #"a-stream.ads" 44 0 0# "inline" 
   (temp___expr_291 : int) (temp___is_init_288 : bool) (temp___do_constant_289 : bool) (temp___do_toplevel_290 : bool)  =
  (if (( temp___is_init_288 \/ (Ada__streams__stream_element_count.first <= Ada__streams__stream_element_count.last) )) then (
   (Ada__streams__stream_element_count.dynamic_property Ada__streams__stream_element_count.first Ada__streams__stream_element_count.last temp___expr_291)) else true)
 
 predicate default_initial_assumption #"a-stream.ads" 51 0 0# "inline" 
   (temp___292 : int) (temp___293 : bool)  =
  true

end

(* Module giving axioms for type "stream_element_array" defined at a-stream.ads:54, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__streams__stream_element_array__axiom
 use import "_gnatprove_standard".Main
 use        Ada__streams__stream_element_offset
 use        Ada__streams__stream_element_array

 predicate dynamic_invariant #"a-stream.ads" 51 0 0# "inline" 
   (temp___expr_297 : Ada__streams__stream_element_array.stream_element_array) (temp___is_init_294 : bool) (temp___do_constant_295 : bool) (temp___do_toplevel_296 : bool)  =
  (if (temp___do_constant_295) then (
   true) else (
   (Ada__streams__stream_element_array.dynamic_property Ada__streams__stream_element_offset.first Ada__streams__stream_element_offset.last (Ada__streams__stream_element_array.first temp___expr_297) (Ada__streams__stream_element_array.last temp___expr_297))))

end

(* Module giving axioms for type "Troot_stream_typeC" defined at a-stream.ads:39, created in Gnat2Why.Types.Generate_Type_Completion *)
module Ada__streams__Troot_stream_typeC__axiom
 use import "_gnatprove_standard".Main
 use        Ada__streams__root_stream_type

 predicate dynamic_invariant #"a-stream.ads" 54 0 0# "inline" 
   (temp___expr_303 : Ada__streams__root_stream_type.root_stream_type) (temp___is_init_300 : bool) (temp___do_constant_301 : bool) (temp___do_toplevel_302 : bool)  =
  true

end

(* Module giving axioms for type "TnodeB" defined at graph.ads:7, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__TnodeB__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "node" defined at graph.ads:7, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__node__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Graph__node

 predicate dynamic_invariant #"a-stream.ads" 70 0 0# "inline" 
   (temp___expr_307 : int) (temp___is_init_304 : bool) (temp___do_constant_305 : bool) (temp___do_toplevel_306 : bool)  =
  (if (( temp___is_init_304 \/ (Graph__node.first <= Graph__node.last) )) then (
   (Graph__node.dynamic_property Graph__node.first Graph__node.last temp___expr_307)) else true)
 
 predicate default_initial_assumption #"graph.ads" 7 0 0# "inline" 
   (temp___308 : int) (temp___309 : bool)  =
  true

end

(* Module giving axioms for type "edge" defined at graph.ads:8, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__edge__axiom
 use import "_gnatprove_standard".Main
 use        Graph__edge

 predicate dynamic_invariant #"graph.ads" 7 0 0# "inline" 
   (temp___expr_313 : Graph__edge.edge) (temp___is_init_310 : bool) (temp___do_constant_311 : bool) (temp___do_toplevel_312 : bool)  =
  true
 
 predicate default_initial_assumption #"graph.ads" 8 0 0# "inline" 
   (temp___314 : Graph__edge.edge) (temp___315 : bool)  =
  true

end

(* Module giving axioms for the type entity "graphnode" defined at graph.ads:21, created in Gnat2Why.External_Axioms.Complete_External_Entities *)
module Graph__graphnode__element_type__axiom
 use export Graph__node__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "set" defined at a-cforse.ads:78 instantiated at graph.ads:21, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__graphnode__set__axiom
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__set

 predicate dynamic_invariant #"graph.ads" 8 0 0# "inline" 
   (temp___expr_321 : Graph__graphnode__set.set) (temp___is_init_318 : bool) (temp___do_constant_319 : bool) (temp___do_toplevel_320 : bool)  =
  true

end

(* Module giving axioms for type "cursor" defined at a-cforse.ads:86 instantiated at graph.ads:21, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__graphnode__cursor__axiom
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__cursor

 predicate dynamic_invariant #"a-cforse.ads" 78 0 0# "inline" 
   (temp___expr_326 : Graph__graphnode__cursor.cursor) (temp___is_init_323 : bool) (temp___do_constant_324 : bool) (temp___do_toplevel_325 : bool)  =
  true
 
 predicate default_initial_assumption #"a-cforse.ads" 86 0 0# "inline" 
   (temp___327 : Graph__graphnode__cursor.cursor) (temp___328 : bool)  =
  true

end

(* Module giving axioms for the type entity "graphedge" defined at graph.ads:25, created in Gnat2Why.External_Axioms.Complete_External_Entities *)
module Graph__graphedge__element_type__axiom
 use export Graph__edge__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "set" defined at a-cforse.ads:78 instantiated at graph.ads:25, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__graphedge__set__axiom
 use import "_gnatprove_standard".Main
 use        Graph__graphedge__set

 predicate dynamic_invariant #"a-cforse.ads" 86 0 0# "inline" 
   (temp___expr_332 : Graph__graphedge__set.set) (temp___is_init_329 : bool) (temp___do_constant_330 : bool) (temp___do_toplevel_331 : bool)  =
  true

end

(* Module giving axioms for type "cursor" defined at a-cforse.ads:86 instantiated at graph.ads:25, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__graphedge__cursor__axiom
 use import "_gnatprove_standard".Main
 use        Graph__graphedge__cursor

 predicate dynamic_invariant #"a-cforse.ads" 78 0 0# "inline" 
   (temp___expr_337 : Graph__graphedge__cursor.cursor) (temp___is_init_334 : bool) (temp___do_constant_335 : bool) (temp___do_toplevel_336 : bool)  =
  true
 
 predicate default_initial_assumption #"a-cforse.ads" 86 0 0# "inline" 
   (temp___338 : Graph__graphedge__cursor.cursor) (temp___339 : bool)  =
  true

end

(* Module giving axioms for type "T95s" defined at graph.ads:29, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__mygraph__T95s__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "T97s" defined at graph.ads:30, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__mygraph__T97s__axiom
 use import "_gnatprove_standard".Main


end

(* Module giving axioms for type "mygraph" defined at graph.ads:28, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__mygraph__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type
 use        Graph__graphnode__set
 use        Graph__graphnode__is_empty
 use        Graph__graphedge__set
 use        Graph__graphedge__is_empty
 use        Graph__mygraph__T95s
 use        Graph__mygraph__T97s
 use        Graph__mygraph

 predicate dynamic_invariant #"a-cforse.ads" 86 0 0# "inline" 
   (temp___expr_343 : Graph__mygraph.mygraph) (temp___is_init_340 : bool) (temp___do_constant_341 : bool) (temp___do_toplevel_342 : bool)  =
  ( (if ((Graph__mygraph.gnode__pred temp___expr_343)) then (
   (let temp___344 = (Graph__graphnode__set.rec__capacity (Graph__mygraph__T95s.__split_discrs (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields temp___expr_343)))) in (
    (if (False) then (
     true) else (
     (Graph__mygraph__T95s.in_range 20 (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields temp___expr_343))))))))
  ) else true) /\ (if ((Graph__mygraph.gedge__pred temp___expr_343)) then (
   (let temp___345 = (Graph__graphedge__set.rec__capacity (Graph__mygraph__T97s.__split_discrs (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields temp___expr_343)))) in (
    (if (False) then (
     true) else (
     (Graph__mygraph__T97s.in_range 20 (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields temp___expr_343))))))))
  ) else true) )
 
 predicate default_initial_assumption #"graph.ads" 28 0 0# "inline" 
   (temp___346 : Graph__mygraph.mygraph) (temp___347 : bool)  =
  ( (if ((Graph__mygraph.gnode__pred temp___346)) then (
   (let temp___348 = (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields temp___346)) in (
    ( (let temp___349 = (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__mygraph__T95s.__split_discrs temp___348))) in (
     ((Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__mygraph__T95s.__split_discrs temp___348))) = 20)))
     /\ (if (False) then (
     true) else (
     (let temp___350 = temp___348 in (
      ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base temp___350)) = True)))
    )) )))
  ) else true) /\ (if ((Graph__mygraph.gedge__pred temp___346)) then (
   (let temp___351 = (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields temp___346)) in (
    ( (let temp___352 = (Ada__containers__count_type.to_rep (Graph__graphedge__set.rec__capacity (Graph__mygraph__T97s.__split_discrs temp___351))) in (
     ((Ada__containers__count_type.to_rep (Graph__graphedge__set.rec__capacity (Graph__mygraph__T97s.__split_discrs temp___351))) = 20)))
     /\ (if (False) then (
     true) else (
     (let temp___353 = temp___351 in (
      ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base temp___353)) = True)))
    )) )))
  ) else true) )

end

(* Module giving axioms for type "TworkingS" defined at graph.adb:27, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__findnext__TworkingS__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type
 use        Graph__graphnode__set
 use        Graph__graphnode__is_empty
 use        Graph__findnext__TworkingS

 predicate dynamic_invariant #"a-cforse.ads" 78 0 0# "inline" 
   (temp___expr_357 : Graph__findnext__TworkingS.tworkingS) (temp___is_init_354 : bool) (temp___do_constant_355 : bool) (temp___do_toplevel_356 : bool)  =
  (let temp___358 = (Graph__graphnode__set.rec__capacity (Graph__findnext__TworkingS.__split_discrs temp___expr_357)) in (
   (if (temp___do_constant_355) then (
    true) else (
    (Graph__findnext__TworkingS.in_range 10 (Graph__findnext__TworkingS.to_base temp___expr_357))))))

 
 predicate default_initial_assumption #"graph.adb" 27 0 0# "inline" 
   (temp___359 : Graph__findnext__TworkingS.tworkingS) (temp___360 : bool)  =
  ( (let temp___361 = (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__findnext__TworkingS.__split_discrs temp___359))) in (
   ((Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__findnext__TworkingS.__split_discrs temp___359))) = 10)))
   /\ (if (temp___360) then (
   true) else (
   (let temp___362 = temp___359 in (
    ((Graph__graphnode__is_empty.is_empty__logic (Graph__findnext__TworkingS.to_base temp___362)) = True)))
  )) )

end

(* Module giving axioms for type "TreachS" defined at graph.adb:47, created in Gnat2Why.Types.Generate_Type_Completion *)
module Graph__distance__TreachS__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type
 use        Graph__graphnode__set
 use        Graph__graphnode__is_empty
 use        Graph__distance__TreachS

 predicate dynamic_invariant #"a-cforse.ads" 78 0 0# "inline" 
   (temp___expr_366 : Graph__distance__TreachS.treachS) (temp___is_init_363 : bool) (temp___do_constant_364 : bool) (temp___do_toplevel_365 : bool)  =
  (let temp___367 = (Graph__graphnode__set.rec__capacity (Graph__distance__TreachS.__split_discrs temp___expr_366)) in (
   (if (temp___do_constant_364) then (
    true) else (
    (Graph__distance__TreachS.in_range 10 (Graph__distance__TreachS.to_base temp___expr_366))))))

 
 predicate default_initial_assumption #"graph.adb" 47 0 0# "inline" 
   (temp___368 : Graph__distance__TreachS.treachS) (temp___369 : bool)  =
  ( (let temp___370 = (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__distance__TreachS.__split_discrs temp___368))) in (
   ((Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__distance__TreachS.__split_discrs temp___368))) = 10)))
   /\ (if (temp___369) then (
   true) else (
   (let temp___371 = temp___368 in (
    ((Graph__graphnode__is_empty.is_empty__logic (Graph__distance__TreachS.to_base temp___371)) = True)))
  )) )

end
(* Module for defining the value of constant "system_name" defined at system.ads:47, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__system_name__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__system_name

 axiom system_name__def_axiom :
  ((System__system_name.system_name ) = 0)

end

(* Module for defining the value of constant "min_int" defined at system.ads:51, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__min_int__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__min_int

 axiom min_int__def_axiom :
  ((System__min_int.min_int ) = ( -9223372036854775808 ))

end

(* Module for defining the value of constant "max_int" defined at system.ads:52, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_int__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_int

 axiom max_int__def_axiom :
  ((System__max_int.max_int ) = 9223372036854775807)

end

(* Module for defining the value of constant "max_binary_modulus" defined at system.ads:54, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_binary_modulus__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_binary_modulus

 axiom max_binary_modulus__def_axiom :
  ((System__max_binary_modulus.max_binary_modulus ) = 18446744073709551616)

end

(* Module for defining the value of constant "max_nonbinary_modulus" defined at system.ads:55, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_nonbinary_modulus__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_nonbinary_modulus

 axiom max_nonbinary_modulus__def_axiom :
  ((System__max_nonbinary_modulus.max_nonbinary_modulus ) = 4294967295)

end

(* Module for defining the value of constant "max_base_digits" defined at system.ads:57, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_base_digits__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_base_digits

 axiom max_base_digits__def_axiom :
  ((System__max_base_digits.max_base_digits ) = 18)

end

(* Module for defining the value of constant "max_digits" defined at system.ads:58, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_digits__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_digits

 axiom max_digits__def_axiom :
  ((System__max_digits.max_digits ) = 18)

end

(* Module for defining the value of constant "max_mantissa" defined at system.ads:60, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_mantissa__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_mantissa

 axiom max_mantissa__def_axiom :
  ((System__max_mantissa.max_mantissa ) = 63)

end

(* Module for defining the value of constant "fine_delta" defined at system.ads:61, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__fine_delta__axiom
 use import "_gnatprove_standard".Main
 use import "real".RealInfix
 use        Standard__universal_real
 use        System__fine_delta

 axiom fine_delta__def_axiom :
  ((System__fine_delta.fine_delta ) = (Standard__universal_real.of_real (0.000000000000000000108420217248550443400745280086994171142578125)))

end

(* Module for defining the value of constant "tick" defined at system.ads:63, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__tick__axiom
 use import "_gnatprove_standard".Main
 use import "real".RealInfix
 use        Standard__universal_real
 use        System__tick

 axiom tick__def_axiom :
  ((System__tick.tick ) = (Standard__universal_real.of_real (1.0E-2)))

end

(* Module for defining the value of constant "storage_unit" defined at system.ads:71, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__storage_unit__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__storage_unit

 axiom storage_unit__def_axiom :
  ((System__storage_unit.storage_unit ) = 8)

end

(* Module for defining the value of constant "word_size" defined at system.ads:72, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__word_size__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__word_size

 axiom word_size__def_axiom :
  ((System__word_size.word_size ) = 32)

end

(* Module for defining the value of constant "memory_size" defined at system.ads:73, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__memory_size__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__memory_size

 axiom memory_size__def_axiom :
  ((System__memory_size.memory_size ) = 4294967296)

end

(* Module for defining the value of constant "default_bit_order" defined at system.ads:92, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__default_bit_order__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__default_bit_order

 axiom default_bit_order__def_axiom :
  ((System__default_bit_order.default_bit_order ) = 1)

end

(* Module for defining the value of constant "max_priority" defined at system.ads:97, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_priority__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_priority

 axiom max_priority__def_axiom :
  ((System__max_priority.max_priority ) = 30)

end

(* Module for defining the value of constant "max_interrupt_priority" defined at system.ads:98, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__max_interrupt_priority__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__max_interrupt_priority

 axiom max_interrupt_priority__def_axiom :
  ((System__max_interrupt_priority.max_interrupt_priority ) = 31)

end

(* Module for defining the value of constant "default_priority" defined at system.ads:104, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__default_priority__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__default_priority

 axiom default_priority__def_axiom :
  ((System__default_priority.default_priority ) = 15)

end

(* Module for defining the value of constant "null_address" defined at system.ads:109, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__null_address__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".BV32
 use        System__null_address

 axiom null_address__def_axiom :
  ((System__null_address.null_address ) = (BV32.of_int 0))

end

(* Module for defining the value of constant "backend_divide_checks" defined at system.ads:121, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__backend_divide_checks__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__backend_divide_checks

 axiom backend_divide_checks__def_axiom :
  ((System__backend_divide_checks.backend_divide_checks ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "backend_overflow_checks" defined at system.ads:122, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__backend_overflow_checks__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__backend_overflow_checks

 axiom backend_overflow_checks__def_axiom :
  ((System__backend_overflow_checks.backend_overflow_checks ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "command_line_args" defined at system.ads:123, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__command_line_args__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__command_line_args

 axiom command_line_args__def_axiom :
  ((System__command_line_args.command_line_args ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "configurable_run_time" defined at system.ads:124, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__configurable_run_time__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__configurable_run_time

 axiom configurable_run_time__def_axiom :
  ((System__configurable_run_time.configurable_run_time ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "denorm" defined at system.ads:125, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__denorm__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__denorm

 axiom denorm__def_axiom :
  ((System__denorm.denorm ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "duration_32_bits" defined at system.ads:126, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__duration_32_bits__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__duration_32_bits

 axiom duration_32_bits__def_axiom :
  ((System__duration_32_bits.duration_32_bits ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "exit_status_supported" defined at system.ads:127, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__exit_status_supported__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__exit_status_supported

 axiom exit_status_supported__def_axiom :
  ((System__exit_status_supported.exit_status_supported ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "fractional_fixed_ops" defined at system.ads:128, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__fractional_fixed_ops__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__fractional_fixed_ops

 axiom fractional_fixed_ops__def_axiom :
  ((System__fractional_fixed_ops.fractional_fixed_ops ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "frontend_layout" defined at system.ads:129, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__frontend_layout__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__frontend_layout

 axiom frontend_layout__def_axiom :
  ((System__frontend_layout.frontend_layout ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "machine_overflows" defined at system.ads:130, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__machine_overflows__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__machine_overflows

 axiom machine_overflows__def_axiom :
  ((System__machine_overflows.machine_overflows ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "machine_rounds" defined at system.ads:131, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__machine_rounds__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__machine_rounds

 axiom machine_rounds__def_axiom :
  ((System__machine_rounds.machine_rounds ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "preallocated_stacks" defined at system.ads:132, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__preallocated_stacks__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__preallocated_stacks

 axiom preallocated_stacks__def_axiom :
  ((System__preallocated_stacks.preallocated_stacks ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "signed_zeros" defined at system.ads:133, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__signed_zeros__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__signed_zeros

 axiom signed_zeros__def_axiom :
  ((System__signed_zeros.signed_zeros ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "stack_check_default" defined at system.ads:134, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__stack_check_default__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__stack_check_default

 axiom stack_check_default__def_axiom :
  ((System__stack_check_default.stack_check_default ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "stack_check_probes" defined at system.ads:135, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__stack_check_probes__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__stack_check_probes

 axiom stack_check_probes__def_axiom :
  ((System__stack_check_probes.stack_check_probes ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "stack_check_limits" defined at system.ads:136, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__stack_check_limits__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__stack_check_limits

 axiom stack_check_limits__def_axiom :
  ((System__stack_check_limits.stack_check_limits ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "support_aggregates" defined at system.ads:137, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__support_aggregates__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__support_aggregates

 axiom support_aggregates__def_axiom :
  ((System__support_aggregates.support_aggregates ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "support_atomic_primitives" defined at system.ads:138, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__support_atomic_primitives__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__support_atomic_primitives

 axiom support_atomic_primitives__def_axiom :
  ((System__support_atomic_primitives.support_atomic_primitives ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "support_composite_assign" defined at system.ads:139, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__support_composite_assign__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__support_composite_assign

 axiom support_composite_assign__def_axiom :
  ((System__support_composite_assign.support_composite_assign ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "support_composite_compare" defined at system.ads:140, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__support_composite_compare__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__support_composite_compare

 axiom support_composite_compare__def_axiom :
  ((System__support_composite_compare.support_composite_compare ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "support_long_shifts" defined at system.ads:141, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__support_long_shifts__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__support_long_shifts

 axiom support_long_shifts__def_axiom :
  ((System__support_long_shifts.support_long_shifts ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "always_compatible_rep" defined at system.ads:142, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__always_compatible_rep__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__always_compatible_rep

 axiom always_compatible_rep__def_axiom :
  ((System__always_compatible_rep.always_compatible_rep ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "suppress_standard_library" defined at system.ads:143, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__suppress_standard_library__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__suppress_standard_library

 axiom suppress_standard_library__def_axiom :
  ((System__suppress_standard_library.suppress_standard_library ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "use_ada_main_program_name" defined at system.ads:144, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__use_ada_main_program_name__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__use_ada_main_program_name

 axiom use_ada_main_program_name__def_axiom :
  ((System__use_ada_main_program_name.use_ada_main_program_name ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "frontend_exceptions" defined at system.ads:145, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__frontend_exceptions__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__frontend_exceptions

 axiom frontend_exceptions__def_axiom :
  ((System__frontend_exceptions.frontend_exceptions ) = (Boolean.of_int 0))

end

(* Module for defining the value of constant "zcx_by_default" defined at system.ads:146, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__zcx_by_default__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        System__zcx_by_default

 axiom zcx_by_default__def_axiom :
  ((System__zcx_by_default.zcx_by_default ) = (Boolean.of_int 1))

end

(* Module for defining the value of constant "underlying_priorities" defined at system.ads:165, created in Gnat2Why.Decls.Translate_Constant_Value *)
module System__underlying_priorities__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        System__underlying_priorities
 use        Array__Int__Standard__integer
 use        System__underlying_priorities__aggregate_def
 use        Array__Int__Standard__integer

 axiom underlying_priorities__def_axiom :
  ((System__underlying_priorities.underlying_priorities ) = (System__underlying_priorities__aggregate_def.system__underlying_priorities__aggregate_def ( -15 ) ( -7 ) ( -6 ) ( -5 ) ( -4 ) ( -3 ) ( -2 ) ( -1 ) 0 1 2 3 4 5 6 15))

end

(* Module for defining the value of constant "count_type_last" defined at a-conhel.ads:39, created in Gnat2Why.Decls.Translate_Constant_Value *)
module Ada__containers__helpers__count_type_last__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__helpers__count_type_last

 axiom count_type_last__def_axiom :
  ((Ada__containers__helpers__count_type_last.count_type_last ) = 2147483647)

end

(* Module for declaring a program function (and possibly an axiom) for "Olt" defined at system.ads:77, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__Olt__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__Olt

 val olt #"system.ads" 77 0 0# 
   (left : BV32.t) (right : BV32.t) : bool
  requires { true }
  ensures { (result = (System__Olt.olt left right)) }

end

(* Module for declaring a program function (and possibly an axiom) for "Ole" defined at system.ads:78, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__Ole__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__Ole

 val ole #"system.ads" 78 0 0# 
   (left : BV32.t) (right : BV32.t) : bool
  requires { true }
  ensures { (result = (System__Ole.ole left right)) }

end

(* Module for declaring a program function (and possibly an axiom) for "Ogt" defined at system.ads:79, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__Ogt__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__Ogt

 val ogt #"system.ads" 79 0 0# 
   (left : BV32.t) (right : BV32.t) : bool
  requires { true }
  ensures { (result = (System__Ogt.ogt left right)) }

end

(* Module for declaring a program function (and possibly an axiom) for "Oge" defined at system.ads:80, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__Oge__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__Oge

 val oge #"system.ads" 80 0 0# 
   (left : BV32.t) (right : BV32.t) : bool
  requires { true }
  ensures { (result = (System__Oge.oge left right)) }

end

(* Module for declaring a program function (and possibly an axiom) for "Oeq" defined at system.ads:81, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__Oeq__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__Oeq

 val oeq #"system.ads" 81 0 0# 
   (left : BV32.t) (right : BV32.t) : bool
  requires { true }
  ensures { (result = (System__Oeq.oeq left right)) }

end

(* Module for declaring a program function (and possibly an axiom) for "adjust" defined at s-finroo.ads:42, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__finalization_root__adjust__axiom
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled
 use        System__finalization_root__root_controlled__axiom

 val adjust #"s-finroo.ads" 42 0 0# 
   (object__split_fields : System__finalization_root__root_controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (System__finalization_root__root_controlled__axiom.dynamic_invariant { System__finalization_root__root_controlled.__split_fields = object__split_fields.System__finalization_root__root_controlled.__split_fields__content; System__finalization_root__root_controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val adjust #"s-finroo.ads" 42 0 0# 
    (object__split_fields : System__finalization_root__root_controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (System__finalization_root__root_controlled__axiom.dynamic_invariant { System__finalization_root__root_controlled.__split_fields = object__split_fields.System__finalization_root__root_controlled.__split_fields__content; System__finalization_root__root_controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "finalize" defined at s-finroo.ads:43, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__finalization_root__finalize__axiom
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled
 use        System__finalization_root__root_controlled__axiom

 val finalize #"s-finroo.ads" 43 0 0# 
   (object__split_fields : System__finalization_root__root_controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (System__finalization_root__root_controlled__axiom.dynamic_invariant { System__finalization_root__root_controlled.__split_fields = object__split_fields.System__finalization_root__root_controlled.__split_fields__content; System__finalization_root__root_controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val finalize #"s-finroo.ads" 43 0 0# 
    (object__split_fields : System__finalization_root__root_controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (System__finalization_root__root_controlled__axiom.dynamic_invariant { System__finalization_root__root_controlled.__split_fields = object__split_fields.System__finalization_root__root_controlled.__split_fields__content; System__finalization_root__root_controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "initialize" defined at s-finroo.ads:44, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__finalization_root__initialize__axiom
 use import "_gnatprove_standard".Main
 use        System__finalization_root__root_controlled
 use        System__finalization_root__root_controlled__axiom

 val initialize #"s-finroo.ads" 44 0 0# 
   (object__split_fields : System__finalization_root__root_controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (System__finalization_root__root_controlled__axiom.dynamic_invariant { System__finalization_root__root_controlled.__split_fields = object__split_fields.System__finalization_root__root_controlled.__split_fields__content; System__finalization_root__root_controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val initialize #"s-finroo.ads" 44 0 0# 
    (object__split_fields : System__finalization_root__root_controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (System__finalization_root__root_controlled__axiom.dynamic_invariant { System__finalization_root__root_controlled.__split_fields = object__split_fields.System__finalization_root__root_controlled.__split_fields__content; System__finalization_root__root_controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "initialize" defined at a-finali.ads:46, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__finalization__initialize__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled
 use        Ada__finalization__controlled__axiom

 val initialize #"a-finali.ads" 46 0 0# 
   (object__split_fields : Ada__finalization__controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (Ada__finalization__controlled__axiom.dynamic_invariant { Ada__finalization__controlled.__split_fields = object__split_fields.Ada__finalization__controlled.__split_fields__content; Ada__finalization__controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val initialize #"a-finali.ads" 46 0 0# 
    (object__split_fields : Ada__finalization__controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (Ada__finalization__controlled__axiom.dynamic_invariant { Ada__finalization__controlled.__split_fields = object__split_fields.Ada__finalization__controlled.__split_fields__content; Ada__finalization__controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "adjust" defined at a-finali.ads:47, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__finalization__adjust__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled
 use        Ada__finalization__controlled__axiom

 val adjust #"a-finali.ads" 47 0 0# 
   (object__split_fields : Ada__finalization__controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (Ada__finalization__controlled__axiom.dynamic_invariant { Ada__finalization__controlled.__split_fields = object__split_fields.Ada__finalization__controlled.__split_fields__content; Ada__finalization__controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val adjust #"a-finali.ads" 47 0 0# 
    (object__split_fields : Ada__finalization__controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (Ada__finalization__controlled__axiom.dynamic_invariant { Ada__finalization__controlled.__split_fields = object__split_fields.Ada__finalization__controlled.__split_fields__content; Ada__finalization__controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "finalize" defined at a-finali.ads:48, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__finalization__finalize__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__controlled
 use        Ada__finalization__controlled__axiom

 val finalize #"a-finali.ads" 48 0 0# 
   (object__split_fields : Ada__finalization__controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (Ada__finalization__controlled__axiom.dynamic_invariant { Ada__finalization__controlled.__split_fields = object__split_fields.Ada__finalization__controlled.__split_fields__content; Ada__finalization__controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val finalize #"a-finali.ads" 48 0 0# 
    (object__split_fields : Ada__finalization__controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (Ada__finalization__controlled__axiom.dynamic_invariant { Ada__finalization__controlled.__split_fields = object__split_fields.Ada__finalization__controlled.__split_fields__content; Ada__finalization__controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "initialize__2" defined at a-finali.ads:53, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__finalization__initialize__2__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__limited_controlled
 use        Ada__finalization__limited_controlled__axiom

 val initialize__2 #"a-finali.ads" 53 0 0# 
   (object__split_fields : Ada__finalization__limited_controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (Ada__finalization__limited_controlled__axiom.dynamic_invariant { Ada__finalization__limited_controlled.__split_fields = object__split_fields.Ada__finalization__limited_controlled.__split_fields__content; Ada__finalization__limited_controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val initialize__2 #"a-finali.ads" 53 0 0# 
    (object__split_fields : Ada__finalization__limited_controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (Ada__finalization__limited_controlled__axiom.dynamic_invariant { Ada__finalization__limited_controlled.__split_fields = object__split_fields.Ada__finalization__limited_controlled.__split_fields__content; Ada__finalization__limited_controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "finalize__2" defined at a-finali.ads:54, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__finalization__finalize__2__axiom
 use import "_gnatprove_standard".Main
 use        Ada__finalization__limited_controlled
 use        Ada__finalization__limited_controlled__axiom

 val finalize__2 #"a-finali.ads" 54 0 0# 
   (object__split_fields : Ada__finalization__limited_controlled.__split_fields__ref) (object__attr__tag : int) : unit
  requires { true }
  ensures { (Ada__finalization__limited_controlled__axiom.dynamic_invariant { Ada__finalization__limited_controlled.__split_fields = object__split_fields.Ada__finalization__limited_controlled.__split_fields__content; Ada__finalization__limited_controlled.attr__tag = object__attr__tag } True True True) }
  writes {object__split_fields}
 
 namespace Dispatch
  val finalize__2 #"a-finali.ads" 54 0 0# 
    (object__split_fields : Ada__finalization__limited_controlled.__split_fields__ref) (object__attr__tag : int) : unit
   requires { true }
   ensures { (Ada__finalization__limited_controlled__axiom.dynamic_invariant { Ada__finalization__limited_controlled.__split_fields = object__split_fields.Ada__finalization__limited_controlled.__split_fields__content; Ada__finalization__limited_controlled.attr__tag = object__attr__tag } True True True) }
   writes {object__split_fields}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "increment" defined at s-atocou.ads:57, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__atomic_counters__increment__axiom
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter
 use        System__atomic_counters__atomic_counter__axiom

 val increment #"s-atocou.ads" 57 0 0# 
   (item__split_fields : System__atomic_counters__atomic_counter.__split_fields__ref) : unit
  requires { true }
  ensures { (System__atomic_counters__atomic_counter__axiom.dynamic_invariant { System__atomic_counters__atomic_counter.__split_fields = item__split_fields.System__atomic_counters__atomic_counter.__split_fields__content } True True True) }
  writes {item__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "is_one" defined at s-atocou.ads:65, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__atomic_counters__is_one__axiom
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter
 use        System__atomic_counters__is_one

 val is_one #"s-atocou.ads" 65 0 0# 
   (item : System__atomic_counters__atomic_counter.atomic_counter) : bool
  requires { true }
  ensures { (result = (System__atomic_counters__is_one.is_one item)) }

end

(* Module for declaring a program function (and possibly an axiom) for "initialize" defined at s-atocou.ads:69, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__atomic_counters__initialize__axiom
 use import "_gnatprove_standard".Main
 use        System__atomic_counters__atomic_counter
 use        System__atomic_counters__atomic_counter__axiom

 val initialize #"s-atocou.ads" 69 0 0# 
   (item__split_fields : System__atomic_counters__atomic_counter.__split_fields__ref) : unit
  requires { true }
  ensures { (System__atomic_counters__atomic_counter__axiom.dynamic_invariant { System__atomic_counters__atomic_counter.__split_fields = item__split_fields.System__atomic_counters__atomic_counter.__split_fields__content } True True True) }
  writes {item__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "increment__2" defined at s-atocou.ads:80, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__atomic_counters__increment__2__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__atomic_counters__atomic_unsigned__axiom

 val increment__2 #"s-atocou.ads" 80 0 0# 
   (item : BV32.t__ref) : unit
  requires { true }
  ensures { (System__atomic_counters__atomic_unsigned__axiom.dynamic_invariant item.BV32.t__content True True True) }
  writes {item}

end

(* Module for declaring a program function (and possibly an axiom) for "decrement__3" defined at s-atocou.ads:87, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module System__atomic_counters__decrement__3__axiom
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".BV32
 use        System__atomic_counters__atomic_unsigned__axiom

 val decrement__3 #"s-atocou.ads" 87 0 0# 
   (item : BV32.t__ref) : unit
  requires { true }
  ensures { (System__atomic_counters__atomic_unsigned__axiom.dynamic_invariant item.BV32.t__content True True True) }
  writes {item}

end

(* Module for declaring a program function (and possibly an axiom) for "read" defined at a-stream.ads:57, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__streams__read__axiom
 use import "_gnatprove_standard".Main
 use        Ada__streams__root_stream_type
 use        Ada__streams__root_stream_type__axiom
 use        Ada__streams__stream_element_offset
 use        Ada__streams__stream_element_offset__axiom
 use        Ada__streams__stream_element_array
 use        Array__Int__Ada__streams__stream_element

 val read #"a-stream.ads" 57 0 0# 
   (stream__split_fields : Ada__streams__root_stream_type.__split_fields__ref) (stream__attr__tag : int) (item : Array__Int__Ada__streams__stream_element.map__ref) (item__first : int) (item__last : int) (last : int__ref) : unit
  requires { true }
  ensures { ( ( (Ada__streams__root_stream_type__axiom.dynamic_invariant { Ada__streams__root_stream_type.__split_fields = stream__split_fields.Ada__streams__root_stream_type.__split_fields__content; Ada__streams__root_stream_type.attr__tag = stream__attr__tag } True True True) /\ (if (True) then (
   true) else (
   (Ada__streams__stream_element_array.dynamic_property Ada__streams__stream_element_offset.first Ada__streams__stream_element_offset.last item__first item__last))) ) /\ (Ada__streams__stream_element_offset__axiom.dynamic_invariant last.int__content True True True) ) }
  writes {stream__split_fields, item, last}
 
 namespace Dispatch
  val read #"a-stream.ads" 57 0 0# 
    (stream__split_fields : Ada__streams__root_stream_type.__split_fields__ref) (stream__attr__tag : int) (item : Array__Int__Ada__streams__stream_element.map__ref) (item__first : int) (item__last : int) (last : int__ref) : unit
   requires { true }
   ensures { ( ( (Ada__streams__root_stream_type__axiom.dynamic_invariant { Ada__streams__root_stream_type.__split_fields = stream__split_fields.Ada__streams__root_stream_type.__split_fields__content; Ada__streams__root_stream_type.attr__tag = stream__attr__tag } True True True) /\ (if (True) then (
    true) else (
    (Ada__streams__stream_element_array.dynamic_property Ada__streams__stream_element_offset.first Ada__streams__stream_element_offset.last item__first item__last))) ) /\ (Ada__streams__stream_element_offset__axiom.dynamic_invariant last.int__content True True True) ) }
   writes {stream__split_fields, item, last}

 end

end

(* Module for declaring a program function (and possibly an axiom) for "write" defined at a-stream.ads:63, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Ada__streams__write__axiom
 use import "_gnatprove_standard".Main
 use        Ada__streams__root_stream_type
 use        Ada__streams__root_stream_type__axiom
 use        Ada__streams__stream_element_array

 val write #"a-stream.ads" 63 0 0# 
   (stream__split_fields : Ada__streams__root_stream_type.__split_fields__ref) (stream__attr__tag : int) (item : Ada__streams__stream_element_array.stream_element_array) : unit
  requires { true }
  ensures { (Ada__streams__root_stream_type__axiom.dynamic_invariant { Ada__streams__root_stream_type.__split_fields = stream__split_fields.Ada__streams__root_stream_type.__split_fields__content; Ada__streams__root_stream_type.attr__tag = stream__attr__tag } True True True) }
  writes {stream__split_fields}
 
 namespace Dispatch
  val write #"a-stream.ads" 63 0 0# 
    (stream__split_fields : Ada__streams__root_stream_type.__split_fields__ref) (stream__attr__tag : int) (item : Ada__streams__stream_element_array.stream_element_array) : unit
   requires { true }
   ensures { (Ada__streams__root_stream_type__axiom.dynamic_invariant { Ada__streams__root_stream_type.__split_fields = stream__split_fields.Ada__streams__root_stream_type.__split_fields__content; Ada__streams__root_stream_type.attr__tag = stream__attr__tag } True True True) }
   writes {stream__split_fields}

 end

end

(* Module giving a program function and a defining axiom for the expression function "Olt" defined at graph.ads:17, created in Gnat2Why.Subprograms.Translate_Expression_Function_Body *)
module Graph__Olt__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Graph__node
 use        Graph__edge
 use        Graph__Olt

 val olt #"graph.ads" 17 0 0# 
   (e : Graph__edge.edge) (f : Graph__edge.edge) : bool
  requires { true }
  ensures { ( (result = (Graph__Olt.olt e f)) /\ ( (result = True) <-> ( ((Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields e))) < (Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields f)))) \/ ( ((Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields e))) = (Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields f)))) /\ ((Graph__node.to_rep (Graph__edge.rec__to (Graph__edge.__split_fields e))) < (Graph__node.to_rep (Graph__edge.rec__to (Graph__edge.__split_fields f)))) ) ) ) ) }
 
 axiom olt__def_axiom :
  (forall e f : Graph__edge.edge [(Graph__Olt.olt e f)].
   ( ((Graph__Olt.olt e f) = True) <-> ( ((Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields e))) < (Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields f)))) \/ ( ((Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields e))) = (Graph__node.to_rep (Graph__edge.rec__from (Graph__edge.__split_fields f)))) /\ ((Graph__node.to_rep (Graph__edge.rec__to (Graph__edge.__split_fields e))) < (Graph__node.to_rep (Graph__edge.rec__to (Graph__edge.__split_fields f)))) ) ) ))

end

(* Module for declaring a program function (and possibly an axiom) for "addnode" defined at graph.ads:33, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Graph__addnode__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type
 use        Graph__graphnode__set
 use        Graph__graphnode__length
 use        Graph__graphnode__is_empty
 use        Graph__mygraph__T95s
 use        Graph__mygraph
 use        Graph__mygraph__axiom

 val addnode #"graph.ads" 33 0 0# 
   (g__split_fields : Graph__mygraph.__split_fields__ref) (n : int) : unit
  requires { ((Graph__graphnode__length.length__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content })))) < (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__mygraph__T95s.__split_discrs (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content })))))) }
  ensures { ( not ( ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content })))) = True) ) /\ (Graph__mygraph__axiom.dynamic_invariant { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content } True True True) ) }
  writes {g__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "addedge" defined at graph.ads:38, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Graph__addedge__axiom
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type
 use        Graph__graphedge__set
 use        Graph__graphedge__length
 use        Graph__graphedge__is_empty
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__mygraph__axiom

 val addedge #"graph.ads" 38 0 0# 
   (g__split_fields : Graph__mygraph.__split_fields__ref) (from : int) (to__ : int) : unit
  requires { ((Graph__graphedge__length.length__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content })))) < (Ada__containers__count_type.to_rep (Graph__graphedge__set.rec__capacity (Graph__mygraph__T97s.__split_discrs (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content })))))) }
  ensures { ( not ( ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content })))) = True) ) /\ (Graph__mygraph__axiom.dynamic_invariant { Graph__mygraph.__split_fields = g__split_fields.Graph__mygraph.__split_fields__content } True True True) ) }
  writes {g__split_fields}

end

(* Module for declaring a program function (and possibly an axiom) for "findnext" defined at graph.ads:43, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Graph__findnext__axiom
 use import "_gnatprove_standard".Main
 use        Graph__node
 use        Graph__graphnode__set
 use        Graph__graphnode__is_empty
 use        Graph__graphnode__contains
 use        Graph__graphedge__set
 use        Graph__graphedge__is_empty
 use        Graph__mygraph__T95s
 use        Graph__graphnode__set__axiom
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__findnext

 val findnext #"graph.ads" 43 0 0# 
   (n : int) (g : Graph__mygraph.mygraph) : Graph__graphnode__set.set
  requires { ( ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g))) n) = True) /\ ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields g)))) = True) ) }
  ensures { ( (result = (Graph__findnext.findnext n g)) /\ ( (Graph__graphnode__set__axiom.dynamic_invariant result True False True) /\ ((Graph__graphnode__is_empty.is_empty__logic result) = True) ) ) }
 
 axiom findnext__post_axiom :
  (forall n : int.
  (forall g : Graph__mygraph.mygraph [(Graph__findnext.findnext n g)].
   ( ( ( (Graph__node.in_range n) /\ (Graph__mygraph__axiom.dynamic_invariant g True True True) ) /\ ( ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g))) n) = True) /\ ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields g)))) = True) ) ) -> (let result = (Graph__findnext.findnext n g) in (
    ( ((Graph__graphnode__is_empty.is_empty__logic result) = True) /\ (Graph__graphnode__set__axiom.dynamic_invariant result True False True) )))
    )))

end

(* Module for declaring a program function (and possibly an axiom) for "distance" defined at graph.ads:51, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Graph__distance__axiom
 use import "_gnatprove_standard".Main
 use        Standard__integer__axiom
 use        Graph__node
 use        Graph__graphnode__set
 use        Graph__graphnode__contains
 use        Graph__mygraph__T95s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__distance

 val distance #"graph.ads" 51 0 0# 
   (source : int) (target : int) (g : Graph__mygraph.mygraph) : int
  requires { ( ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g))) source) = True) /\ ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g))) target) = True) ) }
  ensures { ( (result = (Graph__distance.distance source target g)) /\ (Standard__integer__axiom.dynamic_invariant result True False True) ) }
 
 axiom distance__post_axiom :
  (forall source target : int.
  (forall g : Graph__mygraph.mygraph [(Graph__distance.distance source target g)].
   ( ( ( ( (Graph__node.in_range source) /\ (Graph__node.in_range target) ) /\ (Graph__mygraph__axiom.dynamic_invariant g True True True) ) /\ ( ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g))) source) = True) /\ ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g))) target) = True) ) ) -> (let result = (Graph__distance.distance source target g) in (
    (Standard__integer__axiom.dynamic_invariant result True False True)))
    )))

end

(* Module for declaring a program function (and possibly an axiom) for "diameter" defined at graph.ads:55, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Graph__diameter__axiom
 use import "_gnatprove_standard".Main
 use        Standard__integer__axiom
 use        Graph__graphnode__set
 use        Graph__graphnode__is_empty
 use        Graph__graphedge__set
 use        Graph__graphedge__is_empty
 use        Graph__mygraph__T95s
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__diameter

 val diameter #"graph.ads" 55 0 0# 
   (g : Graph__mygraph.mygraph) : int
  requires { ( ( ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g)))) = True) <-> false ) /\ ( ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields g)))) = True) <-> false ) ) }
  ensures { ( (result = (Graph__diameter.diameter g)) /\ (Standard__integer__axiom.dynamic_invariant result True False True) ) }
 
 axiom diameter__post_axiom :
  (forall g : Graph__mygraph.mygraph [(Graph__diameter.diameter g)].
   ( ( (Graph__mygraph__axiom.dynamic_invariant g True True True) /\ ( ( ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g)))) = True) <-> false ) /\ ( ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields g)))) = True) <-> false ) ) ) -> (let result = (Graph__diameter.diameter g) in (
    (Standard__integer__axiom.dynamic_invariant result True False True)))
    ))

end

(* Module for declaring a program function (and possibly an axiom) for "small" defined at graph.ads:58, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Graph__small__axiom
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__set
 use        Graph__graphnode__is_empty
 use        Graph__graphedge__set
 use        Graph__graphedge__is_empty
 use        Graph__mygraph__T95s
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__small

 val small #"graph.ads" 58 0 0# 
   (x : int) (g : Graph__mygraph.mygraph) : bool
  requires { ( ( ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields g)))) = True) <-> false ) /\ ( ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields g)))) = True) <-> false ) ) }
  ensures { (result = (Graph__small.small x g)) }

end

(* Module for declaring a program function (and possibly an axiom) for "myprint" defined at io.ads:4, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Io__myprint__axiom
 use import "_gnatprove_standard".Main
 use        Standard__string

 val myprint #"io.ads" 4 0 0# 
   (s : Standard__string.string) : unit
  requires { true }
  ensures { true }

end

(* Module for declaring a program function (and possibly an axiom) for "myprintnodes" defined at io.ads:6, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Io__myprintnodes__axiom
 use import "_gnatprove_standard".Main
 use        Graph__graphnode__set

 val myprintnodes #"io.ads" 6 0 0# 
   (ns : Graph__graphnode__set.set) : unit
  requires { true }
  ensures { true }

end

(* Module for declaring a program function (and possibly an axiom) for "myprintedges" defined at io.ads:7, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Io__myprintedges__axiom
 use import "_gnatprove_standard".Main
 use        Graph__graphedge__set

 val myprintedges #"io.ads" 7 0 0# 
   (es : Graph__graphedge__set.set) : unit
  requires { true }
  ensures { true }

end

(* Module for declaring a program function (and possibly an axiom) for "myprintgraph" defined at io.ads:8, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Io__myprintgraph__axiom
 use import "_gnatprove_standard".Main
 use        Graph__mygraph

 val myprintgraph #"io.ads" 8 0 0# 
   (g : Graph__mygraph.mygraph) : unit
  requires { true }
  ensures { true }

end

(* Module for declaring a program function (and possibly an axiom) for "printnode" defined at io.ads:9, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Io__printnode__axiom
 use import "_gnatprove_standard".Main

 val printnode #"io.ads" 9 0 0# 
   (n : int) : unit
  requires { true }
  ensures { true }

end

(* Module for declaring a program function (and possibly an axiom) for "printnumber" defined at io.ads:10, created in Gnat2Why.Subprograms.Generate_Subprogram_Completion *)
module Io__printnumber__axiom
 use import "_gnatprove_standard".Main

 val printnumber #"io.ads" 10 0 0# 
   (i : int) : unit
  requires { true }
  ensures { true }

end

(* Module for checking absence of run-time errors and package initial condition on package elaboration of "graph" defined at graph.ads:4, created in Gnat2Why.Subprograms.Generate_VCs_For_Package_Elaboration *)
module Graph__package_def
 use import "_gnatprove_standard".Main

 let def #"io.ads" 10 0 0# "GP_Subp:graph.ads:4" "W:diverges:N" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( "GP_Sloc:graph.adb:111:1" () )
end

(* Module for checking contracts and absence of run-time errors in subprogram "Olt" defined at graph.ads:17, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__Olt__subprogram_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        Graph__node
 use        Graph__edge
 use        Graph__edge__axiom
 use        Graph__Olt__e
 use        Graph__Olt__f
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__e__axiom
 use        Graph__Olt__f__axiom

 val graph__Olt__result #"io.ads" 10 0 0# "model" "model_trace:3146@result"  : bool__ref 
 
 let def #"io.ads" 10 0 0# "W:diverges:N" "GP_Subp:graph.ads:17" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:17 *)
  ;
  #"graph.ads" 8 0 0# assume { (Graph__edge__axiom.dynamic_invariant Graph__Olt__e.e True False True) };
  #"graph.ads" 8 0 0# assume { (Graph__edge__axiom.dynamic_invariant Graph__Olt__f.f True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:17 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:17 *)
  ;
  #"graph.ads" 17 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:17 *)
  ;
  #"graph.ads" 17 0 0# assume { true };
  () (* checking of pragma precondition graph.ads:17 *)
  ;
  try
   ( ( "GP_Sloc:graph.ads:18:23" ( #"graph.ads" 18 0 0# graph__Olt__result.bool__content <- ( (Boolean.orb(((Graph__node.to_rep((Graph__edge.rec__from((Graph__edge.__split_fields(Graph__Olt__e.e)))))) < (Graph__node.to_rep((Graph__edge.rec__from((Graph__edge.__split_fields(Graph__Olt__f.f)))))))) ((Boolean.andb(((Graph__node.to_rep((Graph__edge.rec__from((Graph__edge.__split_fields(Graph__Olt__e.e)))))) = (Graph__node.to_rep((Graph__edge.rec__from((Graph__edge.__split_fields(Graph__Olt__f.f)))))))) (((Graph__node.to_rep((Graph__edge.rec__to((Graph__edge.__split_fields(Graph__Olt__e.e)))))) < (Graph__node.to_rep((Graph__edge.rec__to((Graph__edge.__split_fields(Graph__Olt__f.f))))))))))) );
   #"graph.ads" 18 0 0# raise Return__exc ) );
   #"graph.ads" 17 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:17 *)
  ;
  #"graph.ads" 17 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__Olt__result.bool__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "Olt" defined at graph.ads:21, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__graphnode__Olt__subprogram_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Graph__node__axiom
 use        Graph__graphnode__Olt__A1s
 use        Graph__graphnode__Olt__B2s
 use        Graph__node__axiom

 val graph__graphnode__Olt__result #"graph.ads" 17 0 0#  : bool__ref 
 
 let def #"graph.ads" 17 0 0# "W:diverges:N" "GP_Subp:graph.ads:21" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:21 *)
  ;
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__graphnode__Olt__A1s.a1s True False True) };
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__graphnode__Olt__B2s.b2s True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:21 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:21 *)
  ;
  #"graph.ads" 21 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:21 *)
  ;
  #"graph.ads" 21 0 0# assume { true };
  () (* checking of pragma precondition graph.ads:21 *)
  ;
  try
   ( ( "GP_Sloc:graph.ads:21:12" ( #"graph.ads" 21 0 0# graph__graphnode__Olt__result.bool__content <- ( (Graph__graphnode__Olt__A1s.a1s < Graph__graphnode__Olt__B2s.b2s) );
   #"graph.ads" 21 0 0# raise Return__exc ) );
   #"graph.ads" 21 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:21 *)
  ;
  #"graph.ads" 21 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__graphnode__Olt__result.bool__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "Oeq" defined at graph.ads:21, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__graphnode__Oeq__subprogram_def
 use import "_gnatprove_standard".Main
 use        Graph__node__axiom
 use        Graph__graphnode__Oeq__A4s
 use        Graph__graphnode__Oeq__B5s
 use        Graph__node__axiom

 val graph__graphnode__Oeq__result #"graph.ads" 21 0 0#  : bool__ref 
 
 let def #"graph.ads" 21 0 0# "W:diverges:N" "GP_Subp:graph.ads:21" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:21 *)
  ;
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__graphnode__Oeq__A4s.a4s True False True) };
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__graphnode__Oeq__B5s.b5s True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:21 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:21 *)
  ;
  #"graph.ads" 21 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:21 *)
  ;
  #"graph.ads" 21 0 0# assume { true };
  () (* checking of pragma precondition graph.ads:21 *)
  ;
  try
   ( ( "GP_Sloc:graph.ads:21:12" ( #"graph.ads" 21 0 0# graph__graphnode__Oeq__result.bool__content <- ( (Graph__graphnode__Oeq__A4s.a4s = Graph__graphnode__Oeq__B5s.b5s) );
   #"graph.ads" 21 0 0# raise Return__exc ) );
   #"graph.ads" 21 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:21 *)
  ;
  #"graph.ads" 21 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__graphnode__Oeq__result.bool__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "Olt" defined at graph.ads:25, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__graphedge__Olt__subprogram_def
 use import "_gnatprove_standard".Main
 use        Graph__edge__axiom
 use        Graph__Olt__axiom
 use        Graph__graphedge__Olt__left
 use        Graph__graphedge__Olt__right
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__axiom

 val graph__graphedge__Olt__result #"graph.ads" 21 0 0#  : bool__ref 
 
 let def #"graph.ads" 21 0 0# "W:diverges:N" "GP_Subp:graph.ads:25" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:25 *)
  ;
  #"graph.ads" 8 0 0# assume { (Graph__edge__axiom.dynamic_invariant Graph__graphedge__Olt__left.left True False True) };
  #"graph.ads" 8 0 0# assume { (Graph__edge__axiom.dynamic_invariant Graph__graphedge__Olt__right.right True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:25 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:25 *)
  ;
  #"graph.ads" 25 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:25 *)
  ;
  #"graph.ads" 25 0 0# assume { true };
  () (* checking of pragma precondition graph.ads:25 *)
  ;
  try
   ( ( "GP_Sloc:graph.ads:25:12" ( #"graph.ads" 25 0 0# graph__graphedge__Olt__result.bool__content <- ( (Graph__Olt__axiom.olt(Graph__graphedge__Olt__left.left) (Graph__graphedge__Olt__right.right)) );
   #"graph.ads" 25 0 0# raise Return__exc ) );
   #"graph.ads" 25 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:25 *)
  ;
  #"graph.ads" 25 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__graphedge__Olt__result.bool__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "Oeq" defined at graph.ads:25, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__graphedge__Oeq__subprogram_def
 use import "_gnatprove_standard".Main
 use        Graph__edge
 use        Graph__edge__axiom
 use        Graph__graphedge__Oeq__A50s
 use        Graph__graphedge__Oeq__B51s
 use        Graph__node__axiom
 use        Graph__edge__axiom

 val graph__graphedge__Oeq__result #"graph.ads" 25 0 0#  : bool__ref 
 
 let def #"graph.ads" 25 0 0# "W:diverges:N" "GP_Subp:graph.ads:25" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:25 *)
  ;
  #"graph.ads" 8 0 0# assume { (Graph__edge__axiom.dynamic_invariant Graph__graphedge__Oeq__A50s.a50s True False True) };
  #"graph.ads" 8 0 0# assume { (Graph__edge__axiom.dynamic_invariant Graph__graphedge__Oeq__B51s.b51s True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:25 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:25 *)
  ;
  #"graph.ads" 25 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:25 *)
  ;
  #"graph.ads" 25 0 0# assume { true };
  () (* checking of pragma precondition graph.ads:25 *)
  ;
  try
   ( ( "GP_Sloc:graph.ads:25:12" ( #"graph.ads" 25 0 0# graph__graphedge__Oeq__result.bool__content <- ( (Graph__edge.bool_eq(Graph__graphedge__Oeq__A50s.a50s) (Graph__graphedge__Oeq__B51s.b51s)) );
   #"graph.ads" 25 0 0# raise Return__exc ) );
   #"graph.ads" 25 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:25 *)
  ;
  #"graph.ads" 25 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__graphedge__Oeq__result.bool__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "addnode" defined at graph.ads:33, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__addnode__subprogram_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type
 use        Graph__node__axiom
 use        Graph__graphnode__set
 use        Graph__graphnode__length
 use        Graph__graphnode__is_empty
 use        Graph__graphnode__include
 use        Graph__mygraph__T95s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__addnode__g
 use        Graph__addnode__n
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__axiom
 use        Graph__mygraph__axiom
 use        Graph__addnode__g__axiom
 use        Graph__addnode__n__axiom
 use        Ada__containers__count_type__axiom
 use        Graph__mygraph__T95s__axiom
 use        Graph__mygraph__T97s__axiom

 let def #"graph.ads" 25 0 0# "W:diverges:N" "GP_Subp:graph.ads:33" 
   (__void_param : unit)
  requires { true }
  ensures { ( #"graph.ads" 36 0 0# "model_vc_post" "keep_on_simp" "GP_Sloc:graph.ads:36:16" "GP_Reason:VC_POSTCONDITION" "GP_Id:3" "comment:       Post => not GraphNode.Is_Empty(g.gnode);
               ^ graph.ads:36:16:VC_POSTCONDITION" "GP_Shape:pragargs__not" ( "GP_Pretty_Ada:28758" "GP_Sloc:graph.ads:36:16" not ( ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content })))) = True) ) ) ) }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:33 *)
  ;
  #"graph.ads" 28 0 0# assume { (Graph__mygraph__axiom.dynamic_invariant { Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content } True False True) };
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__addnode__n.n True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:33 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:33 *)
  ;
  #"graph.ads" 33 0 0# abstract ensures {true}(let _ = (( #"graph.ads" 35 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.ads:35:24" "GP_Id:2" "comment:       Pre => GraphNode.Length(Container => g.gnode)<g.gnode.Capacity,
                       ^ graph.ads:35:24:VC_PRECONDITION" "GP_Shape:pragargs__cmp__call_length" (Graph__graphnode__length.length((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content })))))))) ) < (Ada__containers__count_type.to_rep((Graph__graphnode__set.rec__capacity((Graph__mygraph__T95s.__split_discrs((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content }))))))))))) in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:33 *)
  ;
  #"graph.ads" 28 0 0# assume { ((Graph__graphnode__length.length__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content })))) < (Ada__containers__count_type.to_rep (Graph__graphnode__set.rec__capacity (Graph__mygraph__T95s.__split_discrs (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content })))))) };
  () (* checking of pragma precondition graph.ads:33 *)
  ;
  try
   ( ( "GP_Sloc:graph.adb:11:16" (let graph__graphnode__include__container__compl = (Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content })))))) in (
    #"graph.ads" 28 0 0# let graph__graphnode__include__container__fields = { Graph__graphnode__set.__split_fields__content = (Graph__graphnode__set.__split_fields(graph__graphnode__include__container__compl)) } in 
     ( ( #"graph.adb" 11 0 0# "model_vc" "keep_on_simp" "GP_Sloc:graph.adb:11:16" "GP_Reason:VC_PRECONDITION" "GP_Id:0" "comment:      GraphNode.Include(Container =>g.gnode,
               ^ graph.adb:11:16:VC_PRECONDITION" "GP_Shape:call_include" (Graph__graphnode__include.include(graph__graphnode__include__container__fields) ((Graph__graphnode__set.__split_discrs(graph__graphnode__include__container__compl))) (Graph__addnode__n.n)) );
     (let temp___373 = (let temp___372 = { Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content } in (
      ( #"graph.ads" 28 0 0# abstract ensures {true}(let _ = (Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(temp___372)))) in (
       ()))
       end ;
      { ( temp___372 ) with Graph__mygraph.__split_fields = { ( (Graph__mygraph.__split_fields(temp___372)) ) with Graph__mygraph.rec__gnode = (Graph__mygraph__T95s.of_base { Graph__graphnode__set.__split_fields = graph__graphnode__include__container__fields.Graph__graphnode__set.__split_fields__content; Graph__graphnode__set.__split_discrs = (Graph__graphnode__set.__split_discrs(graph__graphnode__include__container__compl)) }) } } )))
      in (
      #"graph.adb" 11 0 0# Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content <- ( (Graph__mygraph.__split_fields(temp___373)) )))
      )))
    );
   #"graph.adb" 9 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:33 *)
  ;
  #"graph.adb" 9 0 0# abstract ensures {true}(let _ = not ( ( #"graph.ads" 36 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.ads:36:29" "GP_Id:1" "comment:       Post => not GraphNode.Is_Empty(g.gnode);
                            ^ graph.ads:36:29:VC_PRECONDITION" "GP_Shape:pragargs__not__call_is_empty" (Graph__graphnode__is_empty.is_empty((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addnode__g.g__split_fields.Graph__mygraph.__split_fields__content })))))))) ) ) in (
   ()))
   end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "addedge" defined at graph.ads:38, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__addedge__subprogram_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        Ada__containers__count_type
 use        Graph__node
 use        Graph__node__axiom
 use        Graph__edge
 use        Graph__edge__axiom
 use        Graph__graphedge__set
 use        Graph__graphedge__length
 use        Graph__graphedge__is_empty
 use        Graph__graphedge__element_type
 use        Graph__graphedge__include
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__addedge__g
 use        Graph__addedge__from
 use        Graph__addedge__to
 use        Graph__addedge__e
 use        Graph__addedge__e__axiom
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__axiom
 use        Graph__mygraph__axiom
 use        Graph__addedge__g__axiom
 use        Graph__addedge__from__axiom
 use        Graph__addedge__to__axiom
 use        Ada__containers__count_type__axiom
 use        Graph__mygraph__T95s__axiom
 use        Graph__mygraph__T97s__axiom

 let def #"graph.ads" 28 0 0# "W:diverges:N" "GP_Subp:graph.ads:38" 
   (__void_param : unit)
  requires { true }
  ensures { ( #"graph.ads" 41 0 0# "model_vc_post" "keep_on_simp" "GP_Reason:VC_POSTCONDITION" "GP_Shape:pragargs__not" "GP_Sloc:graph.ads:41:15" "GP_Id:7" "comment:       Post=> not GraphEdge.Is_Empty(Container => g.gedge);
              ^ graph.ads:41:15:VC_POSTCONDITION" ( "GP_Pretty_Ada:28824" "GP_Sloc:graph.ads:41:15" not ( ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content })))) = True) ) ) ) }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:38 *)
  ;
  #"graph.ads" 28 0 0# assume { (Graph__mygraph__axiom.dynamic_invariant { Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content } True False True) };
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__addedge__from.from True False True) };
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__addedge__to.to__ True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:38 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:38 *)
  ;
  #"graph.ads" 38 0 0# abstract ensures {true}(let _ = (( #"graph.ads" 40 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:pragargs__cmp__call_length" "GP_Sloc:graph.ads:40:24" "GP_Id:6" "comment:       Pre => GraphEdge.Length(Container => g.gedge)<g.gedge.Capacity,
                       ^ graph.ads:40:24:VC_PRECONDITION" (Graph__graphedge__length.length((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content })))))))) ) < (Ada__containers__count_type.to_rep((Graph__graphedge__set.rec__capacity((Graph__mygraph__T97s.__split_discrs((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content }))))))))))) in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:38 *)
  ;
  #"graph.ads" 28 0 0# assume { ((Graph__graphedge__length.length__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content })))) < (Ada__containers__count_type.to_rep (Graph__graphedge__set.rec__capacity (Graph__mygraph__T97s.__split_discrs (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields { Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content })))))) };
  () (* checking of pragma precondition graph.ads:38 *)
  ;
  try
   ( #"graph.ads" 28 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 16 0 0# assume { (Graph__edge__axiom.default_initial_assumption { Graph__edge.__split_fields = Graph__addedge__e.e__split_fields.Graph__edge.__split_fields__content } False) };
   #"graph.ads" 8 0 0# assume { (Graph__edge__axiom.dynamic_invariant { Graph__edge.__split_fields = Graph__addedge__e.e__split_fields.Graph__edge.__split_fields__content } False False True) };
   ( "GP_Sloc:graph.adb:19:13" (let temp___377 = (let temp___376 = { Graph__edge.__split_fields = Graph__addedge__e.e__split_fields.Graph__edge.__split_fields__content } in (
    ( #"graph.ads" 8 0 0# abstract ensures {true}(let _ = (Graph__edge.rec__from((Graph__edge.__split_fields(temp___376)))) in (
     ()))
     end ;
    { ( temp___376 ) with Graph__edge.__split_fields = { ( (Graph__edge.__split_fields(temp___376)) ) with Graph__edge.rec__from = (Graph__node.of_rep Graph__addedge__from.from) } } )))
    in (
    #"graph.adb" 19 0 0# Graph__addedge__e.e__split_fields.Graph__edge.__split_fields__content <- ( (Graph__edge.__split_fields(temp___377)) )))
    );
   ( "GP_Sloc:graph.adb:20:11" (let temp___379 = (let temp___378 = { Graph__edge.__split_fields = Graph__addedge__e.e__split_fields.Graph__edge.__split_fields__content } in (
    ( #"graph.ads" 8 0 0# abstract ensures {true}(let _ = (Graph__edge.rec__to((Graph__edge.__split_fields(temp___378)))) in (
     ()))
     end ;
    { ( temp___378 ) with Graph__edge.__split_fields = { ( (Graph__edge.__split_fields(temp___378)) ) with Graph__edge.rec__to = (Graph__node.of_rep Graph__addedge__to.to__) } } )))
    in (
    #"graph.adb" 20 0 0# Graph__addedge__e.e__split_fields.Graph__edge.__split_fields__content <- ( (Graph__edge.__split_fields(temp___379)) )))
    );
   ( "GP_Sloc:graph.adb:21:16" (let graph__graphedge__include__container__compl = (Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content })))))) in (
    #"graph.ads" 28 0 0# let graph__graphedge__include__container__fields = { Graph__graphedge__set.__split_fields__content = (Graph__graphedge__set.__split_fields(graph__graphedge__include__container__compl)) } in 
     ( ( #"graph.adb" 21 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:call_include" "GP_Sloc:graph.adb:21:16" "GP_Id:4" "comment:      GraphEdge.Include(Container =>g.gedge,
               ^ graph.adb:21:16:VC_PRECONDITION" (Graph__graphedge__include.include(graph__graphedge__include__container__fields) ((Graph__graphedge__set.__split_discrs(graph__graphedge__include__container__compl))) ((Graph__graphedge__element_type.of_base({ Graph__edge.__split_fields = Graph__addedge__e.e__split_fields.Graph__edge.__split_fields__content })))) );
     (let temp___381 = (let temp___380 = { Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content } in (
      ( #"graph.ads" 28 0 0# abstract ensures {true}(let _ = (Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(temp___380)))) in (
       ()))
       end ;
      { ( temp___380 ) with Graph__mygraph.__split_fields = { ( (Graph__mygraph.__split_fields(temp___380)) ) with Graph__mygraph.rec__gedge = (Graph__mygraph__T97s.of_base { Graph__graphedge__set.__split_fields = graph__graphedge__include__container__fields.Graph__graphedge__set.__split_fields__content; Graph__graphedge__set.__split_discrs = (Graph__graphedge__set.__split_discrs(graph__graphedge__include__container__compl)) }) } } )))
      in (
      #"graph.adb" 21 0 0# Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content <- ( (Graph__mygraph.__split_fields(temp___381)) )))
      )))
    );
   #"graph.adb" 15 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:38 *)
  ;
  #"graph.adb" 15 0 0# abstract ensures {true}(let _ = not ( ( #"graph.ads" 41 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:pragargs__not__call_is_empty" "GP_Sloc:graph.ads:41:28" "GP_Id:5" "comment:       Post=> not GraphEdge.Is_Empty(Container => g.gedge);
                           ^ graph.ads:41:28:VC_PRECONDITION" (Graph__graphedge__is_empty.is_empty((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields({ Graph__mygraph.__split_fields = Graph__addedge__g.g__split_fields.Graph__mygraph.__split_fields__content })))))))) ) ) in (
   ()))
   end  )
end

(* Module for checking contracts and absence of run-time errors in subprogram "findnext" defined at graph.ads:43, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__findnext__subprogram_def
 use import "_gnatprove_standard".Main
 use        "_gnatprove_standard".Boolean
 use        Graph__node
 use        Graph__node__axiom
 use        Graph__graphnode__set
 use        Graph__graphnode__is_empty
 use        Graph__graphnode__include
 use        Graph__graphnode__contains
 use        Graph__graphedge__set
 use        Graph__graphedge__cursor
 use        Graph__graphedge__is_empty
 use        Graph__graphedge__element_type
 use        Graph__graphedge__element
 use        Graph__graphedge__first
 use        Graph__graphedge__next
 use        Graph__graphedge__has_element
 use        Graph__mygraph__T95s
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__findnext__n
 use        Graph__findnext__g
 use        Graph__findnext__TworkingS
 use        Graph__findnext__TworkingS__axiom
 use        Graph__findnext__working
 use        Graph__findnext__c
 use        Graph__findnext__L_1
 use        Graph__graphedge__cursor__axiom
 use        Graph__findnext__working__axiom
 use        Graph__findnext__c__axiom
 use        Graph__findnext__L_1__axiom
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__axiom
 use        Graph__mygraph__axiom
 use        Graph__findnext__n__axiom
 use        Graph__findnext__g__axiom
 use        Ada__containers__count_type__axiom
 use        Graph__mygraph__T95s__axiom
 use        Graph__mygraph__T97s__axiom
 use        Graph__findnext__TworkingS__axiom

 val graph__findnext__result #"graph.ads" 28 0 0#  : Graph__graphnode__set.set__ref 
 
 let def #"a-cforse.ads" 78 0 0# "W:diverges:N" "GP_Subp:graph.ads:43" 
   (__void_param : unit)
  requires { true }
  ensures { ( #"graph.ads" 49 0 0# "model_vc_post" "keep_on_simp" "GP_Reason:VC_POSTCONDITION" "GP_Shape:pragargs__call_is_empty" "GP_Sloc:graph.ads:49:6" "GP_Id:20" "comment:     GraphNode.Is_Empty(findnext'Result);
     ^ graph.ads:49:6:VC_POSTCONDITION" ( "GP_Pretty_Ada:28887" "GP_Sloc:graph.ads:49:6" ((Graph__graphnode__is_empty.is_empty__logic graph__findnext__result.Graph__graphnode__set.set__content) = True) ) ) }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:43 *)
  ;
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__findnext__n.n True False True) };
  #"graph.ads" 28 0 0# assume { (Graph__mygraph__axiom.dynamic_invariant Graph__findnext__g.g True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:43 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:43 *)
  ;
  #"graph.ads" 43 0 0# abstract ensures {true}(let _ = (Boolean.andb(( #"graph.ads" 45 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.ads:45:22" "GP_Id:18" "comment:     Pre => GraphNode.Contains(g.gnode,n) and GraphEdge.Is_Empty(g.gedge),
                     ^ graph.ads:45:22:VC_PRECONDITION" "GP_Shape:pragargs__and__call_contains" (Graph__graphnode__contains.contains((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__n.n)) )) (( #"graph.ads" 45 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.ads:45:56" "GP_Id:19" "comment:     Pre => GraphNode.Contains(g.gnode,n) and GraphEdge.Is_Empty(g.gedge),
                                                       ^ graph.ads:45:56:VC_PRECONDITION" "GP_Shape:pragargs__and__call_is_empty" (Graph__graphedge__is_empty.is_empty((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g)))))))) ))) in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:43 *)
  ;
  #"graph.ads" 43 0 0# assume { ( ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields Graph__findnext__g.g))) Graph__findnext__n.n) = True) /\ ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields Graph__findnext__g.g)))) = True) ) };
  () (* checking of pragma precondition graph.ads:43 *)
  ;
  try
   ( #"graph.ads" 43 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 27 0 0# assume { (Graph__findnext__TworkingS__axiom.default_initial_assumption { Graph__findnext__TworkingS.__split_fields = Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content; Graph__findnext__TworkingS.__split_discrs = Graph__findnext__working.working__split_discrs } False) };
   #"graph.adb" 27 0 0# assume { (Graph__findnext__TworkingS__axiom.dynamic_invariant { Graph__findnext__TworkingS.__split_fields = Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content; Graph__findnext__TworkingS.__split_discrs = Graph__findnext__working.working__split_discrs } False False True) };
   #"graph.adb" 28 0 0# Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content <- ( ( #"graph.adb" 28 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:28:38" "GP_Id:8" "comment:      c:GraphEdge.Cursor := GraphEdge.First(Container => g.gedge);
                                     ^ graph.adb:28:38:VC_PRECONDITION" "GP_Shape:c_decl__call_first" (Graph__graphedge__first.first((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g)))))))) ) );
   #"a-cforse.ads" 86 0 0# assume { (Graph__graphedge__cursor__axiom.dynamic_invariant Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content True False True) };
   ( "GP_Sloc:graph.adb:30:73" ( () (* Translation of an Ada loop from graph.adb:30 *)
   ;
   (if (( #"graph.adb" 30 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:30:22" "GP_Id:16" "comment:      while GraphEdge.Has_Element(Container => g.gedge, Position  => c) loop
                     ^ graph.adb:30:22:VC_PRECONDITION" "GP_Shape:L_1_while__call_has_element" (Graph__graphedge__has_element.has_element((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content)) )) then (
    try
     ( () (* First unroling of the loop statements appearing before the loop invariant of loop graph.adb:30 *)
     ;
     () (* While loop translating the Ada loop from graph.adb:30 *)
     ;
     #"graph.adb" 30 0 0# while True do
      ( () (* Assume implicit invariants from the loop graph.adb:30 *)
      ;
      #"graph.adb" 30 0 0# assume { (Boolean.andb((Boolean.andb((Graph__findnext__TworkingS__axiom.dynamic_invariant { Graph__findnext__TworkingS.__split_fields = Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content; Graph__findnext__TworkingS.__split_discrs = Graph__findnext__working.working__split_discrs } False True True)) ((Graph__graphedge__cursor__axiom.dynamic_invariant Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content False True True)))) (((Graph__graphedge__has_element.has_element__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields Graph__findnext__g.g))) Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content) = True))) };
      () (* Check for absence of RTE in the invariant of loop graph.adb:30 *)
      ;
      () (* Loop statements appearing after the loop invariant of loop graph.adb:30 *)
      ;
      ( "GP_Sloc:graph.adb:31:10" (if (((Graph__node.to_rep((Graph__graphedge__element_type.rec__from((Graph__graphedge__element_type.__split_fields(( #"graph.adb" 31 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:31:24" "GP_Id:11" "comment:         if  (GraphEdge.Element(g.gedge,c).From=n) then
                       ^ graph.adb:31:24:VC_PRECONDITION" "GP_Shape:L_1_while__if__cmp__selectcomp__call_element" (Graph__graphedge__element.element((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content)) ))))))) = Graph__findnext__n.n)) then (
       ( "GP_Sloc:graph.adb:33:22" (let graph__graphnode__include__container__compl = (Graph__findnext__TworkingS.to_base({ Graph__findnext__TworkingS.__split_fields = Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content; Graph__findnext__TworkingS.__split_discrs = Graph__findnext__working.working__split_discrs })) in (
        #"graph.adb" 27 0 0# let graph__graphnode__include__container__fields = { Graph__graphnode__set.__split_fields__content = (Graph__graphnode__set.__split_fields(graph__graphnode__include__container__compl)) } in 
         ( ( #"graph.adb" 33 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:33:22" "GP_Id:10" "comment:            GraphNode.Include(Container => working,New_Item  => GraphEdge.Element(g.gedge,c).To);
                     ^ graph.adb:33:22:VC_PRECONDITION" "GP_Shape:L_1_while__if__call_include" (Graph__graphnode__include.include(graph__graphnode__include__container__fields) (Graph__findnext__working.working__split_discrs) ((Graph__node.to_rep((Graph__graphedge__element_type.rec__to((Graph__graphedge__element_type.__split_fields(( #"graph.adb" 33 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:33:74" "GP_Id:9" "comment:            GraphNode.Include(Container => working,New_Item  => GraphEdge.Element(g.gedge,c).To);
                                                                         ^ graph.adb:33:74:VC_PRECONDITION" "GP_Shape:L_1_while__if__call_include__selectcomp__call_element" (Graph__graphedge__element.element((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content)) ))))))))) );
         (let temp___385 = (Graph__findnext__TworkingS.of_base { Graph__graphnode__set.__split_fields = graph__graphnode__include__container__fields.Graph__graphnode__set.__split_fields__content; Graph__graphnode__set.__split_discrs = Graph__findnext__working.working__split_discrs }) in (
          ( #"graph.adb" 33 0 0# Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content <- ( (Graph__findnext__TworkingS.__split_fields(temp___385)) );
          #"graph.adb" 33 0 0# assume { (Graph__findnext__working.working__split_discrs = (Graph__findnext__TworkingS.__split_discrs temp___385)) } )))
          )))
        )) else (
       ())) );
      ( "GP_Sloc:graph.adb:35:10" (if (((Graph__node.to_rep((Graph__graphedge__element_type.rec__to((Graph__graphedge__element_type.__split_fields(( #"graph.adb" 35 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:L_1_while__if__cmp__selectcomp__call_element" "GP_Sloc:graph.adb:35:23" "GP_Id:14" "comment:         if (GraphEdge.Element(g.gedge,c).To =n) then
                      ^ graph.adb:35:23:VC_PRECONDITION" (Graph__graphedge__element.element((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content)) ))))))) = Graph__findnext__n.n)) then (
       ( "GP_Sloc:graph.adb:36:22" (let graph__graphnode__include__container__compl = (Graph__findnext__TworkingS.to_base({ Graph__findnext__TworkingS.__split_fields = Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content; Graph__findnext__TworkingS.__split_discrs = Graph__findnext__working.working__split_discrs })) in (
        #"graph.adb" 27 0 0# let graph__graphnode__include__container__fields = { Graph__graphnode__set.__split_fields__content = (Graph__graphnode__set.__split_fields(graph__graphnode__include__container__compl)) } in 
         ( ( #"graph.adb" 36 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:L_1_while__if__call_include" "GP_Sloc:graph.adb:36:22" "GP_Id:13" "comment:            GraphNode.Include(Container => working,New_Item  => GraphEdge.Element(g.gedge,c).From);
                     ^ graph.adb:36:22:VC_PRECONDITION" (Graph__graphnode__include.include(graph__graphnode__include__container__fields) (Graph__findnext__working.working__split_discrs) ((Graph__node.to_rep((Graph__graphedge__element_type.rec__from((Graph__graphedge__element_type.__split_fields(( #"graph.adb" 36 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:L_1_while__if__call_include__selectcomp__call_element" "GP_Sloc:graph.adb:36:74" "GP_Id:12" "comment:            GraphNode.Include(Container => working,New_Item  => GraphEdge.Element(g.gedge,c).From);
                                                                         ^ graph.adb:36:74:VC_PRECONDITION" (Graph__graphedge__element.element((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content)) ))))))))) );
         (let temp___386 = (Graph__findnext__TworkingS.of_base { Graph__graphnode__set.__split_fields = graph__graphnode__include__container__fields.Graph__graphnode__set.__split_fields__content; Graph__graphnode__set.__split_discrs = Graph__findnext__working.working__split_discrs }) in (
          ( #"graph.adb" 36 0 0# Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content <- ( (Graph__findnext__TworkingS.__split_fields(temp___386)) );
          #"graph.adb" 36 0 0# assume { (Graph__findnext__working.working__split_discrs = (Graph__findnext__TworkingS.__split_discrs temp___386)) } )))
          )))
        )) else (
       ())) );
      ( "GP_Sloc:graph.adb:38:12" #"graph.adb" 38 0 0# Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content <- ( ( #"graph.adb" 38 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:38:24" "GP_Id:15" "comment:         c := GraphEdge.Next(g.gedge,c);
                       ^ graph.adb:38:24:VC_PRECONDITION" "GP_Shape:L_1_while__c_assign__call_next" (Graph__graphedge__next.next((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content)) ) ) );
      () (* Check for the exit condition and loop statements appearing before the loop invariant of loop graph.adb:30 *)
      ;
      (if (( #"graph.adb" 30 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:30:22" "GP_Id:16" "comment:      while GraphEdge.Has_Element(Container => g.gedge, Position  => c) loop
                     ^ graph.adb:30:22:VC_PRECONDITION" "GP_Shape:L_1_while__call_has_element" (Graph__graphedge__has_element.has_element((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__findnext__g.g))))))) (Graph__findnext__c.c.Graph__graphedge__cursor.cursor__content)) )) then (
       ()) else (
       #"a-cforse.ads" 86 0 0# raise Graph__findnext__L_1.L_1)) )
     done )
    with
     Graph__findnext__L_1.L_1 -> ()
    end)) ) );
   ( "GP_Sloc:graph.adb:41:7" ( #"graph.adb" 41 0 0# graph__findnext__result.Graph__graphnode__set.set__content <- ( (Graph__findnext__TworkingS.to_base({ Graph__findnext__TworkingS.__split_fields = Graph__findnext__working.working__split_fields.Graph__findnext__TworkingS.__split_fields__content; Graph__findnext__TworkingS.__split_discrs = Graph__findnext__working.working__split_discrs })) );
   #"graph.adb" 41 0 0# raise Return__exc ) );
   #"graph.adb" 25 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:43 *)
  ;
  #"graph.adb" 25 0 0# abstract ensures {true}(let _ = ( #"graph.ads" 49 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.ads:49:15" "GP_Id:17" "comment:     GraphNode.Is_Empty(findnext'Result);
              ^ graph.ads:49:15:VC_PRECONDITION" "GP_Shape:pragargs__call_is_empty" (Graph__graphnode__is_empty.is_empty(graph__findnext__result.Graph__graphnode__set.set__content)) ) in (
   ()))
   end ;
  graph__findnext__result.Graph__graphnode__set.set__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "distance" defined at graph.ads:51, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__distance__subprogram_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        Standard__integer
 use        Standard__integer__axiom
 use        Graph__node__axiom
 use        Graph__graphnode__set
 use        Graph__graphnode__cursor
 use        Graph__graphnode__element
 use        Graph__graphnode__first
 use        Graph__graphnode__next
 use        Graph__graphnode__contains
 use        Graph__graphnode__has_element
 use        Graph__mygraph__T95s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__findnext__axiom
 use        Graph__distance__source
 use        Graph__distance__target
 use        Graph__distance__g
 use        Graph__distance__next
 use        Graph__distance__TreachS
 use        Graph__distance__TreachS__axiom
 use        Graph__distance__reach
 use        Graph__distance__c1
 use        Graph__distance__distance
 use        Graph__distance__L_2
 use        Graph__graphnode__cursor__axiom
 use        Standard__integer__axiom
 use        Standard__integer__axiom
 use        Graph__distance__next__axiom
 use        Graph__distance__reach__axiom
 use        Graph__distance__c1__axiom
 use        Graph__distance__distance__axiom
 use        Graph__distance__L_2__axiom
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__axiom
 use        Graph__mygraph__axiom
 use        Graph__findnext__axiom
 use        Graph__distance__source__axiom
 use        Graph__distance__target__axiom
 use        Graph__distance__g__axiom
 use        Ada__containers__count_type__axiom
 use        Graph__mygraph__T95s__axiom
 use        Graph__mygraph__T97s__axiom
 use        Graph__distance__TreachS__axiom

 val graph__distance__result #"a-cforse.ads" 78 0 0# "model" "model_trace:3488@result"  : int__ref 
 
 let def #"system.ads" 1 0 0# "W:diverges:N" "GP_Subp:graph.ads:51" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:51 *)
  ;
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__distance__source.source True False True) };
  #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__distance__target.target True False True) };
  #"graph.ads" 28 0 0# assume { (Graph__mygraph__axiom.dynamic_invariant Graph__distance__g.g True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:51 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:51 *)
  ;
  #"graph.ads" 51 0 0# abstract ensures {true}(let _ = (Boolean.andb(( #"graph.ads" 52 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:pragargs__and__call_contains" "GP_Sloc:graph.ads:52:27" "GP_Id:32" "comment:     with Pre => GraphNode.Contains(Container => g.gnode, Item  => source) and
                          ^ graph.ads:52:27:VC_PRECONDITION" (Graph__graphnode__contains.contains((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__distance__g.g))))))) (Graph__distance__source.source)) )) (( #"graph.ads" 53 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:pragargs__and__call_contains" "GP_Sloc:graph.ads:53:15" "GP_Id:33" "comment:     GraphNode.Contains(Container => g.gnode, Item  => target);
              ^ graph.ads:53:15:VC_PRECONDITION" (Graph__graphnode__contains.contains((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__distance__g.g))))))) (Graph__distance__target.target)) ))) in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:51 *)
  ;
  #"graph.ads" 51 0 0# assume { ( ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields Graph__distance__g.g))) Graph__distance__source.source) = True) /\ ((Graph__graphnode__contains.contains__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields Graph__distance__g.g))) Graph__distance__target.target) = True) ) };
  () (* checking of pragma precondition graph.ads:51 *)
  ;
  try
   ( #"graph.ads" 51 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 45 0 0# assume { (Graph__node__axiom.default_initial_assumption Graph__distance__next.next.int__content False) };
   #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__distance__next.next.int__content False False True) };
   #"graph.ads" 7 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 47 0 0# assume { (Graph__distance__TreachS__axiom.default_initial_assumption { Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs } False) };
   #"graph.adb" 47 0 0# assume { (Graph__distance__TreachS__axiom.dynamic_invariant { Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs } False False True) };
   #"graph.adb" 47 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 49 0 0# assume { (Graph__graphnode__cursor__axiom.default_initial_assumption Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content False) };
   #"a-cforse.ads" 86 0 0# assume { (Graph__graphnode__cursor__axiom.dynamic_invariant Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content False False True) };
   #"graph.adb" 50 0 0# Graph__distance__distance.distance.int__content <- ( 0 );
   #"system.ads" 1 0 0# assume { (Standard__integer__axiom.dynamic_invariant Graph__distance__distance.distance.int__content True False True) };
   ( "GP_Sloc:graph.adb:53:13" (let temp___391 = (Graph__distance__TreachS.of_base(( #"graph.adb" 53 0 0# "model_vc" "keep_on_simp" "GP_Sloc:graph.adb:53:16" "GP_Shape:reach_assign__call_findnext" "GP_Reason:VC_DISCRIMINANT_CHECK" "GP_Id:22" "comment:      reach := findnext(source,g);
               ^ graph.adb:53:16:VC_DISCRIMINANT_CHECK" (Graph__distance__TreachS.range_check_(10) (( #"graph.adb" 53 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:53:16" "GP_Id:21" "comment:      reach := findnext(source,g);
               ^ graph.adb:53:16:VC_PRECONDITION" "GP_Shape:reach_assign__call_findnext" (Graph__findnext__axiom.findnext(Graph__distance__source.source) (Graph__distance__g.g)) ))) ))) in (
    ( #"graph.adb" 53 0 0# Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content <- ( (Graph__distance__TreachS.__split_fields(temp___391)) );
    #"graph.adb" 53 0 0# assume { (Graph__distance__reach.reach__split_discrs = (Graph__distance__TreachS.__split_discrs temp___391)) } )))
    );
   ( "GP_Sloc:graph.adb:54:7" (if (( #"graph.adb" 54 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:54:20" "GP_Id:31" "comment:      if (GraphNode.Contains(Container => reach, Item => target)) then
                   ^ graph.adb:54:20:VC_PRECONDITION" "GP_Shape:if__call_contains" (Graph__graphnode__contains.contains((Graph__distance__TreachS.to_base({ Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs }))) (Graph__distance__target.target)) )) then (
    ( "GP_Sloc:graph.adb:55:10" ( #"graph.adb" 55 0 0# graph__distance__result.int__content <- ( 1 );
    #"graph.adb" 55 0 0# raise Return__exc ) )) else (
    ( ( "GP_Sloc:graph.adb:57:16" #"graph.adb" 57 0 0# Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content <- ( ( #"graph.adb" 57 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:57:28" "GP_Id:23" "comment:            c1 := GraphNode.First(Container => reach);
                           ^ graph.adb:57:28:VC_PRECONDITION" "GP_Shape:if__c1_assign__call_first" (Graph__graphnode__first.first((Graph__distance__TreachS.to_base({ Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs })))) ) ) );
    ( "GP_Sloc:graph.adb:58:46" ( () (* Translation of an Ada loop from graph.adb:58 *)
    ;
    (if (( #"graph.adb" 58 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:58:22" "GP_Id:30" "comment:      while GraphNode.Has_Element(reach, c1) loop
                     ^ graph.adb:58:22:VC_PRECONDITION" "GP_Shape:if__L_2_while__call_has_element" (Graph__graphnode__has_element.has_element((Graph__distance__TreachS.to_base({ Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs }))) (Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content)) )) then (
     try
      ( () (* First unroling of the loop statements appearing before the loop invariant of loop graph.adb:58 *)
      ;
      () (* While loop translating the Ada loop from graph.adb:58 *)
      ;
      #"graph.adb" 58 0 0# while True do
       ( () (* Assume implicit invariants from the loop graph.adb:58 *)
       ;
       #"graph.adb" 58 0 0# assume { (Boolean.andb((Boolean.andb((Boolean.andb((Boolean.andb((Graph__graphnode__cursor__axiom.dynamic_invariant Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content False True True)) ((Standard__integer__axiom.dynamic_invariant Graph__distance__distance.distance.int__content False True True)))) ((Graph__node__axiom.dynamic_invariant Graph__distance__next.next.int__content False True True)))) ((Graph__distance__TreachS__axiom.dynamic_invariant { Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs } False True True)))) (((Graph__graphnode__has_element.has_element__logic (Graph__distance__TreachS.to_base { Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs }) Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content) = True))) };
       () (* Check for absence of RTE in the invariant of loop graph.adb:58 *)
       ;
       () (* Loop statements appearing after the loop invariant of loop graph.adb:58 *)
       ;
       ( "GP_Sloc:graph.adb:59:25" #"graph.adb" 59 0 0# Graph__distance__distance.distance.int__content <- ( ( #"graph.adb" 59 0 0# "model_vc" "keep_on_simp" "GP_Sloc:graph.adb:59:36" "GP_Reason:VC_OVERFLOW_CHECK" "GP_Id:24" "comment:               distance := distance+1;
                                   ^ graph.adb:59:36:VC_OVERFLOW_CHECK" "GP_Shape:if__L_2_while__distance_assign__add" (Standard__integer.range_check_((Graph__distance__distance.distance.int__content + 1))) ) ) );
       ( "GP_Sloc:graph.adb:60:13" (if (( #"graph.adb" 60 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:60:32" "GP_Id:25" "comment:            exit when GraphNode.Contains(Container => reach, Item => target);
                               ^ graph.adb:60:32:VC_PRECONDITION" "GP_Shape:if__L_2_while__exit__call_contains" (Graph__graphnode__contains.contains((Graph__distance__TreachS.to_base({ Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs }))) (Graph__distance__target.target)) )) then (
        #"graph.adb" 60 0 0# raise Graph__distance__L_2.L_2)) );
       ( "GP_Sloc:graph.adb:61:18" #"graph.adb" 61 0 0# Graph__distance__next.next.int__content <- ( ( #"graph.adb" 61 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:61:30" "GP_Id:26" "comment:            Next := GraphNode.Element(reach,c1);
                             ^ graph.adb:61:30:VC_PRECONDITION" "GP_Shape:if__L_2_while__next_assign__call_element" (Graph__graphnode__element.element((Graph__distance__TreachS.to_base({ Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs }))) (Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content)) ) ) );
       ( "GP_Sloc:graph.adb:62:22" (let temp___392 = (Graph__distance__TreachS.of_base(( #"graph.adb" 62 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_DISCRIMINANT_CHECK" "GP_Sloc:graph.adb:62:25" "GP_Shape:if__L_2_while__reach_assign__call_findnext" "GP_Id:28" "comment:               reach := findnext(n => Next, g => g);
                        ^ graph.adb:62:25:VC_DISCRIMINANT_CHECK" (Graph__distance__TreachS.range_check_(10) (( #"graph.adb" 62 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:62:25" "GP_Id:27" "comment:               reach := findnext(n => Next, g => g);
                        ^ graph.adb:62:25:VC_PRECONDITION" "GP_Shape:if__L_2_while__reach_assign__call_findnext" (Graph__findnext__axiom.findnext(Graph__distance__next.next.int__content) (Graph__distance__g.g)) ))) ))) in (
        ( #"graph.adb" 62 0 0# Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content <- ( (Graph__distance__TreachS.__split_fields(temp___392)) );
        #"graph.adb" 62 0 0# assume { (Graph__distance__reach.reach__split_discrs = (Graph__distance__TreachS.__split_discrs temp___392)) } )))
        );
       ( "GP_Sloc:graph.adb:63:15" #"graph.adb" 63 0 0# Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content <- ( ( #"graph.adb" 63 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:63:27" "GP_Id:29" "comment:            c1:= GraphNode.Next(reach,c1);
                          ^ graph.adb:63:27:VC_PRECONDITION" "GP_Shape:if__L_2_while__c1_assign__call_next" (Graph__graphnode__next.next((Graph__distance__TreachS.to_base({ Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs }))) (Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content)) ) ) );
       () (* Check for the exit condition and loop statements appearing before the loop invariant of loop graph.adb:58 *)
       ;
       (if (( #"graph.adb" 58 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:58:22" "GP_Id:30" "comment:      while GraphNode.Has_Element(reach, c1) loop
                     ^ graph.adb:58:22:VC_PRECONDITION" "GP_Shape:if__L_2_while__call_has_element" (Graph__graphnode__has_element.has_element((Graph__distance__TreachS.to_base({ Graph__distance__TreachS.__split_fields = Graph__distance__reach.reach__split_fields.Graph__distance__TreachS.__split_fields__content; Graph__distance__TreachS.__split_discrs = Graph__distance__reach.reach__split_discrs }))) (Graph__distance__c1.c1.Graph__graphnode__cursor.cursor__content)) )) then (
        ()) else (
        #"a-cforse.ads" 86 0 0# raise Graph__distance__L_2.L_2)) )
      done )
     with
      Graph__distance__L_2.L_2 -> ()
     end)) ) );
    ( "GP_Sloc:graph.adb:65:10" ( #"graph.adb" 65 0 0# graph__distance__result.int__content <- ( Graph__distance__distance.distance.int__content );
    #"graph.adb" 65 0 0# raise Return__exc ) ) ))) );
   #"graph.adb" 44 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:51 *)
  ;
  #"graph.adb" 44 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__distance__result.int__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "diameter" defined at graph.ads:55, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__diameter__subprogram_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        Standard__integer__axiom
 use        Graph__node__axiom
 use        Graph__graphnode__set
 use        Graph__graphnode__cursor
 use        Graph__graphnode__is_empty
 use        Graph__graphnode__element
 use        Graph__graphnode__first
 use        Graph__graphnode__next
 use        Graph__graphnode__has_element
 use        Graph__graphedge__set
 use        Graph__graphedge__is_empty
 use        Graph__mygraph__T95s
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__distance__axiom
 use        Graph__diameter__g
 use        Graph__diameter__source
 use        Graph__diameter__target
 use        Graph__diameter__c
 use        Graph__diameter__c1
 use        Graph__diameter__diameter
 use        Graph__diameter__value
 use        Graph__diameter__L_3
 use        Graph__diameter__L_4
 use        Graph__graphnode__cursor__axiom
 use        Standard__integer__axiom
 use        Graph__diameter__source__axiom
 use        Graph__diameter__target__axiom
 use        Graph__diameter__c__axiom
 use        Graph__diameter__c1__axiom
 use        Graph__diameter__diameter__axiom
 use        Graph__diameter__value__axiom
 use        Graph__diameter__L_4__axiom
 use        Graph__diameter__L_3__axiom
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__axiom
 use        Graph__mygraph__axiom
 use        Graph__distance__axiom
 use        Graph__diameter__g__axiom
 use        Ada__containers__count_type__axiom
 use        Graph__mygraph__T95s__axiom
 use        Graph__mygraph__T97s__axiom

 val graph__diameter__result #"system.ads" 1 0 0# "model" "model_trace:3554@result"  : int__ref 
 
 let def #"system.ads" 1 0 0# "W:diverges:N" "GP_Subp:graph.ads:55" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:55 *)
  ;
  #"graph.ads" 28 0 0# assume { (Graph__mygraph__axiom.dynamic_invariant Graph__diameter__g.g True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:55 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:55 *)
  ;
  #"graph.ads" 55 0 0# abstract ensures {true}(let _ = (Boolean.andb(((Boolean.to_int(( #"graph.ads" 56 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.ads:56:25" "GP_Id:43" "comment:   with Pre => GraphNode.Is_Empty(Container => g.gnode)=False and GraphEdge.Is_Empty(Container => g.gedge)=False;
                        ^ graph.ads:56:25:VC_PRECONDITION" "GP_Shape:pragargs__and__cmp__call_is_empty" (Graph__graphnode__is_empty.is_empty((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g)))))))) ))) = (Boolean.to_int((Boolean.of_int(0)))))) (((Boolean.to_int(( #"graph.ads" 56 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:pragargs__and__cmp__call_is_empty" "GP_Sloc:graph.ads:56:76" "GP_Id:44" "comment:   with Pre => GraphNode.Is_Empty(Container => g.gnode)=False and GraphEdge.Is_Empty(Container => g.gedge)=False;
                                                                           ^ graph.ads:56:76:VC_PRECONDITION" (Graph__graphedge__is_empty.is_empty((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__diameter__g.g)))))))) ))) = (Boolean.to_int((Boolean.of_int(0))))))) in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:55 *)
  ;
  #"graph.ads" 56 0 0# assume { ( ( ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields Graph__diameter__g.g)))) = True) <-> false ) /\ ( ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields Graph__diameter__g.g)))) = True) <-> false ) ) };
  () (* checking of pragma precondition graph.ads:55 *)
  ;
  try
   ( #"system.ads" 1 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 71 0 0# assume { (Graph__node__axiom.default_initial_assumption Graph__diameter__source.source.int__content False) };
   #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__diameter__source.source.int__content False False True) };
   #"graph.ads" 7 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 72 0 0# assume { (Graph__node__axiom.default_initial_assumption Graph__diameter__target.target.int__content False) };
   #"graph.ads" 7 0 0# assume { (Graph__node__axiom.dynamic_invariant Graph__diameter__target.target.int__content False False True) };
   #"graph.adb" 74 0 0# Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content <- ( ( #"graph.adb" 74 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:c_decl__call_first" "GP_Sloc:graph.adb:74:39" "GP_Id:34" "comment:      c: GraphNode.Cursor := GraphNode.First(Container => g.gnode);
                                      ^ graph.adb:74:39:VC_PRECONDITION" (Graph__graphnode__first.first((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g)))))))) ) );
   #"a-cforse.ads" 86 0 0# assume { (Graph__graphnode__cursor__axiom.dynamic_invariant Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content True False True) };
   #"a-cforse.ads" 86 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 76 0 0# assume { (Graph__graphnode__cursor__axiom.default_initial_assumption Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content False) };
   #"a-cforse.ads" 86 0 0# assume { (Graph__graphnode__cursor__axiom.dynamic_invariant Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content False False True) };
   #"graph.adb" 77 0 0# Graph__diameter__diameter.diameter.int__content <- ( 0 );
   #"system.ads" 1 0 0# assume { (Standard__integer__axiom.dynamic_invariant Graph__diameter__diameter.diameter.int__content True False True) };
   #"system.ads" 1 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 78 0 0# assume { (Standard__integer__axiom.default_initial_assumption Graph__diameter__value.value.int__content False) };
   #"system.ads" 1 0 0# assume { (Standard__integer__axiom.dynamic_invariant Graph__diameter__value.value.int__content False False True) };
   ( "GP_Sloc:graph.adb:80:72" ( () (* Translation of an Ada loop from graph.adb:80 *)
   ;
   (if (( #"graph.adb" 80 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:80:22" "GP_Id:42" "comment:      while GraphNode.Has_Element(Container => g.gnode,Position  => c) loop
                     ^ graph.adb:80:22:VC_PRECONDITION" "GP_Shape:L_3_while__call_has_element" (Graph__graphnode__has_element.has_element((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content)) )) then (
    try
     ( () (* First unroling of the loop statements appearing before the loop invariant of loop graph.adb:80 *)
     ;
     () (* While loop translating the Ada loop from graph.adb:80 *)
     ;
     #"graph.adb" 80 0 0# while True do
      ( () (* Assume implicit invariants from the loop graph.adb:80 *)
      ;
      #"graph.adb" 80 0 0# assume { (Boolean.andb((Boolean.andb((Boolean.andb((Boolean.andb((Boolean.andb((Boolean.andb((Graph__graphnode__cursor__axiom.dynamic_invariant Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content False True True)) ((Standard__integer__axiom.dynamic_invariant Graph__diameter__diameter.diameter.int__content False True True)))) ((Graph__node__axiom.dynamic_invariant Graph__diameter__source.source.int__content False True True)))) ((Standard__integer__axiom.dynamic_invariant Graph__diameter__value.value.int__content False True True)))) ((Graph__node__axiom.dynamic_invariant Graph__diameter__target.target.int__content False True True)))) ((Graph__graphnode__cursor__axiom.dynamic_invariant Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content False True True)))) (((Graph__graphnode__has_element.has_element__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields Graph__diameter__g.g))) Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content) = True))) };
      () (* Check for absence of RTE in the invariant of loop graph.adb:80 *)
      ;
      () (* Loop statements appearing after the loop invariant of loop graph.adb:80 *)
      ;
      ( "GP_Sloc:graph.adb:81:17" #"graph.adb" 81 0 0# Graph__diameter__source.source.int__content <- ( ( #"graph.adb" 81 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:81:29" "GP_Id:35" "comment:         source := GraphNode.Element(g.gnode,c);
                            ^ graph.adb:81:29:VC_PRECONDITION" "GP_Shape:L_3_while__source_assign__call_element" (Graph__graphnode__element.element((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content)) ) ) );
      ( "GP_Sloc:graph.adb:82:12" #"graph.adb" 82 0 0# Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content <- ( ( #"graph.adb" 82 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:82:23" "GP_Id:36" "comment:         c1:=GraphNode.Next(g.gnode,c);
                      ^ graph.adb:82:23:VC_PRECONDITION" "GP_Shape:L_3_while__c1_assign__call_next" (Graph__graphnode__next.next((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content)) ) ) );
      ( "GP_Sloc:graph.adb:83:77" ( () (* Translation of an Ada loop from graph.adb:83 *)
      ;
      (if (( #"graph.adb" 83 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:83:25" "GP_Id:40" "comment:         while GraphNode.Has_Element(Container => g.gnode, Position  => c1) loop
                        ^ graph.adb:83:25:VC_PRECONDITION" "GP_Shape:L_3_while__L_4_while__call_has_element" (Graph__graphnode__has_element.has_element((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content)) )) then (
       try
        ( () (* First unroling of the loop statements appearing before the loop invariant of loop graph.adb:83 *)
        ;
        () (* While loop translating the Ada loop from graph.adb:83 *)
        ;
        #"graph.adb" 83 0 0# while True do
         ( () (* Assume implicit invariants from the loop graph.adb:83 *)
         ;
         #"graph.adb" 83 0 0# assume { (Boolean.andb((Boolean.andb((Boolean.andb((Boolean.andb((Graph__graphnode__cursor__axiom.dynamic_invariant Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content False True True)) ((Standard__integer__axiom.dynamic_invariant Graph__diameter__diameter.diameter.int__content False True True)))) ((Standard__integer__axiom.dynamic_invariant Graph__diameter__value.value.int__content False True True)))) ((Graph__node__axiom.dynamic_invariant Graph__diameter__target.target.int__content False True True)))) (((Graph__graphnode__has_element.has_element__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields Graph__diameter__g.g))) Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content) = True))) };
         () (* Check for absence of RTE in the invariant of loop graph.adb:83 *)
         ;
         () (* Loop statements appearing after the loop invariant of loop graph.adb:83 *)
         ;
         ( "GP_Sloc:graph.adb:84:20" #"graph.adb" 84 0 0# Graph__diameter__target.target.int__content <- ( ( #"graph.adb" 84 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:84:32" "GP_Id:37" "comment:            target := GraphNode.Element(g.gnode,c1);
                               ^ graph.adb:84:32:VC_PRECONDITION" "GP_Shape:L_3_while__L_4_while__target_assign__call_element" (Graph__graphnode__element.element((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content)) ) ) );
         ( "GP_Sloc:graph.adb:85:18" #"graph.adb" 85 0 0# Graph__diameter__value.value.int__content <- ( ( #"graph.adb" 85 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:85:21" "GP_Id:38" "comment:            value:= distance(source => source,target => target,g => g);
                    ^ graph.adb:85:21:VC_PRECONDITION" "GP_Shape:L_3_while__L_4_while__value_assign__call_distance" (Graph__distance__axiom.distance(Graph__diameter__source.source.int__content) (Graph__diameter__target.target.int__content) (Graph__diameter__g.g)) ) ) );
         ( "GP_Sloc:graph.adb:87:15" #"graph.adb" 87 0 0# Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content <- ( ( #"graph.adb" 87 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:87:27" "GP_Id:39" "comment:            c1:= GraphNode.Next(g.gnode, c1);
                          ^ graph.adb:87:27:VC_PRECONDITION" "GP_Shape:L_3_while__L_4_while__c1_assign__call_next" (Graph__graphnode__next.next((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content)) ) ) );
         ( "GP_Sloc:graph.adb:88:16" (if ((Graph__diameter__value.value.int__content >= Graph__diameter__diameter.diameter.int__content)) then (
          ( "GP_Sloc:graph.adb:89:27" #"graph.adb" 89 0 0# Graph__diameter__diameter.diameter.int__content <- ( Graph__diameter__value.value.int__content ) )) else (
          ())) );
         () (* Check for the exit condition and loop statements appearing before the loop invariant of loop graph.adb:83 *)
         ;
         (if (( #"graph.adb" 83 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:83:25" "GP_Id:40" "comment:         while GraphNode.Has_Element(Container => g.gnode, Position  => c1) loop
                        ^ graph.adb:83:25:VC_PRECONDITION" "GP_Shape:L_3_while__L_4_while__call_has_element" (Graph__graphnode__has_element.has_element((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c1.c1.Graph__graphnode__cursor.cursor__content)) )) then (
          ()) else (
          #"a-cforse.ads" 86 0 0# raise Graph__diameter__L_4.L_4)) )
        done )
       with
        Graph__diameter__L_4.L_4 -> ()
       end)) ) );
      ( "GP_Sloc:graph.adb:92:14" #"graph.adb" 92 0 0# Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content <- ( ( #"graph.adb" 92 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:92:26" "GP_Id:41" "comment:            c:= GraphNode.Next(g.gnode,c);
                         ^ graph.adb:92:26:VC_PRECONDITION" "GP_Shape:L_3_while__c_assign__call_next" (Graph__graphnode__next.next((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content)) ) ) );
      () (* Check for the exit condition and loop statements appearing before the loop invariant of loop graph.adb:80 *)
      ;
      (if (( #"graph.adb" 80 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:80:22" "GP_Id:42" "comment:      while GraphNode.Has_Element(Container => g.gnode,Position  => c) loop
                     ^ graph.adb:80:22:VC_PRECONDITION" "GP_Shape:L_3_while__call_has_element" (Graph__graphnode__has_element.has_element((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__diameter__g.g))))))) (Graph__diameter__c.c.Graph__graphnode__cursor.cursor__content)) )) then (
       ()) else (
       #"a-cforse.ads" 86 0 0# raise Graph__diameter__L_3.L_3)) )
     done )
    with
     Graph__diameter__L_3.L_3 -> ()
    end)) ) );
   ( "GP_Sloc:graph.adb:94:10" ( #"graph.adb" 94 0 0# graph__diameter__result.int__content <- ( Graph__diameter__diameter.diameter.int__content );
   #"graph.adb" 94 0 0# raise Return__exc ) );
   #"graph.adb" 70 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:55 *)
  ;
  #"graph.adb" 70 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__diameter__result.int__content )
end

(* Module for checking contracts and absence of run-time errors in subprogram "small" defined at graph.ads:58, created in Gnat2Why.Subprograms.Generate_VCs_For_Subprogram *)
module Graph__small__subprogram_def
 use import "_gnatprove_standard".Main
 use import "int".Int
 use        "_gnatprove_standard".Boolean
 use        Standard__integer
 use        Standard__integer__axiom
 use        Graph__graphnode__set
 use        Graph__graphnode__length
 use        Graph__graphnode__is_empty
 use        Graph__graphedge__set
 use        Graph__graphedge__is_empty
 use        Graph__mygraph__T95s
 use        Graph__mygraph__T97s
 use        Graph__mygraph
 use        Graph__mygraph__axiom
 use        Graph__diameter__axiom
 use        Graph__small__x
 use        Graph__small__g
 use        Graph__small__diametervalue
 use        Graph__small__nodenumber
 use        Standard__integer__axiom
 use        Standard__integer__axiom
 use        Graph__small__diametervalue__axiom
 use        Graph__small__nodenumber__axiom
 use        Graph__node__axiom
 use        Graph__edge__axiom
 use        Graph__Olt__axiom
 use        Graph__mygraph__axiom
 use        Graph__diameter__axiom
 use        Graph__small__x__axiom
 use        Graph__small__g__axiom
 use        Ada__containers__count_type__axiom
 use        Graph__mygraph__T95s__axiom
 use        Graph__mygraph__T97s__axiom

 val graph__small__result #"system.ads" 1 0 0# "model" "model_trace:3600@result"  : bool__ref 
 
 let def #"system.ads" 1 0 0# "W:diverges:N" "GP_Subp:graph.ads:58" 
   (__void_param : unit)
  requires { true }
  ensures { true }
   =
  ( () (* Assume dynamic invariants of inputs of the subprogram graph.ads:58 *)
  ;
  #"system.ads" 1 0 0# assume { (Standard__integer__axiom.dynamic_invariant Graph__small__x.x True False True) };
  #"graph.ads" 28 0 0# assume { (Graph__mygraph__axiom.dynamic_invariant Graph__small__g.g True False True) };
  () (* Declarations introduced by the compiler at the beginning of the subprogram graph.ads:58 *)
  ;
  () (* Check for RTE in the Pre of the subprogram graph.ads:58 *)
  ;
  #"graph.ads" 58 0 0# abstract ensures {true}(let _ = (Boolean.andb(((Boolean.to_int(( #"graph.ads" 59 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:pragargs__and__cmp__call_is_empty" "GP_Sloc:graph.ads:59:27" "GP_Id:48" "comment:     with Pre => GraphNode.Is_Empty(Container => g.gnode)=False and GraphEdge.Is_Empty(Container => g.gedge)=False;
                          ^ graph.ads:59:27:VC_PRECONDITION" (Graph__graphnode__is_empty.is_empty((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__small__g.g)))))))) ))) = (Boolean.to_int((Boolean.of_int(0)))))) (((Boolean.to_int(( #"graph.ads" 59 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Shape:pragargs__and__cmp__call_is_empty" "GP_Sloc:graph.ads:59:78" "GP_Id:49" "comment:     with Pre => GraphNode.Is_Empty(Container => g.gnode)=False and GraphEdge.Is_Empty(Container => g.gedge)=False;
                                                                             ^ graph.ads:59:78:VC_PRECONDITION" (Graph__graphedge__is_empty.is_empty((Graph__mygraph__T97s.to_base((Graph__mygraph.rec__gedge((Graph__mygraph.__split_fields(Graph__small__g.g)))))))) ))) = (Boolean.to_int((Boolean.of_int(0))))))) in (
   ()))
   end ;
  () (* Assume Pre of the subprogram graph.ads:58 *)
  ;
  #"graph.ads" 59 0 0# assume { ( ( ((Graph__graphnode__is_empty.is_empty__logic (Graph__mygraph__T95s.to_base (Graph__mygraph.rec__gnode (Graph__mygraph.__split_fields Graph__small__g.g)))) = True) <-> false ) /\ ( ((Graph__graphedge__is_empty.is_empty__logic (Graph__mygraph__T97s.to_base (Graph__mygraph.rec__gedge (Graph__mygraph.__split_fields Graph__small__g.g)))) = True) <-> false ) ) };
  () (* checking of pragma precondition graph.ads:58 *)
  ;
  try
   ( #"system.ads" 1 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 98 0 0# assume { (Standard__integer__axiom.default_initial_assumption Graph__small__diametervalue.diametervalue.int__content False) };
   #"system.ads" 1 0 0# assume { (Standard__integer__axiom.dynamic_invariant Graph__small__diametervalue.diametervalue.int__content False False True) };
   #"system.ads" 1 0 0# abstract ensures {true}(let _ = () in (
    ()))
    end ;
   #"graph.adb" 99 0 0# assume { (Standard__integer__axiom.default_initial_assumption Graph__small__nodenumber.nodenumber.int__content False) };
   #"system.ads" 1 0 0# assume { (Standard__integer__axiom.dynamic_invariant Graph__small__nodenumber.nodenumber.int__content False False True) };
   ( "GP_Sloc:graph.adb:102:18" #"graph.adb" 102 0 0# Graph__small__nodenumber.nodenumber.int__content <- ( ( #"graph.adb" 102 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:102:38" "GP_Id:45" "comment:      nodenumber := Integer(GraphNode.Length(Container => g.gnode));
                                     ^ graph.adb:102:38:VC_PRECONDITION" "GP_Shape:nodenumber_assign__typeconv__call_length" (Graph__graphnode__length.length((Graph__mygraph__T95s.to_base((Graph__mygraph.rec__gnode((Graph__mygraph.__split_fields(Graph__small__g.g)))))))) ) ) );
   ( "GP_Sloc:graph.adb:103:21" #"graph.adb" 103 0 0# Graph__small__diametervalue.diametervalue.int__content <- ( ( #"graph.adb" 103 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_PRECONDITION" "GP_Sloc:graph.adb:103:24" "GP_Id:46" "comment:      diametervalue := diameter(g);
                       ^ graph.adb:103:24:VC_PRECONDITION" "GP_Shape:diametervalue_assign__call_diameter" (Graph__diameter__axiom.diameter(Graph__small__g.g)) ) ) );
   ( "GP_Sloc:graph.adb:104:7" (if ((( #"graph.adb" 104 0 0# "model_vc" "keep_on_simp" "GP_Reason:VC_OVERFLOW_CHECK" "GP_Sloc:graph.adb:104:12" "GP_Id:47" "comment:      if( x*diametervalue >= nodenumber) then
           ^ graph.adb:104:12:VC_OVERFLOW_CHECK" "GP_Shape:if__cmp__mult" (Standard__integer.range_check_((Graph__small__x.x * Graph__small__diametervalue.diametervalue.int__content))) ) >= Graph__small__nodenumber.nodenumber.int__content)) then (
    ( "GP_Sloc:graph.adb:105:10" ( #"graph.adb" 105 0 0# graph__small__result.bool__content <- ( (Boolean.of_int(1)) );
    #"graph.adb" 105 0 0# raise Return__exc ) )) else (
    ( "GP_Sloc:graph.adb:107:10" ( #"graph.adb" 107 0 0# graph__small__result.bool__content <- ( (Boolean.of_int(0)) );
    #"graph.adb" 107 0 0# raise Return__exc ) ))) );
   #"graph.adb" 97 0 0# raise Return__exc )
  with
   Return__exc -> ()
  end;
  () (* checking of pragma postcondition graph.ads:58 *)
  ;
  #"graph.adb" 97 0 0# abstract ensures {true}(let _ = True in (
   ()))
   end ;
  graph__small__result.bool__content )
end
